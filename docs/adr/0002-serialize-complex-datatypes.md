# The MVP will pass complex datatypes over the FFI using simple, explicit serialization

* Status: accepted
* Deciders: rfkelly
* Date: 2020-07-01 (or thereabouts)

## Context and Problem Statement

Passing complex data-types from Rust to foreign-language code and back again can be, well, *complex*.
Given a Rust struct with named fields, and a corresponding autogenerated data class in the foreign language
bindings, how does one turn into the other?

## Decision Drivers

* Ensuring safety of the generated code.
* Fitting with our [MVP goal](./0001-mvp-webidl.md) of favouring initial-time-to-ship over performance.

## Considered Options

* Option A: Declare complex datatypes using Protocol Buffers, pass them as serialized bytes.
* Option B: Declare complex datatypes `[#repr(C)]` structs and pass them directly.
* Option C: Implement a simple direct serialization scheme, pass them as serialized bytes.

## Decision Outcome

Chosen option:
  * **Option C: Implement a simple direct serialization scheme, pass them as serialized bytes.**

The choice here comes down to simplicity and safety for the MVP.

Serializing complex datatypes into a bytebuffer makes it easier for us to pass the data safely across the FFI,
because it strictly controls shared access to memory on each side of the boundary. Using our own simple
serialization scheme reducing the number of moving parts relative to third-party serialization libraries.

This choice comes with non-trivial performance costs, but that's acceptable for MVP.
We are likely to ***revisit this choice*** if the MVP of the tool proves successful
and expect that we can do so incrementally without changing the consumer-facing experience.

## Pros and Cons of the Options

### Option A: Declare complex datatypes using Protocol Buffers, pass them as serialized bytes.

Following the approach currently taken by hand-written component bindings in application-services,
we could generate a Protocol Buffers schema for each complex data type, and use generated serialization
code to send it across the FFI as a bytebuffer.

* Good, because we're familiar with this approach from our existing components.
* Good, because Protocol Buffers exist and have decent tooling for generating serialization code
  in our various target languages.
* Good, because it's hard to mis-handle the data in a way that introduces memory-safety issues.
* Bad, because we'd be calling the protobuf code-generator from inside our own code-generator,
  which seems like a very complex setup.
* Bad, because there's likely to be a noticeable serialization-related performance overhead.
* Bad, because Protocol Buffers contain some complexity that isn't useful for our use-case, such
  as affordances for backwards-compatibility.

A similar set of considerations apply to other third-party serialization schems such as flatbuffers,
with the added disadvantage of unfamiliarity.

Ultimately, the additional build complexity of integrating a code-generator inside our own code generator
makes this option unattractive.

### Option B: Declare complex datatypes `[#repr(C)]` structs and pass them directly.

Following the approach currently taken by hand-written component bindings in the glean project,
we could generate a `#[repr(C)]` struct for each complex data type and a corresponding struct
in the foreign language bindings, then pass structs directly across the FFI boundary either
by value or as pointers.

* Good, it has minimal serialization overhead.
* Good, because it can avoid copying data from rust-memory to foreign-language-memory.
* Bad, because using raw pointers gives more opportunities for memory-safety issues.
* Bad, because it's not obvious how to handle nested values without using raw pointers.
* Bad, because the codegen seems likely to be more complex than other options.

Ultimately, given that our MVP explicitly prioritizes features over performance, this option
is not a good choice for the MVP. It seems worthwhile revisiting as an option for post-MVP
when performance becomes more important.

### Option C: Implement a simple direct serialization scheme, pass them as serialized bytes.

We could invent a very simple serialization scheme without all the bells-and-whistles of Protocol Buffers,
and serialize complex data types to send them across the FFI as a bytebuffer.

* Good, because this is similar to the familiar protocol-buffers approach.
* Good, because we can directly codegen the serialization logic as part of generating other code for
  the data structure.
* Good, because it's hard to mis-handle the data in a way that introduces memory-safety issues.
* Bad, because we might introduce bugs in a new codebase that have already been shaken out in
  a more mature third-party serialization library.
* Bad, because there's likely to be a noticeable serialization-related performance overhead.

Ultimately, the simplicity and safety of this approach make it the best choice for our MVP.

## Links

* [Crossing the Rust FFI frontier with Protocol Buffers](https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/);
  a discussion of how Application Services components pass complex data types by serializing them with
  protocol buffers, and deserializing on the other side.
* [This Week in Glean: Bytes in Memory (on Android)](https://fnordig.de/2020/05/04/this-week-in-glean/);
  a discussion of how the Glean library passes complex data types by mapping them into `repr(c)` structs.
