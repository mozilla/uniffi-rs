# External types which wrap primitive types

*Note: The facility described in this document is not yet available for all foreign language
bindings.*

It's possible to expose types in your Rust crate to UniFFI, so long as the type can
be expressed as one of UniFFI's [builtin_types](./builtin_types.md).

For example, consider the following trivial Rust abstraction for a "handle" which wraps an
integer:

```rust
pub struct Handle(i64);
```

You can use this type in your udl by declaring it via a `typedef` with a `Wrapped` attribute,
defining the primitive type which it wraps.

```idl
[Wrapped]
typedef i64 Handle;
```

For this to work, your Rust code must also implement a special trait named
`UniffiCustomTypeWrapper`. This trait is generated by UniFFI and can be found in the generated
Rust scaffolding - it is defined as:

```Rust
trait UniffiCustomTypeWrapper {
    type Wrapped;

    fn wrap(val: Self::Wrapped) -> uniffi::Result<Self>
    where
        Self: Sized;
    fn unwrap(obj: Self) -> Self::Wrapped;
}
```

where `Wrapped` is the Rust type being wrapped - `i64` in the example above. Thus, the trait
implemention for `Handle` would look something like:

```rust
impl UniffiCustomTypeWrapper for Handle {
    type Wrapped = i64;

    fn wrap(val: Self::Wrapped) -> uniffi::Result<Self> {
        Ok(Handle(val))
    }

    fn unwrap(obj: Self) -> Self::Wrapped {
        obj.0
    }
}
```

Because `UniffiCustomTypeWrapper` is defined in each crate, this means you can wrap objects even
if they are not defined in your crate - see the 'wrapper_types' example which demonstrates
how `serde_json::Value` can be wrapped.

## Error handling during conversion

You might have noticed that the `wrap` function returns a `uniffi::Result<Self>` (which is an
alias for `anyhow::Result`) and might be wondering what happens if you return an `Err`.

It depends on the context. In short:

* If the value is being used as an argument to a function/constructor that does not return
  a `Result` (ie, does not have the `throws` attribute in the .udl), then the uniffi generated
  scaffolding code will `panic!()`

* If the value is being used as an argument to a function/constructor that *does* return a
  `Result` (ie, does have a `throws` attribute in the .udl), then the uniffi generated
  scaffolding code will use `anyhow::Error::downcast()` to try and convert the failure into
  that declared error type and:
  * If that conversion succeeds, it will be used as the `Err` for the function.
  * If that conversion fails, it will `panic()`

### Example
For example, consider the following UDL:
```idl
[Wrapped]
typedef i64 Handle;

[Error]
enum ExampleErrors {
    "InvalidHandle"
};

namespace errors_example {
    take_handle_1(Handle handle);

    [Throws=ExampleErrors]
    take_handle_2(Handle handle);
}
```

and the following Rust:
```rust
#[derive(Debug, thiserror::Error)]
pub enum ExampleErrors {
    #[error("The handle is invalid")]
    InvalidHandle,
}

impl UniffiCustomTypeWrapper for ExampleHandle {
    type Wrapped = i64;

    fn wrap(val: Self::Wrapped) -> uniffi::Result<Self> {
        if (val == 0) {
            Err(ExampleErrors::InvalidHandle.into())
        else if (val == -1) {
            Err(SomeOtherError.into()) // SomeOtherError decl. not shown.
        } else {
            Ok(Handle(val))
        }
    }
    ...
}
```

The behavior of the generated scaffolding will be:

* Calling `take_handle_1` with a value of `0` or `-1` will always panic.
* Calling `take_handle_2` with a value of `0` will return `Err(ExampleErrors)` exception
* Calling `take_handle_2` with a value of `-1` will always panic.
* All other values will return `Ok(ExampleHandle)`

## Custom Foreign Wrappers

In the example above, the foreign bindings just see the "wrapped" value - eg, the bindings will
get an integer for the `Handle`.

We intend on making it possible to customize this - for example, `serde_json::Value` could be
transformed into a suitable JSON object in the bindings.

## Using Wrapped Types from other crates

To use the `Handle` example above from another crate, these other crates just refer to the type
as a regular `External` type - for example, another crate might use `udl` such as:

```idl
[External="crate_defining_handle_name"]
typedef extern Handle;
```
