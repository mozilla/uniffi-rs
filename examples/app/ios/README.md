# Using `uniffi` with iOS

Getting a Rust library working with `uniffi` and iOS has a few working parts.

For this example, we'll build a small app linked to one of the `uniffi` examples, the `todolist`.

This will not be a complete tutorial on how to use `uniffi`, just the bits to get it running with Xcode and iOS.

## Install Rust compiler targets with `rustup`

```sh
% rustup target add x86_64-apple-ios aarch64-apple-ios
```

## Associate the iOS project with the Rust project

1. In Xcode, right click on the project in the Project Navigator.
2. Add a file to the iOS project
3. Find the `udl` file in the Rust project.

## Tell Xcode what to do with `udl` files.

1. In Xcode, click on the project in the Project Navigator.
2. In the main window, select the app's main target, and then select "Build Rules".
3. Add a custom rule, to process sources files with names matching `*.udl`.
4. Use `uniffi-bindgen` on each file to generate the headers and swift scaffolding.

```sh
$HOME/.cargo/bin/uniffi-bindgen generate "$INPUT_FILE_PATH" --language swift --out-dir "$DERIVED_FILE_DIR"
```

These will output two files Xcode is interested in.

```sh
$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).swift
$(DERIVED_FILE_DIR)/uniffi_$(INPUT_FILE_BASE)-Bridging-Header.h
```

The header file is a descriptor of the C API to a library that hasn't been built yet. The Swift file is a Swift facade that calls that C API.

## Tell `swiftc` about the generated header files

1. In Xcode, click on the project in the Project Navigator.
2. In the main window, select the app's main target, and then select "Build Settings".
3. Search for `Objective C Bridging Header`, and add one if needed. For our example app, we've called it `IOSApp-Bridging-Header.h`.
4. It should be generated for you, but it should look like:

```h
#ifndef IOSApp_Bridging_Header_h
#define IOSApp_Bridging_Header_h

#import "todolist-Bridging-Header.h"

#endif /* IOSApp_Bridging_Header_h */
```

The `#import` directive points to the header file generated by `uniffi-bindgen generate` aboveâ€” `$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE)-Bridging-Header.h`

```h
#import "todolist-Bridging-Header.h"
```

This `IOSApp-Bridging-Header.h` tells Xcode to look for the header file; because it's in `DERIVED_FILE_DIR`, Xcode should know where to look.

## Configure `cargo` to build the crate as a static library

1. In the `Cargo.toml` file of the Rust project, add `staticlib` to the `crate-type` list.

```toml
[lib]
crate-type = ["staticlib", "cdylib"]
name = "uniffi_todolist"
```

The `package` `name` and the `lib` `name` will be used below. In this case, the package name is `uniffi-example-todolist` and the lib name is `uniffi_todolist`.

## Tell Xcode how to build the Rust project.

#### TODO use a better explanation of what is going on here

1. In Xcode, click on the project in the Project Navigator.
2. In the main window, select the app's main target, and then select "Build Phases".
3. Add a new `Run Script` build phase and move it to the top.
4. Add the script that will build a universal binary for the Rust project.

For this project, we've used a script adapted from the #mozilla/application-services project to build a universal binary with `lipo`.

```sh
bash $SRCROOT/xc-universal-binary.sh libuniffi_todolist.a uniffi-example-todolist $SRCROOT/../../../ $CONFIGURATION
```

In this case we constructed the command:

```sh
xc-universal-binary.sh <STATIC_LIB_NAME> <FFI_TARGET> <WORKSPACE_PATH> <BUILD_CONFIGURATION>"
```

by making:

 * `STATIC_LIB_NAME` from the `lib` `name` above: `uniffi_todolist` --> `libuniffi_todolist.a`
 * `FFI_TARGET` from the `package` `name` above: `uniffi-example-todolist`.

The workspace path is where the `Cargo.toml` will resolve the Rust project, and also determine the target directory that `cargo build` and `lipo` will put its artifacts.

This script performs a few steps:

1. Runs `cargo build` to compile the Rust project for the `x86_64-apple-ios` and `aarch64-apple-ios` targets.
    * This includes using `uniffi-bindgen` to generate the Rust scaffolding so we can go from C to Rust.
2. Runs `lipo` to combine these libs in to a universal binary.
3. Puts the universal binary in to the `$WORKSPACE_PATH/target/universal` directory.

## Tell Xcode where the universal library is

Finally, we need to tell Xcode to look for the universal binary `libuniffi_todolist.a` is, so it can tie it together with the header file `todolist-Bridging-Header.h`.

1. In Xcode, click on the project in the Project Navigator.
2. In the main window, select the app's main target, and then select "Build Settings".
3. Search for `Library Search Paths`.
4. Add paths to where lipo constructed the universal binaries for each of `Debug` and `Release`.

```sh
$(SRCROOT)/../../../target/universal/debug
$(SRCROOT)/../../../target/universal/release
```

## Back to code.

By now, we should've 

1. Used `uniffi-bindgen` to generate a Swift file to call a C API header and put them in a place Xcode can find them.
2. Configured Xcode to find the header.
3. Configured cargo to build a static library version of the crate.
4. Used `uniffi-bindgen` to generate a C API for the Rust crate.
5. Used cargo to cross-compile the crate for different targets.
6. Used lipo to combine those crates for different target into a universal binary.
7. Configured Xcode to find the universal binary.

By now, we should be able to hit Run in Xcode and build something.

Once this builds and runs okay, we should be able to start using the library in Swift.

We don't need to import anything. We should be able to start using the Swift bindings which will start talking to the Rust code.

```swift
let todolist = TodoList()
todolist.addEntry(entry: TodoListEntry(text: "Make uniffi work on iOS"))
```

When you need to make a change to the Rust API, add the Rust parts, then the UDL, and Xcode should pick up the changes on the next build.
