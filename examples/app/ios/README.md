# Using `uniffi` with iOS

Getting a Rust library working with `uniffi` and iOS has a few working parts.

For this example, we'll build a small app linked to one of the `uniffi` examples, the `todolist`.

This will not be a complete tutorial on how to use `uniffi`, just the bits to get it running with Xcode and iOS.

## Install Rust compiler targets with `rustup`

```sh
rustup target add x86_64-apple-ios aarch64-apple-ios aarch64-apple-ios-sim
```

## Creating the bindgen binary

See [Creating the bindgen binary](https://mozilla.github.io/uniffi-rs/tutorial/foreign_language_bindings.html#foreign-language-bindings)
for a full guide on how to create a uniffi-bindgen library for your project.

This sample project ships with one in `examples/app/uniffi-bindgen-cli`.

## Associate the iOS project with the Rust project

1. In Xcode, right click on the project in the Project Navigator.
2. Add a file to the iOS project
3. Find the `udl` file in the Rust project.

## Tell Xcode what to do with `udl` files.

1. In Xcode, click on the project in the Project Navigator.
2. In the main window, select the app's main target, and then select "Build Rules".
3. Add a custom rule, to process sources files with names matching `*.udl`.
4. Use your `uniffi-bindgen` binary on each file to generate the headers and swift scaffolding.

```sh
$HOME/.cargo/bin/cargo run -p uniffi-bindgen -- generate "$INPUT_FILE_PATH" --language swift --out-dir "$DERIVED_FILE_DIR"
```

These will output two files Xcode is interested in.

```sh
$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE)FFI.h
$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).swift
```

The header file is a descriptor of the C API to a library that hasn't been built yet. The Swift file is a Swift facade that calls that C API.

## Tell `swiftc` about the generated header files

1. In Xcode, click on the project in the Project Navigator.
2. In the main window, select the app's main target, and then select "Build Settings".
3. Search for `Objective C Bridging Header`, and add one if needed. For our example app, we've called it `IOSApp-Bridging-Header.h`.
4. It should be generated for you, but it should look like:

```h
#ifndef IOSApp_Bridging_Header_h
#define IOSApp_Bridging_Header_h

#import "todolistFFI.h"

#endif /* IOSApp_Bridging_Header_h */
```

The `#import` directive points to the header file generated by `uniffi-bindgen generate` aboveâ€” `$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE)FFI.h`

```h
#import "todolistFFI.h"
```

This `IOSApp-Bridging-Header.h` tells Xcode to look for the header file; because it's in `DERIVED_FILE_DIR`, Xcode should know where to look.

## Configure `cargo` to build the crate as a static library

1. The build script automatically builds a static library (note: this requires rustc 1.64 or newer)

```toml
[lib]
name = "uniffi_todolist"
```

The `package` `name` and the `lib` `name` will be used below. In this case, the package name is `uniffi-example-todolist` and the lib name is `uniffi_todolist`.

## Tell Xcode how to build the Rust project.

1. In Xcode, click on the project in the Project Navigator.
2. In the main window, select the app's main target, and then select "Build Phases".
3. Add a new `Run Script` build phase and move it to the top.
4. Add the script that will build a universal binary for the Rust project.

`uniffi` comes with a script suitable to build a static library for all iOS targets:

```sh
bash $SRCROOT/xc-universal-binary.sh uniffi-example-todolist $SRCROOT/../../../ $CONFIGURATION
```

In this case we constructed the command:

```sh
xc-universal-binary.sh <FFI_TARGET> <WORKSPACE_PATH> <BUILD_CONFIGURATION>"
```

by making:

 * `FFI_TARGET` from the `package` `name` above: `uniffi-example-todolist`.

The workspace path is where the `Cargo.toml` will resolve the Rust project, and also determine the target directory that `cargo build` and `lipo` will put its artifacts.

This script runs `cargo build` to compile the Rust project for the `x86_64-apple-ios`, `aarch64-apple-ios` and `aarch64-apple-ios-sim` targets.
This includes using `uniffi-bindgen` to generate the Rust scaffolding so we can go from C to Rust.

## Tell Xcode where the universal library is

Finally, we need to tell Xcode to look for the libraries based on the target, so it can tie it together with the header file `todolistFFI.h`.

1. In Xcode, click on the project in the Project Navigator.
2. In the main window, select the app's main target, and then select "Build Settings".
3. Search for `Library Search Paths`.
4. Add paths per OS and architecture.
   The OS specific part can be configured in the Xcode project editor,
   but the architecture specific part has to be added by manually editing the `project.pbxproj` file.
   Open `project.pbxproj` in your project directory and add the following in the `Debug` section:

   ```
   "LIBRARY_SEARCH_PATHS[sdk=iphoneos*][arch=arm64]" = "../../../target/aarch64-apple-ios/debug";
   "LIBRARY_SEARCH_PATHS[sdk=iphonesimulator*][arch=arm64]" = "../../../target/aarch64-apple-ios-sim/debug";
   "LIBRARY_SEARCH_PATHS[sdk=iphonesimulator*][arch=x86_64]" = "../../../target/x86_64-apple-ios/debug";
   ```

    The path should be a relative path pointing into the `target` directory created by `cargo`.
    Add a similar block in the `Release` section and adjust the paths accordingly.

## Back to code.

By now, we should've

1. Used `uniffi-bindgen` to generate a Swift file to call a C API header and put them in a place Xcode can find them.
2. Configured Xcode to find the header.
3. Configured cargo to build a static library version of the crate.
4. Used `uniffi-bindgen` to generate a C API for the Rust crate.
5. Used cargo to cross-compile the crate for different targets.
7. Configured Xcode to find the different static libraries.

By now, we should be able to hit Run in Xcode and build something.

Once this builds and runs okay, we should be able to start using the library in Swift.

We don't need to import anything. We should be able to start using the Swift bindings which will start talking to the Rust code.

```swift
let todolist = TodoList()
todolist.addEntry(entry: TodoListEntry(text: "Make uniffi work on iOS"))
```

When you need to make a change to the Rust API, add the Rust parts, then the UDL, and Xcode should pick up the changes on the next build.
