< RenderInfo { template_name: "Common", data: Null }
> "# The non-type specific parts of RustBuffer, RustBufferBuilder, RustBufferStream\n\nclass RustBuffer(ctypes.Structure):\n    _fields_ = [\n        (\"capacity\", ctypes.c_int32),\n        (\"len\", ctypes.c_int32),\n        (\"data\", ctypes.POINTER(ctypes.c_char)),\n    ]\n\n    @staticmethod\n    def alloc(size):\n        return rust_call(_UniFFILib.LIBRARY_NAME, size)\n\n    @staticmethod\n    def reserve(rbuf, additional):\n        return rust_call(_UniFFILib.LIBRARY_NAME, rbuf, additional)\n\n    def free(self):\n        return rust_call(_UniFFILib.LIBRARY_NAME, self)\n\n    def __str__(self):\n        return \"RustBuffer(capacity={}, len={}, data={})\".format(\n            self.capacity,\n            self.len,\n            self.data[0:self.len]\n        )\n\n    @contextlib.contextmanager\n    def allocWithBuilder():\n        \"\"\"Context-manger to allocate a buffer using a RustBufferBuilder.\n\n        The allocated buffer will be automatically freed if an error occurs, ensuring that\n        we don\'t accidentally leak it.\n        \"\"\"\n        builder = RustBufferBuilder()\n        try:\n            yield builder\n        except:\n            builder.discard()\n            raise\n\n    @contextlib.contextmanager\n    def consumeWithStream(self):\n        \"\"\"Context-manager to consume a buffer using a RustBufferStream.\n\n        The RustBuffer will be freed once the context-manager exits, ensuring that we don\'t\n        leak it even if an error occurs.\n        \"\"\"\n        try:\n            s = RustBufferStream(self)\n            yield s\n            if s.remaining() != 0:\n                raise RuntimeError(\"junk data left in buffer after consuming\")\n        finally:\n            self.free()\n\nclass RustBufferBuilder(object):\n    \"\"\"Helper for structured writing of values into a RustBuffer.\"\"\"\n\n    def __init__(self):\n        self.rbuf = RustBuffer.alloc(16)\n        self.rbuf.len = 0\n\n    def finalize(self):\n        rbuf = self.rbuf\n        self.rbuf = None\n        return rbuf\n\n    def discard(self):\n        if self.rbuf is not None:\n            rbuf = self.finalize()\n            rbuf.free()\n\n    @contextlib.contextmanager\n    def _reserve(self, numBytes):\n        if self.rbuf.len + numBytes > self.rbuf.capacity:\n            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)\n        yield None\n        self.rbuf.len += numBytes\n\n    def _pack_into(self, size, format, value):\n        with self._reserve(size):\n            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can\'t figure it out.\n            for i, byte in enumerate(struct.pack(format, value)):\n                self.rbuf.data[self.rbuf.len + i] = byte\n\n    def write(self, value):\n        with self._reserve(len(value)):\n            for i, byte in enumerate(value):\n                self.rbuf.data[self.rbuf.len + i] = byte\n\nclass RustBufferStream(object):\n    \"\"\"Helper for structured reading of values from a RustBuffer.\"\"\"\n\n    def __init__(self, rbuf):\n        self.rbuf = rbuf\n        self.offset = 0\n\n    def remaining(self):\n        return self.rbuf.len - self.offset\n\n    def _unpack_from(self, size, format):\n        if self.offset + size > self.rbuf.len:\n            raise InternalError(\"read past end of rust buffer\")\n        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]\n        self.offset += size\n        return value\n\n    def read(self, size):\n        if self.offset + size > self.rbuf.len:\n            raise InternalError(\"read past end of rust buffer\")\n        data = self.rbuf.data[self.offset:self.offset+size]\n        self.offset += size\n        return data\n\n"

< RenderInfo { template_name: "FFIConverterPrimitiveClass", data: Null }
> "class FFIConverterPrimitive:\n    size = NotImplemented\n    pack_fmt = NotImplemented\n\n\n    @staticmethod\n    def lower(builder, value):\n        builder._pack_into(self.size, self.pack_fmt, value)\n\n    @staticmethod\n    def lift(stream, value):\n        return stream._unpack_from(self.size, self.pack_fmt, value)\n"

< RenderInfo { template_name: "FFIConverterPrimitive", data: Object({"name": String("I32"), "pack_fmt": String(">i"), "size": Number(4)}) }
> "class FFIConverterI32(FFIConverterPrimitive):\n    pack_fmt = >i\n    size = 4\n\n"

< RenderInfo { template_name: "FFIConverterString", data: Null }
> "TODO\n"

< RenderInfo { template_name: "RecordClassDef", data: Object({"fields": Array([Array([String("a"), String("I32")]), Array([String("b"), String("String")])]), "name": String("Foo")}) }
> "class Foo:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n"

< RenderInfo { template_name: "FFIConverterRecord", data: Object({"fields": Array([Array([String("a"), String("I32")]), Array([String("b"), String("String")])]), "name": String("Foo")}) }
> "TODO\n"
