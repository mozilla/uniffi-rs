{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"UniFFI","text":"<p>UniFFI is a tool that automatically generates foreign-language bindings targeting Rust libraries. The repository can be found on github. It fits in the practice of consolidating business logic in a single Rust library while targeting multiple platforms, making it simpler to develop and maintain a cross-platform codebase. Note that this tool will not help you ship a Rust library to these platforms, but it will help you avoid writing bindings code by hand. Related.</p>"},{"location":"index.html#design","title":"Design","text":"<p>UniFFI requires you to describe your interface via either proc-macros or in an Interface Definition Language (based on WebIDL) file. These definitions describe the methods and data structures available to the targeted languages, and are used to generate Rust scaffolding code and foreign-language bindings. This process can take place either during the build process or be manually initiated by the developer.</p> <p></p>"},{"location":"index.html#supported-languages","title":"Supported languages","text":"<p>UniFFI comes with full support for Kotlin, Swift and Python; unless specified otherwise, you can expect all features in this manual will work for these languages.</p> <p>We also have partial legacy support for Ruby; the UniFFI team keeps the existing Ruby support working but tends to not add new features to that language. It seems possible that Ruby support will be split into its own crate at some point, but in the meantime we welcome improvements and contributions to Ruby.</p> <p>There are also many 3rd party bindings - please see our README for references. These languages may require older versions of UniFFI and may have partial or non-existant support for some features; see the documentation for those bindings for details.</p>"},{"location":"Getting_started.html","title":"Getting started","text":"<p>Say your company has a simple <code>math</code> crate with the following <code>lib.rs</code>:</p> <pre><code>fn add(a: u32, b: u32) -&gt; u32 {\n    a + b\n}\n</code></pre> <p>And top brass would like you to expose this business-critical operation to Kotlin and Swift. Don't panic! We will show you how do that using UniFFI.</p>"},{"location":"Motivation.html","title":"Motivation","text":""},{"location":"Motivation.html#what","title":"What?","text":"<p>We're interested in building re-useable components for our browsers. We want to write the code for these components once, in Rust. We want to easily re-use these components from all the different languages and on all the different platforms for which we build browsers, which currently includes JavaScript for PCs, Kotlin for Android, and Swift for iOS.</p> <p>And of course, we want to do this in a way that's convenient, maintainable, and difficult to mess up.</p>"},{"location":"Motivation.html#how","title":"How?","text":"<p>In an aspirational world, we could get this kind of easy cross-language interop for free using wasm_bindgen and webassembly interface types - imagine writing an API in Rust, annotating it with some <code>#[wasm_bindgen]</code> macros, compiling it into a webassembly bundle, and being able to import and use that bundle from any target language, complete with a rich high-level API!</p> <p>That kind of tooling is not available to shipping applications today, but that doesn't mean we can't take a small step in that general direction while the Rust and Wasm ecosystem continues to evolve.</p> <p>Using UniFFI, you can:</p> <ul> <li>Implement your software component as a <code>cdylib</code> crate in Rust; let's say the code is in <code>./src/lib.rs</code>.</li> <li>Optionally, describe parts of your component API using proc-macros directly in <code>lib.rs</code>.</li> <li>Optionally, describe parts of your component API using an Interface Definition Language in a separate file like <code>./src/lib.udl</code>. UniFFI will generate a bunch of boilerplate Rust code that exposes this API as a C-compatible FFI layer, and include it as part of your crate.</li> <li><code>cargo build</code> your crate as normal to produce a shared library.</li> <li>Run <code>uniffi-bindgen generate ... -l kotlin</code> (see the bindgen docs for omitted arg details)   to generate a Kotlin library that can load your shared library   and expose it to Kotlin code using your nice high-level component API!</li> <li>Or <code>-l swift</code> or <code>-l python</code> to produce bindings for other languages.</li> </ul>"},{"location":"Motivation.html#why","title":"Why?","text":"<p>There are plenty of potential ways to solve this problem, and the one that's right for us might not be right for you. You can read a little more about the considerations and trade-offs that lead to the current approach in our Architecture Decision Records, starting with this motivational document.</p>"},{"location":"Motivation.html#why-not","title":"Why Not?","text":"<p>We hope UniFFI will be useful to you! But if you're considering it for your project then here are some tradeoffs you should keep in mind:</p> <ul> <li>UniFFI makes it easy to produce \"good enough\" bindings into Rust from several different target languages.   If you want to call Rust code from just one foreign language, there may be a language-specific   bindings tool that provides more features and better performance.</li> <li>The project is evolving fast, because it's being developed concurrently with its   primary consumers. You should be prepared for frequent releases and non-trivial API churn   (but we'll use semantic versioning to signal breaking changes).</li> <li>UniFFI doesn't provide an end-to-end packaging solution for your Rust code and its generated bindings.   For example, it'll help you generate Kotlin bindings to call into Rust, but it won't help you with   compiling the Rust code to run on Android or with packaging the bindings into an <code>.aar</code> bundle   (but it might be useful as a building-block for such a tool!).</li> </ul> <p>We also have a list of design principles that might help you decide whether this project is a good fit for your needs.</p>"},{"location":"Upgrading.html","title":"Upgrading v0.28.x -&gt; v0.29.x","text":"<p>We've made a number of breaking changes in this release, particularly to:</p> <ul> <li>Custom types: UniffiCustomTypeConverter has been removed.</li> <li>External types: <code>extern</code> has been removed; you must describe the type.</li> </ul>"},{"location":"Upgrading.html#custom-types","title":"Custom types","text":"<p>Custom types still implemented via the <code>UniffiCustomTypeConverter</code> trait must move to proc-macros.</p> <p>Before:</p> <pre><code>impl UniffiCustomTypeConverter for NewCustomType {\n    type Builtin = BridgeType;\n\n    fn into_custom(val: Self::Builtin) -&gt; uniffi::Result&lt;Self&gt; {\n        ...\n    }\n\n    fn from_custom(obj: Self) -&gt; Self::Builtin {\n        ...\n    }\n}\n</code></pre> <p>After:</p> <pre><code>uniffi::custom_type!(NewCustomType, BridgeType, {\n    try_lift: |val| { Ok(...) },\n    lower: |obj| { ... },\n})\n</code></pre> <p>The <code>custom_type!</code> macro is more flexible than the old system - eg, the closures can be omitted in many cases where <code>From</code> and <code>Into</code> exist. See the Custom Types for details.</p>"},{"location":"Upgrading.html#external-types","title":"External Types","text":"<p>External types can no longer be described in UDL via <code>extern</code> - instead, you must specify the type.</p> <p>For example: <pre><code>[External=\"crate_name\"]\ntypedef extern MyEnum;\n</code></pre> is no longer accepted - you must use, eg: <pre><code>[External=\"crate_name\"]\ntypedef enum MyEnum;\n</code></pre></p> <p>Edge-cases broken include:</p> <ul> <li>Different variations of the <code>External</code> attribute (eg, <code>[ExternalInterface]</code>) are no longer supported; eg, <code>[ExternalInterface=\"..\"] typedef extern ...</code> becomes <code>[External=\"..\"] typedef interface ...</code> )</li> <li>The <code>[Rust=..]</code> attribute has been removed - you should just remove the attribute entirely.</li> </ul> <p>See Remote and External Types for more detail.</p>"},{"location":"Upgrading.html#external-custom-types","title":"External Custom Types","text":"<p>Previously you could describe an external Custom Type <code>Url</code> in UDL as: <pre><code>[External=\"crate_name\"]\ntypedef extern Url;\n</code></pre></p> <p>But now you must use: <pre><code>[Custom=\"crate_name\"]\ntypedef string Url; // replace `string` with any appropriate type.\n</code></pre></p>"},{"location":"Upgrading.html#remote-types","title":"Remote Types","text":"<p>Remote types in UDL now need the <code>[Remote]</code> attribute: <pre><code>[Remote]\ndictionary RemoteRecord {\n    ...\n};\n</code></pre></p> <p>The macros <code>ffi_converter_forward</code> and all <code>use_*</code> macros (eg, <code>use_udl_record!</code>, <code>use_udl_object!</code>, <code>use_udl_enum!</code> etc) are now unnecessary so have been removed.</p> <p>See Remote and External Types for more detail.</p>"},{"location":"Upgrading.html#shared-rustudl-types","title":"Shared Rust/UDL types","text":"<p>The <code>Rust</code> attribute has been removed - use the same typedef syntax described above for External Types.</p> <p><pre><code>[Rust=\"record\"]\ntypedef extern One;\n</code></pre> becomes a <code>typedef</code> with no attributes <pre><code>typedef record One;\n</code></pre></p>"},{"location":"bindings.html","title":"Generating bindings","text":"<p>Bindings is the term used for the code generates for foreign languages which integrate with Rust crates - that is, the generated Python, Swift or Kotlin code which drives the examples.</p> <p>UniFFI comes with a <code>uniffi_bindgen</code> which generates these bindings. For introductory information, see Foreign Language Bindings in the tutorial</p>"},{"location":"bindings.html#customizing-the-binding-generation","title":"Customizing the binding generation.","text":"<p>Each of the bindings reads a file <code>uniffi.toml</code> in the root of a crate which supports various options which influence how the bindings are generated. Default options will be used if this file is missing.</p> <p><code>--config</code> option can be used to specify additional uniffi config file. This config is merged with the <code>uniffi.toml</code> config present in each crate, with its values taking precedence.</p> <p>Each binding supports different options, so please see the documentation for each binding language.</p>"},{"location":"describing.html","title":"Describing the interface","text":"<p>UniFFI allows you to define your object model using both Procedural Macros and via stand-alone UDL files.</p> <p>Each library can choose to use either or both of these techniques.</p>"},{"location":"foreign_traits.html","title":"Foreign traits","text":"<p>UniFFI traits can be implemented by foreign code. This means traits implemented in Python/Swift/Kotlin etc can provide Rust code with capabilities not easily implemented in Rust, such as:</p> <ul> <li>device APIs not directly available to Rust.</li> <li>provide glue to clip together Rust components at runtime.</li> <li>access shared resources and assets bundled with the app.</li> </ul>"},{"location":"foreign_traits.html#example","title":"Example","text":"<p>To implement a Rust trait in a foreign language, you might:</p>"},{"location":"foreign_traits.html#1-define-a-rust-trait","title":"1. Define a Rust trait","text":"<p>This toy example defines a way of Rust accessing a key-value store exposed by the host operating system (e.g. the key chain).</p> <p>All methods of the Rust trait should return a <code>Result&lt;&gt;</code> with the error half being a compatible error type - see below for more on error handling.</p> <p>For example:</p> <pre><code>pub trait Keychain: Send + Sync + Debug {\n  fn get(&amp;self, key: String) -&gt; Result&lt;Option&lt;String&gt;, KeyChainError&gt;;\n  fn put(&amp;self, key: String, value: String) -&gt; Result&lt;(), KeyChainError&gt;;\n}\n</code></pre> <p>If you are using macros add <code>#[uniffi::export(with_foreign)]</code> above the trait. Otherwise define this trait in your UDL file:</p> <pre><code>[Trait, WithForeign]\ninterface Keychain {\n    [Throws=KeyChainError]\n    string? get(string key);\n\n    [Throws=KeyChainError]\n    void put(string key, string data);\n};\n</code></pre> <p>The <code>with_foreign</code> / <code>WithForeign</code> attributes specify that you want to enable support for foreign implementations of that trait as well as Rust ones. Note that references in foreign trait methods aren't supported, so all parameters must be passed by value.</p>"},{"location":"foreign_traits.html#2-allow-it-to-be-passed-into-rust","title":"2. Allow it to be passed into Rust","text":"<p>Here, we define a new object with a constructor which takes a keychain.</p> <pre><code>interface Authenticator {\n    constructor(Keychain keychain);\n    void login();\n};\n</code></pre> <p>In Rust we'd write:</p> <pre><code>struct Authenticator {\n  keychain: Arc&lt;dyn Keychain&gt;,\n}\n\nimpl Authenticator {\n  pub fn new(keychain: Arc&lt;dyn Keychain&gt;) -&gt; Self {\n    Self { keychain }\n  }\n\n  pub fn login(&amp;self) {\n    let username = self.keychain.get(\"username\".into());\n    let password = self.keychain.get(\"password\".into());\n  }\n}\n</code></pre>"},{"location":"foreign_traits.html#3-create-a-foreign-language-implementation-of-the-trait","title":"3. Create a foreign language implementation of the trait","text":"<p>Here's a Kotlin implementation:</p> <pre><code>class KotlinKeychain: Keychain {\n    override fun get(key: String): String? {\n        // \u2026 elide the implementation.\n        return value\n    }\n    override fun put(key: String) {\n        // \u2026 elide the implementation.\n    }\n}\n</code></pre> <p>\u2026and Swift:</p> <pre><code>class SwiftKeychain: Keychain {\n    func get(key: String) -&gt; String? {\n        // \u2026 elide the implementation.\n        return value\n    }\n    func put(key: String) {\n        // \u2026 elide the implementation.\n    }\n}\n</code></pre>"},{"location":"foreign_traits.html#4-pass-the-implementation-to-rust","title":"4. Pass the implementation to Rust","text":"<p>Again, in Kotlin</p> <pre><code>val authenticator = Authenticator(KotlinKeychain())\n// later on:\nauthenticator.login()\n</code></pre> <p>and in Swift:</p> <pre><code>let authenticator = Authenticator(SwiftKeychain())\n// later on:\nauthenticator.login()\n</code></pre> <p>Care is taken to ensure that things are cleaned up in the foreign language once all Rust references drop.</p>"},{"location":"foreign_traits.html#avoid-cycles","title":"\u26a0\ufe0f  Avoid cycles","text":"<p>Foreign trait implementations make it easy to create cycles between Rust and foreign objects causing memory leaks. For example a foreign implementation holding a reference to a Rust object which also holds a reference to the same foreign implementation.</p> <p>UniFFI doesn't try to help here and there's no universal advice; take the usual precautions.</p>"},{"location":"foreign_traits.html#error-handling","title":"Error handling","text":"<p>We must handle foreign code failing, so all methods of the Rust trait should return a <code>Result&lt;&gt;</code> with a compatible error type otherwise these errors will panic.</p>"},{"location":"foreign_traits.html#unexpected-error-handling","title":"Unexpected Error handling.","text":"<p>So long as your function returns a <code>Result&lt;&gt;</code>, it's possible for you to define how \"unexpected\" errors (ie, errors not directly covered by your <code>Result&lt;&gt;</code> type, panics, etc) are converted to your <code>Result&lt;&gt;</code>'s <code>Err</code>.</p> <p>If your code defines a <code>From&lt;uniffi::UnexpectedUniFFICallbackError&gt;</code> impl for your error type, then those errors will be converted into your error type which will be returned to the Rust caller. If your code does not define this implementation the generated code will panic. In other words, you really should implement this!</p> <p>See our callbacks example for more.</p>"},{"location":"futures.html","title":"Async/Future support","text":"<p>UniFFI supports exposing async Rust functions over the FFI. It can convert a Rust <code>Future</code>/<code>async fn</code> to and from foreign native futures (<code>async</code>/<code>await</code> in Python/Swift, <code>suspend fun</code> in Kotlin etc.)</p> <p>Check out the examples or the more terse and thorough fixtures.</p> <p>We've also documentation on the internals of how this works.</p>"},{"location":"futures.html#example","title":"Example","text":"<p>This is a short \"async sleep()\" example: <pre><code>use std::time::Duration;\nuse async_std::future::{timeout, pending};\n\n/// Async function that says something after a certain time.\n#[uniffi::export]\npub async fn say_after(ms: u64, who: String) -&gt; String {\n    let never = pending::&lt;()&gt;();\n    timeout(Duration::from_millis(ms), never).await.unwrap_err();\n    format!(\"Hello, {who}!\")\n}\n</code></pre></p> <p>This can be called by the following Python code: <pre><code>import asyncio\nfrom uniffi_example_futures import *\n\nasync def main():\n    print(await say_after(20, 'Alice'))\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre></p> <p>Async functions can also be defined in UDL: <pre><code>namespace example {\n    [Async]\n    string say_after(u64 ms, string who);\n}\n</code></pre></p> <p>This code uses <code>asyncio</code> to drive the future to completion, while our exposed function is used with <code>await</code>.</p> <p>In Rust <code>Future</code> terminology this means the foreign bindings supply the \"executor\" - think event-loop, or async runtime. In this example it's <code>asyncio</code>. There's no requirement for a Rust event loop.</p> <p>There are some great API docs on the implementation that are well worth a read.</p>"},{"location":"futures.html#exporting-async-trait-methods","title":"Exporting async trait methods","text":"<p>UniFFI is compatible with the async-trait crate and this can be used to export trait interfaces over the FFI.</p> <p>When using UDL, wrap your trait with the <code>#[async_trait]</code> attribute.  In the UDL, annotate all async methods with <code>[Async]</code>:</p> <pre><code>[Trait]\ninterface SayAfterTrait {\n    [Async]\n    string say_after(u16 ms, string who);\n};\n</code></pre> <p>When using proc-macros, make sure to put <code>#[uniffi::export]</code> outside the <code>#[async_trait]</code> attribute:</p> <pre><code>#[uniffi::export]\n#[async_trait::async_trait]\npub trait SayAfterTrait: Send + Sync {\n    async fn say_after(&amp;self, ms: u16, who: String) -&gt; String;\n}\n</code></pre>"},{"location":"futures.html#combining-rust-and-foreign-async-code","title":"Combining Rust and foreign async code","text":"<p>Traits with callback interface support that export async methods can be combined with async Rust code. See the async-api-client example for an example of this.</p>"},{"location":"futures.html#python-uniffi_set_event_loop","title":"Python: <code>uniffi_set_event_loop()</code>","text":"<p>Python bindings export a function named <code>uniffi_set_event_loop()</code> which handles a corner case when integrating async Rust and Python code. <code>uniffi_set_event_loop()</code> is needed when Python async functions run outside of the eventloop, for example:</p> <ul> <li>Rust code is executing outside of the eventloop.  Some examples:<ul> <li>Rust code spawned its own thread</li> <li>Python scheduled the Rust code using <code>EventLoop.run_in_executor</code></li> </ul> </li> <li>The Rust code calls a Python async callback method, using something like <code>pollster</code> to block   on the async call.</li> </ul> <p>In this case, we need an event loop to run the Python async function, but there's no eventloop set for the thread. Use <code>uniffi_set_event_loop()</code> to handle this case. It should be called before the Rust code makes the async call and passed an eventloop to use.</p> <p>Note that <code>uniffi_set_event_loop</code> cannot be glob-imported because it's not part of the library's <code>__all__</code>.</p>"},{"location":"futures.html#cancelling-async-code","title":"Cancelling async code.","text":"<p>We don't directly support cancellation in UniFFI even when the underlying platforms do. You should build your cancellation in a separate, library specific channel; for example, exposing a <code>cancel()</code> method that sets a flag that the library checks periodically.</p> <p>Cancellation can then be exposed in the API and be mapped to one of the error variants, or None/empty-vec/whatever makes sense. There's no builtin way to cancel a future, nor to cause/raise a platform native async cancellation error (eg, a swift <code>CancellationError</code>).</p> <p>See also this github PR.</p>"},{"location":"glossary.html","title":"UniFFI Glossary","text":"<p>This page contains terms used throughout these docs</p>"},{"location":"glossary.html#scaffolding","title":"Scaffolding","text":"<p>UniFFI-generated Rust code. This is an <code>extern \"C\"</code> API that helps the foreign bindings make Rust calls.</p> <p>Scaffolding is generated by Rust macros and not found in source code.  If you use proc-macro, you can see it by using <code>cargo expand</code> or expanding the UniFFI macros in an IDE.  If you use UDL files, you can see it by running <code>cargo build</code>, then finding the generated file in the <code>target</code> directory.</p>"},{"location":"glossary.html#bindings","title":"Bindings","text":"<p>UniFFI-generated code in a foreign language. This implements the exported Rust API by calling in to the Rust scaffolding.</p>"},{"location":"glossary.html#lower","title":"Lower","text":"<p>The process of converting a high-level Rust type into a lower-level FFI type in the scaffolding code.  Alternatively, converting a high-level foreign language type to the same FFI type in the bindings code.  See lifting and lowering for details.</p> <p>\"lowered type\", refers to the FFI type that a high-level top lowers to.  For example, <code>RustBuffer</code> is the lowered type for <code>String</code>.</p>"},{"location":"glossary.html#lift","title":"Lift","text":"<p>The process of converting a low-level FFI type into a high-level Rust type into in the scaffolding code.  Alternatively, converting the same FFI type into a high-level foreign language type in the bindings code. See lifting and lowering for details.</p> <p>The process of converting a low-level FFI type into a high-level Rust/foreign language type as described in lifting and lowering.</p>"},{"location":"internals/async-ffi.html","title":"UniFFI Async FFI details","text":"<p>This document describes the low-level FFI details of UniFFI async calls. Check out Async overview for high-level description of what's going on here.</p>"},{"location":"internals/async-ffi.html#rust-async-functions","title":"Rust async functions","text":"<p>Rust async functions are implemented by a scaffolding function that return a <code>RustFuture</code> handle. For example, a <code>fn add(a: u32, b: u32) -&gt; u32</code> function would be implemented by something like this:</p> <pre><code>pub extern \"C\" fn ffi_add(a: u32, b: u32) -&gt; uniffi::Handle {\n    // Creates a future for the `add` function and returns handle that represents that handle.\n}\n</code></pre> <p>The bindings then sets up an asynchronous loop that polls the RustFuture until it's complete.</p> <p>Here's some Python code that shows how this works:</p> <pre><code>async def add(a, b):\n    # Get a future handle by calling the scaffolding function\n    rust_future_handle = RustScaffoldingLibrary.ffi_add(a, b)\n    try:\n        # asynchronously loop until the future is ready\n        while True:\n            # create a future to handle a single iteration of the polling loop.\n            inner_future = eventloop.create_future()\n            # Create a handle to send to Rust that represents `inner_future`\n            inner_future_handle = create_future_handle(inner_future)\n            # Call the rust_future_poll scaffolding function (see below for how that's handled).\n            RustScaffoldingLibrary.ffi_rust_future_poll_u32(\n                rust_future_handle,\n                uniffi_continuation_callback,\n                inner_future_handle,\n            )\n            # await the inner future.  When this completes, there's are 2 possibilities:\n            #  * The RustFuture is ready and we can complete it\n            #  * The RustFuture should be polled again and we should perform another iteration\n            poll_code = await inner_future\n            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:\n                break\n\n        # Call the complete function to get:\n        #   * The future's return value\n        #   * The call status -- returned by an out pointer and used to return errors.\n        call_status = UniffiRustCallStatus.default()\n        return_value = RustScaffoldingLibrary.rust_future_complete_u32(rust_future_handle, ctypes.byref(call_status))\n\n        # We can then lift the result the same way we would a sync call\n        return lift_result(return_value, call_status)\n    finally:\n        # In the finally block, we call `rust_future_free` to ensure we cleanup the future handle\n        # regardless of any errors\n        RustScaffoldingLibrary.rust_future_free_u32(rust_future_handle)\n\n# Continuation callback, this is called from Rust when progress can be made on the future, either\n# because it's ready or it needs to be polled again.\ndef uniffi_continuation_callback(future_handle, poll_code):\n    # Convert the handle we sent to Rust to a Python Future\n    future = get_future_from_handle(future_handle)\n    # Complete the future with the code that indicates if the future is ready or not.\n    eventloop.call_soon_threadsafe(future.set_result, poll_code)\n\n# Create a `u64` handle that represents a Python Future object.\ndef create_future_handle(future):\n    # The code to do this will vary by language.\n\n# Re-create the Python Future object from a `u64` handle.\ndef get_future_from_handle(handle):\n    # The code to do this will vary by language.\n</code></pre>"},{"location":"internals/async-ffi.html#cancellation","title":"Cancellation","text":"<p>Some languages have builtin cancellation semantics.  For those, you can call the <code>rust_future_cancel</code> to request that the future be cancelled.  On the Rust side, this causes the future to be dropped.</p> <pre><code>def cancel_future(future_handle):\n    if rust_future_has_not_been_freed(future_handle):\n        RustScaffoldingLibrary.rust_future_cancel_u32(rust_future_handle)\n</code></pre>"},{"location":"internals/async-ffi.html#managing-the-rustfuture-handle","title":"Managing the RustFuture handle","text":"<ul> <li>The foreign code is responsible for calling the <code>rust_future_free</code> function when it's done with the handle.   The code must always call <code>rust_future_free</code>, regardless of if the future is completed or cancelled.   Once that function is called, the handle must not be used again.</li> <li><code>rust_future_complete</code> must only be called once.  Once it's called, <code>rust_future_poll</code> should not   be called again.</li> <li>If your bindings call <code>rust_future_cancel</code> make sure there are no races that allow it to be called   after <code>rust_future_free</code>.</li> </ul>"},{"location":"internals/async-ffi.html#ffi-definitions","title":"FFI definitions","text":""},{"location":"internals/async-ffi.html#scaffolding-functions","title":"Scaffolding functions","text":"<pre><code>extern \"C\" fn [scaffolding_function_name](\n    // The lowered type for each argument of the Rust function\n    foo: u32,\n    bar: RustBuffer,\n    // No `RustCallStatus` argument.  Errors are handled by calling the `rust_future_complete`\n    // function.\n) -&gt; u64 { } // Returns a RustFuture handle\n</code></pre>"},{"location":"internals/async-ffi.html#rust_future_poll","title":"rust_future_poll","text":"<p>A <code>rust_future_poll</code> method is defined for each lowered return type.  For example: <pre><code>/// `rust_future_poll` for return types that lower to `RustBuffer`.  This handles exported functions\n/// that return `String`, `Vec`, records, etc.\nextern \"C\" fn rust_future_poll_rustbuffer(\n    rust_future_handle: u64,\n    /// Callback to call when progress can be made to the future\n    continuation_callback: RustFutureContinuationCallback,\n    /// Data to pass to the continuation callback\n    continuation_callback_data: u64,\n) { }\n\ntype RustFutureContinuationCallback = fn(callback_data: u64, poll_code: u8)\n\n// The future is ready, call `rust_future_complete`\nconst POLL_CODE_RUST_FUTURE_READY = 0;\n// Wake the future by calling `rust_future_poll` again.\nconst POLL_CODE_RUST_FUTURE_WAKE = 1;\n</code></pre></p>"},{"location":"internals/async-ffi.html#other-rustfuture-ffi-functions","title":"Other RustFuture FFI functions","text":"<pre><code>/// `rust_future_complete` for return types that lower to `u8`\nextern \"C\" fn rust_future_complete_u8(\n    rust_future_handle: u64,\n    /// RustCallStatus out pointer.  This indicates if the call was successful.\n    *mut RustCallStatus out_status,\n) -&gt; u8 { } // lowered return value, in this case a `u8`.\n\n/// `rust_future_cancel` for return types that lower to `f32`.\n///\n/// Languages that support cancellation can call this to cancel the future.  It will cause the\n/// `Future` object to be dropped in Rust.\nextern \"C\" fn rust_future_cancel_f32(\n    rust_future_handle: u64,\n) { }\n\n/// `rust_future_free` for void return types.\n///\n/// This must be called for each RustFuture you receive and it must be the last call you pass the\n/// RustFuture handle to.\nextern \"C\" fn rust_future_free_void(\n    rust_future_handle: u64,\n) { }\n</code></pre>"},{"location":"internals/async-ffi.html#foreign-async-callback-interface-methods","title":"Foreign async callback interface methods","text":"<p>Async callback interface methods are defined as fields in the callback interface vtable like sync methods.  However, they have no return value and 3 extra arguments:</p> <ul> <li><code>complete_func</code>: Function to call when the async method completes.</li> <li><code>complete_func_data</code>: <code>u64</code> value to pass to the complete function</li> <li><code>foreign_future_dropped_callback</code>: Out pointer to the future dropped callback.   If the foreign bindings set this, it will be called when the Rust future is dropped.   This is used to handle cancellation for languages that support it.</li> </ul> <p>For example: </p> <pre><code>#[repr(C)]\nstruct CallbackInterfaceVTable {\n    add: extern \"C\" fn(\n        // The lowered type for each argument of the method\n        a: u32,\n        b: u32,\n        /// Function pointer for the completion func\n        complete_func: ForeignFutureCompleteU32,\n        /// Data to pass to the completion func\n        complete_func_data: u64,\n        /// Out pointer that can be used to set the future dropped callback\n        out_dropped_callback: *mut ForeignFutureDroppedCallbackStruct,\n    ), // Note: no return value, `complete_func` is used for that.\n    // .. other methods here\n}\n\n/// Complete func signature, details in the next section\ntype ForeignFutureCompleteU32 = extern \"C\" fn(u64, ForeignFutureResultU32);\n</code></pre>"},{"location":"internals/async-ffi.html#completing-async-methods-with-complete_func","title":"Completing async methods with <code>complete_func</code>","text":"<p>The <code>complete_func</code> should be called when the async callback method has completed and ready to return data.  Pass it 2 arguments:</p> <ul> <li>The <code>complete_func_data</code> passed to the callback method.</li> <li>A foreign future result struct, which contains the return value and the RustCallStatus for the   call.</li> </ul> <p>The foreign future result struct varies based on the return value:</p> <pre><code>#[repr(C)]\n/// Result struct for `u8` \nstruct ForeignFutureResultU8 {\n    /// Lowered return value.  For error calls, set this to a placeholder value like `0`\n    return_value: u8,\n    /// RustCallStatus.  This indicates if the call was successful or not\n    call_status: RustCallStatus,\n}\n\n/// Result struct for `RustBuffer` \nstruct ForeignFutureResultRustBuffer {\n    /// Lowered return value.  For error calls, set this to empty `RustBuffer`.\n    return_value: RustBuffer,\n    /// RustCallStatus.  This indicates if the call was successful or not\n    call_status: RustCallStatus,\n}\n\n/// Result struct for void returns\nstruct ForeignFutureResultVoid {\n    // No return value field.\n\n    /// RustCallStatus.  This indicates if the call was successful or not\n    call_status: RustCallStatus,\n}\n\n/// ...etc.\n</code></pre>"},{"location":"internals/async-ffi.html#cancellation-with-foreign_future_dropped_callback","title":"Cancellation with <code>foreign_future_dropped_callback</code>","text":"<p>The <code>foreign_future_dropped_callback</code> is a pointer to a <code>ForeignFutureDroppedCallbackStruct</code>. This can be used to get a callback when the underlying Future is dropped in <code>Rust</code>. The main reason to do this is to cancel the Foreign async task.  If you want to support cancellation, set the <code>ForeignFutureDroppedCallbackStruct</code> data and connect it to some mechanism for cancelling the future.</p> <pre><code>type ForeignFutureDroppedCallback = extern \"C\" fn(u64);\n\n#[repr(C)]\nstruct ForeignFutureDroppedCallbackStruct {\n    /// Data to pass to the callback\n    callback_data: u64,\n    /// Callback function pointer\n    callback: ForeignFutureDroppedCallback,\n}\n</code></pre> <p>Languages that don't want to support cancellation are free to ignore this field by not setting a value.</p>"},{"location":"internals/async-ffi.html#managing-the-foreignfuture-handle","title":"Managing the ForeignFuture handle","text":"<p>If an async callback method is called, you must ensure that the <code>complete_func</code> is called which will complete the future and allow the async task to progress.  The <code>complete_func</code> must be called exactly once.</p> <p>If you don't want to support cancellation, then managing this handle is fairly easy:</p> <ul> <li>Start an async task to execute the method</li> <li>Chain a function to that task that calls <code>complete_func</code> with the handle when it's complete</li> <li>Ensure that <code>complete_func</code> is also called if the function errors out.   In this case you can pass a <code>ForeignFutureResult*</code> value with   <code>RustCallStatus.code = CallStatus::InternalError</code>.</li> </ul> <p>If you want to support cancellation, then there are some additional steps:</p> <ul> <li>Create a <code>u64</code> handle for the async task that was started.</li> <li>Set the <code>foreign_future_dropped_callback</code> with a callback and handle.</li> <li>In the callback:</li> <li>Cancel the task if it's still running</li> <li>Release the handle in whatever way the foreign language requires</li> <li>Note: this callback can be called after the task completes. You may need to avoid calling      methods that are invalid for completed tasks.</li> </ul>"},{"location":"internals/async-overview.html","title":"UniFFI Async Overview","text":"<p>This document describes how UniFFI implements async from a high-level. Once you've read this, you can also check out the low-level Async FFI details.</p>"},{"location":"internals/async-overview.html#what-runtime-does-async-code-run-on","title":"What runtime does async code run on?","text":"<p>The fundamental issue here is that UniFFI can't rely on a Rust async runtime. We don't want to force library authors into a particular runtime. Furthermore, we want to allow library authors to not use a runtime at all and instead to integrate with the runtime of the application using the library.</p> <p>To accomplish this, UniFFI piggybacks off the runtime from the foreign bindings. The generated Rust code schedules work using callbacks provided by the foreign bindings.</p>"},{"location":"internals/async-overview.html#rust-async-functions","title":"Rust Async functions","text":"<p>Rust async functions are implemented by wrapping the Future into a <code>uniffi::RustFuture</code> struct and providing scaffolding functions so that the foreign bindings can drive the future to completion.</p> <pre><code>sequenceDiagram\n  participant User as User code\n  participant Foreign as Foreign Language Bindings\n  participant Rust as Rust Scaffolding\n\n  User-&gt;&gt;+Foreign: call async function\n  Foreign-&gt;&gt;+Rust: call scaffolding function\n  Rust--&gt;&gt;-Foreign: return RustFuture handle\n\n  loop until RustFuture is ready\n    Foreign-&gt;&gt;Rust: call RustFuture poll fn\n    Rust-&gt;&gt;Foreign: call future callback\n  end\n\n  Foreign-&gt;&gt;+Rust: call RustFuture complete fn\n  Rust--&gt;&gt;-Foreign: return result\n  Foreign-&gt;&gt;Rust: call RustFuture free fn\n  Foreign--&gt;&gt;-User: return from async function</code></pre> <p>For each async function, UniFFI generates 4 scaffolding functions: * A scaffolding function that returns a <code>RustFuture</code> handle * <code>rust_future_poll</code> to poll the future * <code>rust_future_complete</code> to receive the completed result of a future * <code>rust_future_free</code> to destroy a future freeing any underlying memory * Technically, the function names are more like <code>uniffi_[module_prefix]_rust_future_poll</code>, but this document uses above names make for shorthand.</p> <p>The UniFFI generated code for an async function performs these steps:</p> <ol> <li>Call the Rust scaffolding function, receiving a <code>RustFuture</code> handle</li> <li>Call the <code>rust_future_poll</code> function for the future until the future is ready.</li> <li>The <code>rust_future_poll</code> function inputs a callback function and a <code>u64</code> callback data value to pass to the callback.</li> <li>If the future is pending, then the generated code registers a waker that will call the callback function with <code>RUST_FUTURE_WAKE</code>.</li> <li>If the future is ready, then the callback function is immediately called with <code>RUST_FUTURE_READY</code> and we move to the next step.</li> <li>Call <code>rust_future_complete</code>, receiving the return value of the future</li> <li>Call <code>rust_future_free</code> (ideally in a <code>finally</code> block)</li> <li>Return the result from <code>rust_future_complete</code></li> </ol>"},{"location":"internals/async-overview.html#why-not-have-rust_future_poll-return-a-boolean","title":"Why not have <code>rust_future_poll</code> return a boolean?","text":"<p>As described above, <code>rust_future_poll</code> inputs a callback and an opaque pointer. If the future is ready, then <code>rust_future_poll</code> immediately invokes the callback, passing it the pointer back and <code>RUST_FUTURE_READY</code> A more straightforward API would be to return a boolean if the future is ready, why not do that?</p> <p>The issue is that it doesn't work well with the way foreign code's lifetime management. The opaque pointer is usually either something like a raw <code>Arc</code> pointer that holds data about the async call. When the foreign code passes the pointer to <code>rust_future_poll</code>, it temporarily leaks a reference. Then when callback is called, it reconstructs the leaked reference, restoring the refcount.</p> <p>If <code>rust_future_poll</code> returned <code>true</code> to indicate that the future is ready, then the foreign code is in an awkward situation. It wants to use the async call data that the pointer was referring to, but it just sent a leaked pointer to Rust. It would have to hold on to a copy of the raw pointer, use that to restore the reference, and assume the callback is never going to be called. This could work, but it makes things much more complicated and could easily lead to memory leaks or use-after-free bugs.</p>"},{"location":"internals/async-overview.html#foreign-async-callback-methods","title":"Foreign async callback methods","text":"<p>Async callback/trait interface methods are the way that Rust makes async calls across the FFI. These are implemented using a callback, which makes them quite a bit simpler than their counterparts.</p> <pre><code>sequenceDiagram\n  participant User as User code\n  participant Rust as Rust Scaffolding\n  participant Foreign as Foreign Language Bindings\n\n  User-&gt;&gt;+Rust: call async function\n  Rust-&gt;&gt;Foreign: call scaffolding function, pass a oneshot::Sender pointer\n  Rust--&gt;&gt;-User: return oneshot::Receiver\n\n  Foreign-&gt;&gt;Rust: invoke callback, pass back oneshot::Sender pointer\n  Note over Rust: send callback result to the oneshot::Sender</code></pre> <p>The UniFFI generated code for an async trait method performs these steps:</p> <ul> <li>Create a <code>oneshot::Channel</code> (see oneshot crate for how these work, although we don't currently depend on that crate).</li> <li>Leak the <code>oneshot::Sender</code> into a raw pointer</li> <li>Defines an <code>extern \"C\"</code> function that will:<ul> <li>input that raw pointer plus a return value </li> <li>lift the return value</li> <li>send the return value into the <code>oneshot::Sender</code>.</li> </ul> </li> <li>Call the callback method, passing a pointer to the function from the last step and the <code>oneshot::Sender</code> raw pointer.</li> <li>Return the receiver half of the <code>oneshot::Channel</code>.</li> </ul> <p>On the foreign side, the generated code simply runs the async function as normal, and call the callback once it completes.</p>"},{"location":"internals/async-overview.html#can-you-really-just-piggyback-on-the-foreign-async-runtime","title":"Can you really just piggyback on the foreign async runtime?","text":"<p>It's somewhat surprising, but yes. All the async code can run in the foreign runtime and Rust never has to start its own eventloop thread. In order to implement this, the Rust async functions must only await functions that fall into one of these categories:</p> <ul> <li>UniFFI async callback/trait methods   This often means defining traits for things like HTTP clients so that Rust can leverage async HTTP libraries from the foreign side.</li> <li>Async functions from crates like oneshot and async_mutex that work with any runtime.</li> </ul> <p>Beware that some Rust crates will present async APIs that silently start up runtimes in the background. For example, reqwest will start a tokio runtime.</p> <p>The Async API client example shows how this could work in the real-world. The Rust library depends an async HTTP callback interface to do the low-level fetching, then deserializes/validates the HTTP response. After that, it returns a high-level API response struct to the application. Furthermore, let's stipulate that the deserialization/validation is slow enough to be considered blocking. To manage this, the Rust library also depends on a (synchronous) callback interface that runs a task in a worker queue where blocking is allowed. Here's how the async API call could be handled:</p> <pre><code>sequenceDiagram\n  participant AsyncRust as Async Rust code\n  participant SyncRust as Sync Rust code\n  participant WorkerQueue as Work Queue Callback Interface\n  participant Http as Http Callback Interface\n  participant Foreign as Foreign language code\n\n  Foreign-&gt;&gt;+AsyncRust: Start async API call\n  AsyncRust-&gt;&gt;+Http: await method of Http callback interface\n  Http--&gt;&gt;-AsyncRust: Return HTTP response\n  Note over AsyncRust: Create oneshot channel&lt;br/&gt;and deseralization task\n  AsyncRust--&gt;&gt;WorkerQueue: Schedule task&lt;br /&gt;(sends the HTTP response for further processing)\n  Note over AsyncRust: await oneshot channel\n  WorkerQueue-&gt;&gt;SyncRust: Run task (in background thread)\n  SyncRust--&gt;&gt;AsyncRust: Send deserialized response via oneshot channel\n  AsyncRust--&gt;&gt;-Foreign: Return API result</code></pre> <ul> <li>Action in this sequence diagram represents calling an async Rust function or async callback interface method, see the above diagrams for details.</li> <li>The dotted lines show how the data is passed around during the async call.</li> <li>The async Rust code runs in a Future::poll method, inside the foreign event loop.  This code never blocks.</li> <li>The sync Rust code runs inside a worker queue where it's okay to block.</li> <li>This all combines together to create an async Rust call that's driven by the foreign event loop.</li> </ul>"},{"location":"internals/async-overview.html#can-you-integrate-with-rust-runtimes-like-tokio","title":"Can you integrate with Rust Runtimes like <code>tokio</code>?","text":"<p>Yes.  This will vary for each runtime, but the typical procedure is:</p> <ul> <li>Keep a reference to the runtime</li> <li>Use a bridge function like tokio::Runtime::spawn to await a future that runs in that runtime.</li> </ul> <p>There's also the <code>uniffi::async_runtime</code> macro attribute to help with this, but it's not clear if we want to continue to support it (#1726).</p>"},{"location":"internals/bindings_ir.html","title":"The UniFFI Bindings IR","text":"<p>Note: the Bindings IR is currently an experiment. It's checked in so that we can use it for the gecko-js external binding generator. Our current recommendation for other external bindings authors is to avoid using it for now since we haven't fully committed to this new system and expect it to change.</p> <p>UniFFI models foreign bindings generation as a compiler pipeline:</p> <pre><code>flowchart LR\n    ProcMacros[Rust + proc-macros] --&gt; Metadata[Metadata]\n    UDL[UDL] --&gt; Metadata[Metadata]\n    Metadata --&gt; InitialIr[Initial IR]\n    InitialIr --&gt; GeneralIr[General IR]\n    GeneralIr --&gt; KotlinIr[Kotlin IR]\n    GeneralIr --&gt; SwiftIr[Swift IR]\n    GeneralIr --&gt; PythonIr[Python IR]\n    GeneralIr --&gt; RubyIr[Ruby IR]\n\n    subgraph Not yet implemented\n    KotlinIr --&gt; Kotlin[Generated Kotlin]\n    SwiftIr --&gt; Swift[Generated Swift]\n    PythonIr --&gt; Python[Generated Python]\n    RubyIr --&gt; Ruby[Generated Ruby]\n    end</code></pre> <ol> <li>Metadata is generated from the proc-macro code and UDL files.    The metadata is a simple reflection of the Rust definitions.</li> <li>The initial IR is built from the metadata with very few transformations.</li> <li>The initial IR is transformed into the general IR.    This adds information like FFI function names, that's needed for bindings generation.</li> <li>The general IR is transformed into a language-specific IR.    This adds information like concrete type names.</li> <li>The final step uses the language-specific IR and to generate the bindings code.</li> </ol> <p>This document describes the system from a high-level. See Bindings IR Pipeline for details on how the IR pipeline is implemented.</p>"},{"location":"internals/bindings_ir.html#generation","title":"Generation","text":"<p>When a UniFFI proc-macro wraps a Rust item, it records metadata about the item it's wrapping. For example, when <code>#[uniffi::export]</code> wraps a function, it records the function name, arguments, return type, etc. This metadata is then serialized into a buffer and stored as an exported symbol in the Rust library. The generated code will look something like this:</p> <pre><code>// An example exported Rust function\n#[uniffi::export]\nfn add(a: u64, b: u64) -&gt; Result&lt;u64&gt; {\n    a.checked_add(b)\n        .ok_or(ArithmeticError::IntegerOverflow { a, b })\n}\n\n// Metadata buffer for `arithmetic::add()`, generated by the `uniffi::export` macro.\nconst UNIFFI_META_CONST_ARITHMETIC_FUNC_ADD: ::uniffi::MetadataBuffer = ::uniffi::MetadataBuffer::from_code(\n        ::uniffi::metadata::codes::FUNC, // Code for the item type\n    )\n    .concat_str(\"arithmetic\") // module name\n    .concat_str(\"add\") // function name\n    .concat_bool(false) // async?\n    .concat_value(2u8) // number of arguments\n    .concat_str(\"a\") // 1st argument name\n    .concat(&lt;u64 as ::uniffi::TypeId&lt;crate::UniFfiTag&gt;&gt;::TYPE_ID_META) // 1st argument type\n    .concat_bool(false) // default value?\n    .concat_str(\"b\") // 2nd argument name\n    .concat(&lt;u64 as ::uniffi::TypeId&lt;crate::UniFfiTag&gt;&gt;::TYPE_ID_META) // 2nd argument type\n    .concat_bool(false) // default value?\n    .concat(&lt;Result&lt;u64&gt; as ::uniffi::TypeId&lt;crate::UniFfiTag&gt;&gt;::TYPE_ID_META) // result type\n    .concat_long_str(\"\"); // docstring\n\n// Serialize the metadata into a byte array and export the symbol.\n// This can be evaluated at compile time because `UNIFFI_META_ARITHMETIC_FUNC_ADD` is `const`.\n#[no_mangle]\n#[doc(hidden)]\npub static UNIFFI_META_ARITHMETIC_FUNC_ADD: [u8; UNIFFI_META_CONST_ARITHMETIC_FUNC_ADD\n    .size] = UNIFFI_META_CONST_ARITHMETIC_FUNC_ADD.into_array();\n</code></pre> <p>Notes:</p> <ul> <li>UniFFI gets the type metadata types using the <code>TypeId::TYPE_ID_META</code>.   By using a trait and associated type rather than relying on the type identifier, we get the correct metadata even through type aliases.   For example, <code>Result&lt;u64&gt;</code> is a type alias with the error type omitted, but <code>&lt;Result&lt;u64&gt; as ::uniffi::TypeId&lt;crate::UniFfiTag&gt;&gt;::TYPE_ID_META&gt;</code> includes metadata about the error type.</li> <li>See Lifting and Lowering for details on <code>UniFfiTag</code>.</li> <li>If a UDL file is present, UniFFI also generates metadata from that and merges it with the proc-macro metadata.</li> </ul> <p>When a UniFFI bindgen command runs, it reads/deserializes the exported metadata symbols from the Rust library. Then the metadata is passed on to the next stage of the pipeline See <code>uniffi_bingen::macro_metadata</code> and <code>uniffi_meta::reader</code> for details.</p> <p>Here's how the metadata might look for the above function: <pre><code>FnMetadata {\n    module_path: \"arithmetic\",\n    name: \"add\",\n    is_async: false,\n    inputs: [\n        FnParamMetadata {\n            name: \"a\",\n            ty: UInt64,\n            by_ref: false,\n            optional: false,\n            default: None,\n        },\n        FnParamMetadata {\n            name: \"b\",\n            ty: UInt64,\n            by_ref: false,\n            optional: false,\n            default: None,\n        },\n    ],\n    return_type: Some(\n        UInt64,\n    ),\n    throws: Some(\n        Enum {\n            module_path: \"arithmetic\",\n            name: \"ArithmeticError\",\n        },\n    ),\n    checksum: Some(\n        39863,\n    ),\n    docstring: None,\n},\n</code></pre></p>"},{"location":"internals/bindings_ir.html#metadata-initial-ir","title":"Metadata -&gt; Initial IR","text":"<p>This phase transforms inputs the metadata and creates an IR from it. The Initial IR contains the metadata items with a couple changes. The main change is the flat list is converted into a tree structure.</p> <pre><code>/// Root node of the Initial IR\n///\n/// Note: The `Node` derive also implements `Default` and `Default` should not be listed in the\n/// #[derive] list.\n#[derive(Debug, Clone, Node)]\npub struct Root {\n    pub modules: IndexMap&lt;String, Module&gt;,\n    /// The library path the user passed to us, if we're in library mode\n    pub cdylib: Option&lt;String&gt;,\n}\n\n#[derive(Debug, Clone, Node)]\npub struct Module {\n    pub name: String,\n    pub crate_name: String,\n    pub docstring: Option&lt;String&gt;,\n    pub functions: Vec&lt;Function&gt;,\n    pub type_definitions: Vec&lt;TypeDefinition&gt;,\n}\n\n#[derive(Debug, Clone, Node)]\n// This is just FnMetadata with a new struct name\n#[node(from(FnMetadata))]\npub struct Function {\n    pub name: String,\n    pub is_async: bool,\n    pub inputs: Vec&lt;Argument&gt;,\n    pub return_type: Option&lt;Type&gt;,\n    pub throws: Option&lt;Type&gt;,\n    pub checksum: Option&lt;u16&gt;,\n    pub docstring: Option&lt;String&gt;,\n}\n\n#[derive(Debug, Clone, Node)]\npub enum TypeDefinition {\n    /// RecordMetadata with a new struct name\n    /// This has `FieldMetadata` as child nodes\n    Record(Record),\n    /// RecordMetadata with a new struct name\n    /// This has `VariantMetadata` as child nodes and `FieldMetadata` as grand children.\n    Enum(Enum),\n    /// ObjectMetadata with a new struct name\n    /// This has child nodes for ConstructorMetadata, MethodMetadata, and several other metadata\n    /// items.\n    Interface(Interface),\n    /// ...etc\n    CallbackInterface(CallbackInterface),\n    Custom(CustomType),\n}\n</code></pre>"},{"location":"internals/bindings_ir.html#initial-ir-general-ir","title":"Initial IR -&gt; General IR","text":"<p>This phase adds derived information about the FFI. Some examples are:</p> <ul> <li>The FFI scaffolding function for each Rust function</li> <li>The FFI scaffolding functions to clone/free object references</li> <li>The FFI type that each type is lowered into/lifted from</li> <li>If a type is used as an error or not</li> </ul> <p>Here's how <code>Function</code> might look in the General IR.</p> <pre><code>Function {\n    name: \"add\",\n    ...\n    arguments: [\n        Argument {\n            name: \"a\",\n            ty: Type {\n                kind: UInt64,\n                ffi_type: FfiType::UInt64,\n                ...\n            },\n            ...\n        },\n        ...\n    ],\n    return_type: ReturnType {\n        ty: Some(\n            Type {\n                kind: UInt64,\n                ffi_type: FfiType::UInt64,\n                ...\n            },\n        ),\n        ...\n    },\n    throws_type: ThrowsType {\n        ty: Some(\n            Type {\n                kind: Enum {\n                    module_path: \"arithmeticpm\",\n                    name: \"ArithmeticError\",\n                },\n                ffi_type: FfiType::RustBuffer,\n                ...\n            },\n        ),\n        ...\n    },\n    ffi_func: FfiFunctionRef {\n        name: \"uniffi_arithmeticpm_fn_func_add\",\n        ...\n    },\n    ...\n}\n</code></pre>"},{"location":"internals/bindings_ir.html#general-ir-language-specific-ir","title":"General IR -&gt; Language-specific IR","text":"<p>This phase transforms the general IR into a language-specific one:</p> <ul> <li>Language-specific data is added, like concrete type names and the names of the <code>FfiConverter</code> classes that lift/lower types</li> <li>New top-level items may be added, for example a list of import statements.</li> <li>Fields like <code>name</code> and <code>docstring</code> will be transformed to the preferred style for the language.</li> </ul> <p>For example, when the function IR is specialized for Python:</p> <ul> <li>Concrete type names will be added</li> <li>The FFI converter class name is added</li> <li>Docstrings will be formatted as Python docstrings</li> <li>Names will usually stay the same, since Rust and Python happen to share the same naming style.   Other languages may translate names into camelCase.</li> </ul> <pre><code>Function {\n    name: \"add\",\n    ...\n    arguments: [\n        Argument {\n            name: \"a\",\n            ty: Type {\n                kind: UInt64,\n                \"type_name\": String(\n                    \"int\",\n                ),\n                \"ffi_converter_name\": String(\n                    \"_UniffiConverterUInt64\",\n                ),\n                \"ffi_type_name\": String(\n                    \"ctypes.c_uint64\",\n                ),\n                ...\n            },\n            ...\n        },\n        ...\n    ],\n    return_type: ReturnType {\n        ty: Some(\n            Type {\n                kind: UInt64,\n                \"type_name\": String(\n                    \"int\",\n                ),\n                \"ffi_converter_name\": String(\n                    \"_UniffiConverterUInt64\",\n                ),\n                \"ffi_type_name\": String(\n                    \"ctypes.c_uint64\",\n                ),\n                ...\n            },\n        ),\n        ...\n    },\n    throws_type: ThrowsType {\n        ty: Some(\n            Type {\n                kind: Enum {\n                    module_path: \"arithmeticpm\",\n                    name: \"ArithmeticError\",\n                },\n                \"type_name\": String(\n                    \"ArithmeticError\",\n                ),\n                \"ffi_converter_name\": String(\n                    \"_UniffiConverterTypeArithmeticError\",\n                ),\n                \"ffi_type_name\": String(\n                    \"_UniffiRustBuffer\",\n                ),\n                ...\n            },\n        ),\n        ...\n    },\n    ffi_func: FfiFunctionRef {\n        name: \"uniffi_arithmeticpm_fn_func_add\",\n        ...\n    },\n    ...\n},\n</code></pre>"},{"location":"internals/bindings_ir.html#language-specific-ir-generated-bindings-code","title":"Language-specific IR -&gt; Generated Bindings Code","text":"<p>The final phase takes the language-specific IR and uses it to generate the bindings code. We use the Askama template rendering engine for this.</p> <p>In this phase, the top-level <code>add</code> function is implemented by:</p> <ul> <li>checking/lowering all arguments using the class named by <code>Argument.ty.lang_data.ffi_converter_name</code></li> <li>calling the scaffolding function named by <code>ffi_func.name</code></li> <li>handling errors using the class named by <code>ReturnType.ty.lang_dataffi_converter_name</code></li> <li>lifting the return value using the class named by <code>ThrowsType.ty.lang_data.ffi_converter_name</code></li> </ul> <pre><code>def add(a: int, b: int) -&gt; int:\n    _UniffiConverterUInt64.check_lower(a)\n    _UniffiConverterUInt64.check_lower(b)\n    _uniffi_return = _uniffi_rust_call_with_error(\n        _UniffiConverterTypeArithmeticError,\n        _UniffiLib.uniffi_arithmeticpm_fn_func_add,\n        _UniffiConverterUInt64.lower(a),\n        _UniffiConverterUInt64.lower(b),\n    )\n    return _UniffiConverterUInt64.lift(_uniffi_return)\n</code></pre>"},{"location":"internals/bindings_ir.html#how-does-this-work-under-the-hood","title":"How does this work under the hood?","text":"<p>See Bindings IR Pipeline for details on how the IR pipeline is implemented.</p>"},{"location":"internals/bindings_ir_pipeline.html","title":"Bindings IR Pipeline","text":"<p>Note: the Bindings IR is currently an experiment. It's checked in so that we can use it for the gecko-js external binding generator. Our current recommendation for other external bindings authors is to avoid using it for now since we haven't fully committed to this new system and expect it to change.</p> <p>The Bindings IR pipeline is used to transform different intermediate representations of the generated bindings.</p> <ul> <li>The foundational code lives in the <code>uniffi_pipeline</code> crate.   This defines things like the <code>Node</code> trait.</li> <li>The macro code lives in the <code>uniffi_internal_macros</code> crate.   This defines things like the <code>Node</code> derive macro.</li> <li><code>uniffi_bindgen</code> defines the general pipeline.   This converts <code>uniffi_meta</code> metadata to the initial IR then converts that to the general IR.</li> <li>Finally, each language defines their own pipeline, which extends the general pipeline and outputs a language-specific IR.</li> </ul>"},{"location":"internals/bindings_ir_pipeline.html#nodes","title":"Nodes","text":"<p>Types inside an IR are called \"nodes\" and they must derive a <code>Node</code> trait impl. The top-level node is always named <code>Root</code>. When this document talks about converting between two IRs, this means converting between the root nodes of those IRs.</p> <p><code>Node</code> trait provides functionality to:</p> <ul> <li>Traverse the node tree.  <code>Node::visit()</code> and <code>Node::visit_mut()</code> allows you to visit all   descendants with a given type.</li> <li>Convert between any two nodes using <code>Node::try_from_node</code>.  This conversion is described in the   next section.</li> </ul>"},{"location":"internals/bindings_ir_pipeline.html#node-conversions","title":"Node conversions","text":"<p><code>Node::try_from_node</code> attempts to convert a node from one IR to the corresponding node from another IR. For example, <code>from_ir::Node</code> will be converted to <code>into_ir::Node</code> using the following rules:</p> <ul> <li>Any fields in <code>into_ir::Node</code>, but not <code>from_ir::Node</code> are added using <code>Default::default</code>, which the <code>Node</code> derive macro also derives.</li> <li>Any fields in <code>from_ir::Node</code>, but not <code>into_ir::Node</code> are ignored</li> <li>Any fields in both are recursively converted using <code>Node::try_from_node</code>.</li> <li><code>try_from_node</code> is automatically derived using the <code>Node</code> derive macro.   The conversion can be customized using macro attributes.</li> </ul> <p>Renamed node types, variants, and fields can be handled by adding the <code>#[node(from([name]))]</code> attribute:</p> <pre><code>#[derive(Node)]\npub struct Node {\n    /// `from_ir::Node::prev_name` fields become `into_ir::Node::new_name` fields.\n    #[node(from(prev_name))]\n    new_name: String,\n}\n</code></pre> <p>Also, nodes can be \"wrapped\" in the new IR using the <code>#[node(wraps([type]))]</code> attribute:</p> <pre><code>#[derive(Node)]\npub struct Node {\n    /// `into_ir::Node` wraps `from_ir::WrappedNode`.\n    /// All `from_ir::WrappedNode` values will be replaced with `Node { wrapped: wrapped_node }` values.\n    /// Any other fields will be initialized to their default values.\n    ///\n    /// This is mostly used as a way to add fields to enum types.\n    /// Wrap the enum with a struct, then add fields to that struct.\n    /// For example, `TypeNode` wraps the `Type` enum from `uniffi_meta`.\n    #[node(wraps)]\n    wrapped: WrappedNode,\n}\n</code></pre>"},{"location":"internals/bindings_ir_pipeline.html#field-conversion-order","title":"Field Conversion order","text":"<p>Fields are converted in declaration order. This matters when a field is listed twice with one of them using <code>#[node(from(&lt;name_of_the_other_field&gt;)]</code>. In this case the first field declared will be initialized with the data from the previous pass and the second field will be initialized to the default value.</p> <p>You can take advantage of this to convert an optional value into a non-optional value. For example:</p> <pre><code>#[derive(Node)]\npub struct SourceNode {\n    name: Option&lt;String&gt;\n}\n\n#[derive(Node)]\npub struct DestNode {\n    /// This field will be set to `SourceNode::name`\n    #[node(from(name))]\n    name_from_previous_pass: Option&lt;String&gt;\n    /// This field will be a non-optional version of `SourceNode::name`.\n    /// It will be initialized to an empty string, then a pipeline pass will populate it using\n    /// `name_from_previous_pass` combined with logic to handle the `None` case.\n    name: String,\n}\n</code></pre>"},{"location":"internals/bindings_ir_pipeline.html#module-structure","title":"Module structure","text":"<p>Each IRs will typically have a module dedicated to them with the following structure:</p> <ul> <li><code>mod.rs</code> -- Top-level module.  This is where the pipeline for the IR is defined.</li> <li><code>nodes.rs</code> -- Node definitions.</li> <li>other submodules -- Define pipeline pass functions.  These are named <code>pass()</code> by convention.</li> </ul>"},{"location":"internals/bindings_ir_pipeline.html#defining-irs","title":"Defining IRs","text":"<ul> <li>Start with an existing IR, let's assume it lives in the <code>from_ir</code> module.</li> <li>Define a new module for your IR, let's call it <code>into_ir</code></li> <li>Copy the <code>from_ir/nodes.rs</code> to <code>into_ir/nodes.rs</code></li> <li>Add new fields to the structs in <code>into_ir::nodes</code></li> <li>Define pipeline passes to populate the new fields, using the existing fields.  For example, <code>into_ir/mod.rs</code> might define a pipeline like this:</li> </ul> <pre><code>// The output type is a pipeline that converts from `initial::Root` to the `Root` node from this IR.\npub fn pipeline() -&gt; Pipeline&lt;initial::Root, Root&gt; {\n    // Start with `from_ir's` pipeline.  This converts `initial::root` to `from_ir::Root`.\n    from_ir::pipeline()\n        // Convert to `into_ir::Root`.\n        // This will use the logic from the Node conversions section above.\n        .convert_ir_pass::&lt;Root&gt;()\n        // Add passes to populate the new fields, mutate existing fields, etc.\n        .pass(foo::pass)\n        .pass(bar::pass)\n        .pass(baz::pass)\n}\n</code></pre> <ul> <li>Define the pipeline passes.   These input a node type in the IR and mutate all instances of that node.   <code>visit()</code> and <code>visit_mut()</code> are extremely helpful here.   For example, the general IR pass that adds FFI types to types looks like this:</li> </ul> <pre><code>// Visiting all `Module` nodes\npub fn pass(module: &amp;mut Module) -&gt; Result&lt;()&gt; {\n    // Save a copy of the module name, then visit all `TypeNode` nodes.\n    // Note: TypeNode wraps the `Type` enum from the initial IR\n    let module_name = module.name.clone();\n    // Visit all `TypeNode` instances that are descendants of `Module`.\n    module.visit_mut(|node: &amp;mut TypeNode| {\n        // Derive the FfiType from the type and module name\n        node.ffi_type = generate_ffi_type(&amp;node.ty, &amp;module_name);\n    });\n    Ok(())\n}\n</code></pre> <p>See <code>uniffi_bindgen::pipeline::general</code> for examples.</p>"},{"location":"internals/bindings_ir_pipeline.html#constructing-nodes-with-partial-field-data","title":"Constructing nodes with partial field data","text":"<p>Passes that construct new nodes often only want to specify partial field data and let a later pass populate the rest of the fields. Use the <code>Default::default()</code> to handle this case, which the <code>Node</code> derive also implements. Here's how this works in the <code>callables</code> pass:</p> <pre><code>pub fn pass(root: &amp;mut Root) -&gt; Result&lt;()&gt; {\n    root.visit_mut(|func: &amp;mut Function| {\n        func.callable = Callable {\n            // Most of the fields are simply copied from `Function`\n            name: func.name.clone(),\n            is_async: func.is_async,\n            kind: CallableKind::Function,\n            arguments: func.inputs.clone(),\n            return_type: ReturnType! {\n                ty: func.return_type.clone().map(|ty| TypeNode! { ty }),\n            },\n            throws_type: ThrowsType! {\n                ty: func.throws.clone().map(|ty| TypeNode! { ty }),\n            },\n            checksum: func.checksum,\n            // However, `async_data` and `ffi_func` are derived in a later pass.\n            // Use `default()` to create placeholder values for now\n            ..Callable::default()\n        }\n    });\n    // ... repeat for methods and constructors\n    Ok(())\n}\n</code></pre>"},{"location":"internals/bindings_ir_pipeline.html#peeking-behind-the-curtains-with-the-pipeline-cli","title":"Peeking behind the curtains with the <code>pipeline</code> CLI","text":"<p>Use the <code>pipeline</code> subcommand from any UniFFI CLI to inspect IR data at various stages of the pipeline.</p> <ul> <li>Build a UniFFI crate that you'd like to inspect, for example <code>cargo build -p uniffi-example-arithmetic</code></li> <li>Run the uniffi-bindgen CLI, with these arguments <code>pipeline --library path/to/library.so_a_or_dll [language]</code></li> <li>For example, in the UniFFI repo, <code>cargo run -p uniffi-bindgen-cli -- pipeline --library target/debug/libarithmetical.so python</code></li> </ul> <p>This will print out:</p> <ul> <li>The initial IR</li> <li>The diff after each pass</li> <li>The final IR</li> </ul> <p>This is a lot of data.  Use CLI flags to reduce it to a reasonable amount:</p> <ul> <li><code>-p</code>, <code>--pass</code> only show a single pass.</li> <li>Use <code>-p final</code> to only show the final pass in the process, which can be usefull when you're adding pass functions and want to see their effects.</li> <li><code>-t</code>, <code>--type</code> to only show one node type (e.g. <code>-t Record</code> or <code>-t Interface</code>).</li> <li><code>-n</code>, <code>--name</code> to only show with nodes with a specific name</li> </ul> <p>Alternatively, if you want to see the full IR for each pass, you can use <code>--no-diff</code> to print it out. Piping to a pager like <code>less</code> is highly recommended in this case.</p> <p>You can test this out yourself by running the following command to follow the <code>add</code> function as it moves throw the IR pipeline:</p> <p><code>cargo run -p uniffi-bindgen-cli -- pipeline --library target/debug/libarithmetical.so  python -t Function -n add</code></p>"},{"location":"internals/crates.html","title":"Navigating the code","text":"<p>The code for UniFFI is organized into the following crates:</p> <ul> <li> <p><code>./uniffi</code> (docs.rs, source): The main entry-point to UniFFI - almost all consumers should be able to use facilities expored by this module.</p> </li> <li> <p><code>./uniffi_bindgen</code> (docs.rs, source): The the source for the <code>uniffi-bindgen</code> executable and is where   most of the logic for the foreign bindings generation lives. Its contents include:</p> <ul> <li><code>./uniffi_bindgen/src/interface/</code>: Converting <code>uniffi_meta</code> types into an in-memory representation called <code>ComponentInterface</code>,   from which we can generate code for different languages.</li> <li><code>./uniffi_bindgen/src/scaffolding</code>: This module generates <code>.rs</code> files for the parts of the    <code>ComponentInterface</code> defined in UDL</li> <li><code>./uniffi_bindgen/src/bindings/</code>: This module turns a   <code>ComponentInterface</code> into foreign-language bindings,   the code that can load the FFI layer exposed by Rust and expose it as a   higher-level API in a target language. There is a sub-module for each internally supported language.</li> </ul> </li> <li> <p><code>./uniffi_meta</code>(docs.rs, source): The types used to represent the metadata used to describe the <code>ComponentInterface</code> used to generate the Rust scaffolding and the foreign bindings.</p> </li> <li> <p><code>./uniffi_udl</code>(docs.rs, source) : The parsing of UDL files, turning them into <code>uniffi_meta</code> types.</p> </li> <li> <p><code>./uniffi_build</code>(docs.rs, source): A small hook to run <code>uniffi-bindgen</code> from the <code>build.rs</code> script of a UniFFI component, in order to automatically generate the Rust scaffolding as part of its build process.</p> </li> <li> <p><code>./uniffi_macros</code>(docs.rs, source): Contains the proc_macro support, which does much of the heavy-lifting for defining the Rust FFI.</p> </li> <li> <p><code>./examples</code>: Contains code examples demonstrating the capabilites and code generation process.</p> </li> <li> <p><code>./fixtures</code>: Our test suite.</p> </li> </ul>"},{"location":"internals/design_principles.html","title":"Design Principles","text":"<p>These are some high-level points to consider when making changes to UniFFI (or when wondering why past changes were made in a particular way).</p>"},{"location":"internals/design_principles.html#prioritize-mozillas-short-term-needs","title":"Prioritize Mozilla's short-term needs","text":"<p>The initial consumers of this tool are teams working on features for Mozilla's mobile browsers. While we try to make the tool generally useful, we'll invest first in things that are the most valuable to those teams, which are reflected in the points below.</p>"},{"location":"internals/design_principles.html#safety-first","title":"Safety First","text":"<p>The generated bindings need to be safe by default. It should be impossible for foreign-language code to trigger undefined behaviour in Rust by calling the public API of the generated bindings, even if it is called in egregiously wrong or malicious ways. We will accept reduced performance in the interests of ensuring this safety.</p> <p>(The meaning of \"impossible\" and \"public API\" will of course depend on the target language. For example, code in Python might mutate internal attributes of an object that are marked as private with a leading underscore, and there's not much we can do to guard against that.)</p> <p>Where possible, we use Rust's typesystem to encode safety guarantees. If that's not possible then the generated Rust code may use <code>unsafe</code> and assume that the generated foreign-language code will uphold safety guarantees at runtime.</p> <p>Example: We insist that all object instances exposed to foreign-language code be <code>Sync</code> and <code>Send</code>, so that they're safe to access regardless of the threading model of the calling code. We do not allow thread-safety guarantees to be deferred to assumptions about how the code is called.</p> <p>Example: We do not allow returning any borrowed data from function calls, because we can't make any guarantees about when or how the foreign-language could access it.</p>"},{"location":"internals/design_principles.html#performance-is-a-feature-but-not-a-deal-breaker","title":"Performance is a feature, but not a deal-breaker","text":"<p>Our initial use-cases are not performance-critical, and our team are not low-level Rust experts, so we're highly motivated to favour simplicity and maintainability over performance. Given the choice we will pick \"simple but slow\" over \"fast but complicated\".</p> <p>However, we know that performance can degrade through thousands of tiny cuts, so we'll keep iterating towards the winning combination of \"simple and fast\" over time.</p> <p>Example: Initial versions of the tool used opaque integer handles and explicit mutexes to manage object references, favouring simplicity (in the \"we're confident this works as intended\" sense) over performance. As we got more experience and confidence with the approach and tool we replaced handles with raw <code>Arc</code> pointers, which both simplified the code and removed some runtime overheads.</p> <p>Violation: The tool currently passes structured data over the FFI by serializing it to a byte buffer, favouring ease of implementation and understanding over performance. This was fine as a starting point! However, we have not done any work to measure the performance impact or iterate towards something with lower overhead (such as using <code>repr(C)</code> structs).</p>"},{"location":"internals/design_principles.html#produce-bindings-that-feel-idiomatic-for-the-target-language","title":"Produce bindings that feel idiomatic for the target language","text":"<p>The generated bindings should feel idiomatic for their end users, and what feels idiomatic can differ between different target languages. Ideally consumers should not even realize that they're using bindings to Rust under the hood.</p> <p>We'll accept extra complexity inside of UniFFI if it means producing bindings that are nicer for consumers to use.</p> <p>Example: We case-convert names to match the accepted standards of the target language, so a method named <code>do_the_thing</code> in Rust might be called <code>doTheThing</code> in its Kotlin bindings.</p> <p>Example: Object references try to integrate with the GC of the target language, so that holding a reference to a Rust struct feels like holding an ordinary object instance.</p> <p>Violation: The Kotlin bindings have an explicit <code>destroy</code> method on object instances, because we haven't yet found a good way to integrate with the JVM's GC.</p>"},{"location":"internals/design_principles.html#empower-users-to-debug-and-maintain-the-tool","title":"Empower users to debug and maintain the tool","text":"<p>To succeed long-term, we can't depend on a dedicated team of \"UniFFI experts\" for debugging and maintenance. The people using the tool need to be empowered to debug, maintain and develop it.</p> <p>If you're using UniFFI-generated bindings and something doesn't work quite right, it should be possible for you to dig in to the generated foreign-language code, follow it through to the underlying Rust code, and work out what's going wrong without being an expert in Rust or UniFFI.</p> <p>Example: We try to include comments in the generated code to help guide users who may be reading through it to debug some issue.</p> <p>Violation: We don't have very good \"overview\" documentation on how each set of foreign-language bindings works, so someone trying to debug the Kotlin bindings would need to poke around in the generated code to try to build up a mental model of how it's supposed to work.</p> <p>Violation: A lack of structure in our code-generation templates means that it's hard for non-experts to find and change the codegen logic for a particular piece of functionality.</p>"},{"location":"internals/ffi_converter_traits.html","title":"Ffi converter traits","text":""},{"location":"internals/ffi_converter_traits.html#rust-ffi-conversion-traits","title":"Rust FFI conversion traits","text":"<p>UniFFI leverages a set of FFI converter traits to implement lifting and lowering on the Rust side. Each trait handles a single step in the lifting/lowering process (e.g. lifting an argument, lowering a return, etc.). We implement these traits for each type used in the exported API then leverage them in the codegen.</p> <p>For example, <code>uniffi::Lift</code> is used to lift values. To handle a function like <code>fn print(msg: String)</code>, the generated code will use:</p> <ul> <li><code>&lt;String as Lift&lt;crate::UniFfiTag&gt;&gt;::FfiType</code> when it needs to specify the FFI type (<code>RustBuffer</code> for strings).</li> <li><code>&lt;String as Lift&lt;crate::UniFfiTag&gt;&gt;::try_lift()</code> when it needs to lift an argument value.  In this example, this means taking an FFI value (<code>&lt;String as Lift&lt;crate::UniFfiTag&gt;&gt;::FfiType</code> AKA <code>RustBuffer</code>) and converting it into a Rust <code>String</code> for passing to the Rust function.</li> </ul> <p>Using a trait for this is important for proc-macros, which only see Rust tokens and don't know the surrounding context. For example, if macros always used <code>RustBuffer</code> as the FFI type whenever it sees <code>String</code>, then that would fail if users created a type alias like <code>type MyTypeAlias = String</code>. This may be unusual for <code>String</code>, but it's very common for <code>Result</code>. In general, any reasoning about the tokens is fragile and should be avoided.</p>"},{"location":"internals/ffi_converter_traits.html#uniffitag-and-the-orphan-rule","title":"<code>UniFfiTag</code> and the orphan rule","text":"<p>One odd part about the above code is that the <code>Lift</code> trait has a generic parameter which is always set to <code>crate::UniFfiTag</code>. In general, all of the FFI converter traits have this parameter (i.e. we generate <code>Lower&lt;crate::UniFfiTag&gt;</code>, <code>LowerReturn&lt;crate::UniFfiTag&gt;</code>, etc.). What's the point of all of this?</p> <p>The main reason is to work around issues with the Rust orphan rule and types from 3rd-party crates. For example, the custom types documentation shows how <code>url::Url</code> can be used in an exported API. For these types, we normally can't implement <code>Lift</code> in the code we generate in the crate since neither <code>uniffi::Lift</code> or <code>url::Url</code> is local to that crate. This same issue applies to all of the FFI converter traits.</p> <p>To work around this we:</p> <ul> <li>Add a generic parameter to each trait (<code>Lift</code> becomes <code>Lift&lt;UT&gt;</code> where \"UT\" is short for <code>UniFfiTag</code>).</li> <li>Define a unit struct in each crate named <code>UniFfiTag</code> (the term \"tag\" is borrowed from the C++ template pattern).</li> <li>We use that unit struct as the generic parameter for the trait (e.g. <code>Lift&lt;crate::UniFfiTag&gt;</code> is used to lift a value).</li> </ul> <p>Using the local type as a generic parameter means the impl no longer violates the orphan rule. For details on this see the Rust Chalk Book The TLDR is that generic parameters \"count\" towards the requirement that there be a local type in the impl.</p> <p>However, this makes it harder to use this impl from another crate. UniFFI handles that in 2 ways:</p> <ul> <li>The <code>uniffi</code> crate generates blanket trait impls for all UniFFI tag params (<code>impl&lt;UT&gt; Lift&lt;UT&gt; for String</code>).   This allows all crates to use them automatically with their <code>UniFfiTag</code> struct.</li> <li>UniFFI defines the <code>use_remote_type!</code> macro, which generates an implementation for the local   <code>UniFfiTag</code> by forwarding to the implementation from another crate's <code>UniFfiTag</code>.   See the Remote and external types for example usage.   This is also what the <code>remote</code> flag of the custom type macro does.</li> </ul>"},{"location":"internals/ffi_converter_traits.html#an-incomplete-list-of-ffi-traits","title":"An incomplete list of FFI traits","text":"<p>UniFFI defines a large number of FFI conversion traits, each one used for a specific purpose. This section describes a few them for explanatory purposes. See <code>uniffi_core/src/ffi_converter_traits.rs</code> for a full and up-to-date list.</p> <ul> <li><code>Lift</code>: Lift an value</li> <li><code>Lower</code>: Lower a value</li> <li><code>LowerReturn</code>: Lower a return value.</li> <li>For most types this is equivalent <code>Lower</code>, but a specialized impl is created for <code>Result&lt;T, E&gt;</code>.</li> <li><code>LiftRef</code>: Lift for a reference type.   This is often just <code>Lift</code> then a borrow, but a specialized impl is created for <code>Arc&lt;T&gt;</code>.</li> <li><code>FfiConverter</code>: General-purpose FFI conversion logic.   When <code>FfiConverter</code> is defined on a type, all other FFI traits are automatically derived.   This is what we implement for user-defined types like records and enums.</li> <li><code>FfiConverterArc</code>: FfiConverter implementation for <code>Arc&lt;T&gt;</code>.   This is another trait that we use to get around orphan rules.   Crates can't directly implement <code>FfiConverter</code> on <code>Arc&lt;T&gt;</code> for some interface, so they implement <code>FfiConverterArc</code> instead.   <code>uniffi</code> defines a blanket impl <code>FfiConverter</code> impl for these types (<code>impl&lt;T: FfiConverterArc&lt;UT&gt;, UT&gt; FfiConverter&lt;UT&gt; for Arc&lt;T&gt;</code>).</li> </ul>"},{"location":"internals/foreign_calls.html","title":"Rust -&gt; Foreign calls","text":"<p>How can Rust code make a call into the foreign language? The lifting and lowering docs describe this at a high-level, this document will explore the details.</p> <p>This document only describes non-async calls. See the Async FFI docs for a description of async calls.</p>"},{"location":"internals/foreign_calls.html#vtables","title":"VTables","text":"<p>Calling into foreign code has 2 major differences from calling Rust code:</p> <ul> <li>Foreign code is only called via an interface.</li> <li>The Rust code does not have knowledge of the FFI functions on the foreign language side.</li> </ul> <p>Because of this, the foreign calls all go through a vtable defined in the foreign language. This is a <code>repr(C)</code> struct where each entry is a function pointer corresponding to a method in a callback interface.</p> <p>For example:</p> <pre><code>/// For this trait interface...\n#[uniffi::export(with_foreign)]\npub trait TodoList {\n    fn append(&amp;self, title: String);\n    fn get_items(&amp;self) -&gt; Vec&lt;String&gt;;\n}\n\n/// A VTable like this will be generated:\n#[repr(C)]\npub struct UniffiTodoListVTable {\n    // One function pointer field for each method\n    // title is passed as a `RustBuffer` as described in [Lifting and lowering](./lifting_and_lowering.md)\n    append: extern \"C\" fn(uniffi_handle: u64, title: RustBuffer, uniffi_out_return: &amp;mut (), uniffi_call_status: &amp;mut RustCallStatus),\n    get_items: extern \"C\" fn(uniffi_handle: u64, uniffi_out_return: &amp;mut RustBuffer, uniffi_call_status: &amp;mut RustCallStatus);\n    // A function pointer for freeing the callback interface\n    uniffi_free: extern \"C\" fn(uniffi_handle: u64);\n}\n\n/// Called by the generated foreign bindings to register the VTable\n#[no_mangle]\npub extern \"C\" fn uniffi_init_todo_list_vtable(vtable: std::ptr::NonNull&lt;UniffiTodoListVTable&gt;) {...}\n</code></pre>"},{"location":"internals/foreign_calls.html#vtable-methods","title":"VTable methods","text":"<p>VTable methods work similar to a Rust method call], with some exceptions.</p> <p>Instead of returning the value as normal, it's written to a pointer that Rust passes as extra argument to the method (AKA an out pointer). This is because some foreign languages, like Python, don't support returning C structs like <code>RustBuffer</code> (issue). Methods that don't return anything still have an out pointer argument, but it's never written to.</p> <p>The first argument is a <code>u64</code> handle. Different bindings have different systems for callback interface handles, but they generally fall into 2 camps: * The handle is the key to a hash map that maps <code>u64</code> -&gt; callback interface objects. * The is a raw pointer to a callback interface object cast to a <code>u64</code>.</p> <p>The method call is handled very similarly to a Rust method call:</p> <ul> <li>If the function returns successfully then the lowered return value is written to <code>uniffi_out_return</code> and nothing is written to <code>uniffi_call_status</code>.</li> <li>If the function throws the exception that corresponds to the <code>Result::Err</code> side of the Rust function, then:</li> <li>The foreign bindings set <code>uniffi_call_status.code</code> to <code>RustCallStatusCode::Error</code></li> <li>The foreign bindings serialize the error into a <code>RustBuffer</code> and write it to <code>uniffi_call_status.error_buf</code>.</li> <li>Nothing is written to <code>uniffi_out_return</code>.</li> <li>If the method throws some other exception, then:</li> <li>The foreign bindings set <code>uniffi_call_status.code</code> to <code>RustCallStatusCode::InternalError</code></li> <li>The foreign bindings should try to to serialize the error message to a <code>RustBuffer</code> and write it to <code>error_buf</code>.     However, bindings may also not write to <code>error_buf</code> and the generated Rust code will handle this.</li> <li>Nothing is written to <code>uniffi_out_return</code>.</li> <li>If the callback method returns a <code>Result&lt;T, E&gt;</code> type and the bindings implement <code>From&lt;uniffi::UnexpectedUniFFICallbackError&gt; for E</code>,     then the generated Rust will convert the error to an <code>Err(E)</code> value and return it.</li> <li>If not, then the Rust bindings will panic.     This is why it's recommended to always have callback methods return <code>Result</code> types and implement <code>From&lt;uniffi::UnexpectedUniFFICallbackError&gt;</code>.</li> </ul>"},{"location":"internals/foreign_calls.html#vtable-free-method","title":"VTable free method","text":"<p>Each vtable also stores a free method that inputs a <code>uniffi_handle</code>. The generated Rust code calls this in the <code>Drop</code> implementation for the callback interface. The foreign bindings are responsible for releasing any resources associated with the handle, this usually means removing the hash map entry for it or freeing the raw pointer.</p>"},{"location":"internals/foreign_calls.html#registering-vtables-and-calling-methods","title":"Registering VTables and calling methods","text":"<p>As shown in the example code, UniFFI generates a function to register the vtable for each callback interface. The foreign bindings must all this function before returning any callback interface handles, usually this is done at startup. When a callback interface method is called, the generated code finds the registered vtable, looks up the field for the method, then uses the function pointer for that field to make the call.</p>"},{"location":"internals/lifting_and_lowering.html","title":"Lifting, Lowering and Serialization","text":"<p>UniFFI is able to transfer rich data types back-and-forth between the Rust code and the foreign-language code via a process we refer to as \"lowering\" and \"lifting\".</p> <p>Recall that UniFFI interoperates between different languages by defining a C-style FFI layer which operates in terms of primitive data types and plain functions. To transfer data from one side of this layer to the other, the sending side \"lowers\" the data from a language-specific data type into one of the primitive types supported by the FFI-layer functions, and the receiving side \"lifts\" that primitive type into its own language-specific data type.</p> <p>Lifting and lowering simple types such as integers is done by directly casting the value to and from an appropriate type. Non-trivial types such as Strings, Optionals and Records, etc. are lowered to a byte buffer called a <code>RustBuffer</code> internally.</p> <p>For example, a Python <code>str</code> is passed to Rust by lowering it to a <code>RustBuffer</code>, which is then lifted to a Rust <code>String</code></p> <pre><code>block-beta\n  columns 2\n  block:PythonLayer\n    columns 1\n    PythonTitle[\"Python\"]\n    PythonStr[\"str\"]\n  end\n  block:RustLayer\n    columns 1\n    RustTitle[\"Rust\"]\n    RustString[\"String\"]\n  end\n  block:FFILayer:2\n    columns 3\n    space:2\n    FfiTitle[\"FFI\"]\n    space\n    RustBuffer[\"RustBuffer\"]\n    space\n  end\n\n  PythonStr --\"Lower\"--&gt; RustBuffer\n  RustBuffer --\"Lift\"--&gt; RustString\n\nclassDef default stroke:transparent,fill:#fff\nclassDef layer stroke:#c0c0c0,fill:#cae9ff\nclassDef title stroke:transparent,fill:transparent,color:#f72585\nclassDef invisible stroke:transparent,fill:transparent\nclass RustLayer layer\nclass PythonLayer layer\nclass FFILayer layer\nclass RustTitle title\nclass PythonTitle title\nclass FfiTitle title</code></pre>"},{"location":"internals/lifting_and_lowering.html#lifting-and-lowering-when-calling-functions","title":"Lifting and Lowering when calling functions","text":"<p>As a concrete example, consider this interface for accumulating a list of integers:</p> <pre><code>namespace example {\n  sequence&lt;i32&gt; add_to_list(i32 item);\n}\n</code></pre> <p>Calling this function from foreign language code involves lowering the arguments, calling an FFI function, lifting the arguments, then calling the original function.</p> <pre><code>block-beta\n  columns 2\n  block:PythonUserLayer\n    columns 1\n    PythonTitle[\"Generated Python function\"]\n    PythonFunc[\"add_to_list(int) -&gt; [int]\"]\n  end\n  block:RustUserLayer\n    columns 1\n    RustTitle[\"User-defined Rust Function\"]\n    RustFunc[\"add_to_list(i32) -&gt; Vec&lt;i32&gt;\"]\n  end\n  space:2\n  block:ScaffoldingLayer:2\n    columns 1\n    ScaffoldingFunc[\"uniffi_fn_add_to_list(int32_t) -&gt; RustBuffer\"]\n    ScaffoldingTitle[\"Generated Rust scaffolding function\"]\n  end\n\n  PythonFunc -- \"Lower\" --&gt; ScaffoldingFunc\n  ScaffoldingFunc -- \"Lift\" --&gt; RustFunc\n\nclassDef default stroke:transparent,fill:#fff\nclassDef layer stroke:#c0c0c0,fill:#cae9ff\nclassDef title stroke:transparent,fill:transparent,color:#f72585\nclassDef invisible stroke:transparent,fill:transparent\n\nclass PythonUserLayer layer\nclass RustUserLayer layer\nclass ScaffoldingLayer layer\n\nclass RustTitle title\nclass PythonTitle title\nclass ScaffoldingTitle title</code></pre> <p>Details:</p> <ol> <li>UniFFI generates an <code>add_to_list</code> function in the foreign language (Python in the example    diagram).  In this function the <code>item</code> argument and the return type are language-native types.</li> <li>The generated function lowers each argument.  Since the <code>item</code> argument is a plain integer,    it is lowered by casting to an <code>int32_t</code>.</li> <li>The generated Python function passes the lowered arguments to the Rust scaffolding function.    This is a <code>repr(C)</code> FFI function in Rust library and named <code>uniffi_fn_add_to_list</code> in this example.</li> <li>The Rust scaffolding function lifts each argument received over the FFI into a native Rust type.    Since <code>item</code> is a plain integer no conversion is needed.</li> <li>The Rust scaffolding passes the lifted arguments to the user-defined Rust <code>add_to_list</code> function, which then executes normally.</li> <li>The Rust scaffolding function receives the return value and now needs to lower the it to pass it back across the FFI.    Since this type's <code>::FfiType</code> is a <code>RustBuffer</code>, it's lowered by serializing the values into a byte buffer (<code>RustBuffer</code>), which is then returned.</li> <li>The generated Python function receives the return value, and then lifts it to a native data type.    Since this type's <code>::FfiType</code> is a <code>RustBuffer</code>, it's lifted by deserializing a language-native list of integers from the RustBuffer.</li> </ol>"},{"location":"internals/lifting_and_lowering.html#lowered-types","title":"Lowered Types","text":"UDL Type Representation in the C FFI <code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code> <code>int8_t</code>/<code>int16_t</code>/<code>int32_t</code>/<code>int64_t</code> <code>u8</code>/<code>u16</code>/<code>u32</code>/<code>u64</code> <code>uint8_t</code>/<code>uint16_t</code>/<code>uint32_t</code>/<code>uint64_t</code> <code>f32</code>/<code>float</code> <code>float</code> <code>f64</code>/<code>double</code> <code>double</code> <code>boolean</code> <code>int8_t</code>, either <code>0</code> or <code>1</code> <code>string</code> <code>RustBuffer</code> struct pointing to utf8 bytes <code>bytes</code> Same as <code>sequence&lt;u8&gt;</code> <code>timestamp</code> <code>RustBuffer</code> struct pointing to a i64 representing seconds and a u32 representing nanoseconds <code>duration</code> <code>RustBuffer</code> struct pointing to a u64 representing seconds and a u32 representing nanoseconds <code>T?</code> <code>RustBuffer</code> struct pointing to serialized bytes <code>sequence&lt;T&gt;</code> <code>RustBuffer</code> struct pointing to serialized bytes <code>record&lt;string, T&gt;</code> <code>RustBuffer</code> struct pointing to serialized bytes <code>enum</code> and <code>[Enum] interface</code> <code>RustBuffer</code> struct pointing to serialized bytes <code>dictionary</code> <code>RustBuffer</code> struct pointing to serialized bytes <code>interface</code> <code>void*</code> opaque pointer to object on the heap"},{"location":"internals/lifting_and_lowering.html#serialization-format","title":"Serialization Format","text":"<p>When serializing complex data types into a byte buffer, UniFFI uses an ad-hoc fixed-width format which is designed mainly for simplicity. The details of this format are internal only and may change between versions of UniFFI.</p> UDL Type Representation in serialized bytes <code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code> Fixed-width 1/2/4/8-byte signed integer, big-endian <code>u8</code>/<code>u16</code>/<code>u32</code>/<code>u64</code> Fixed-width 1/2/4/8-byte unsigned integer, big-endian <code>f32</code>/<code>float</code> Fixed-width 4-byte float, big-endian <code>f64</code>/<code>double</code> Fixed-width 8-byte double, big-endian <code>boolean</code> Fixed-width 1-byte signed integer, either <code>0</code> or <code>1</code> <code>string</code> Serialized <code>i32</code> length followed by utf-8 string bytes; no trailing null <code>T?</code> If null, serialized <code>boolean</code> false; if non-null, serialized <code>boolean</code> true followed by serialized <code>T</code> <code>sequence&lt;T&gt;</code> Serialized <code>i32</code> item count followed by serialized items; each item is a serialized <code>T</code> <code>record&lt;string, T&gt;</code> Serialized <code>i32</code> item count followed by serialized items; each item is a serialized <code>string</code> followed by a serialized <code>T</code> <code>enum</code> and <code>[Enum] interface</code> Serialized <code>i32</code> indicating variant, numbered in declaration order starting from 1, followed by the serialized values of the variant's fields in declaration order <code>dictionary</code> The serialized value of each field, in declaration order <code>interface</code> Fixed-width 8-byte unsigned integer encoding a pointer to the object on the heap <p>Note that length fields in this format are serialized as signed integers despite the fact that they will always be non-negative. This is to help ease compatibility with JVM-based languages since the JVM uses signed 32-bit integers for its size fields internally.</p>"},{"location":"internals/object_references.html","title":"Managing Object References","text":"<p>UniFFI interfaces represent instances of objects that have methods and contain state. One of Rust's core innovations is its ability to provide compile-time guarantees about working with such instances, including:</p> <ul> <li>Ensuring that each instance has a unique owner responsible for disposing of it.</li> <li>Ensuring that there is only a single writer or multiple readers of an object   active at any point in the program.</li> <li>Guarding against data races.</li> </ul> <p>The very nature of the problems UniFFI tries to solve is that calls may come from foreign languages on any thread, outside of the control of Rust's ownership system. UniFFI itself tries to take a hands-off approach as much as possible and depends on the Rust compiler itself to uphold safety guarantees, without assuming that foreign-language callers will be \"well behaved\".</p>"},{"location":"internals/object_references.html#concurrency","title":"Concurrency","text":"<p>UniFFI's hands-off approach means that all object instances exposed by UniFFI must be safe to access concurrently. In Rust terminology, they must be <code>Send+Sync</code> and must be useable without taking any <code>&amp;mut</code> references.</p> <p>Typically this will mean that the Rust implementation of an object uses some of Rust's data structures for thread-safe interior mutability, such as a <code>Mutex</code> or <code>RwLock</code> or the types from <code>std::atomic</code>. The precise details are completely up to the author of the component - as much as possible, UniFFI tries to stay out of your way, simply requiring that the object implementation is <code>Send+Sync</code> and letting the Rust compiler ensure that this is so.</p>"},{"location":"internals/object_references.html#lifetimes","title":"Lifetimes","text":"<p>In order to allow for instances to be used as flexibly as possible from foreign-language code, UniFFI wraps all object instances in an <code>Arc</code> and leverages their reference-count based lifetimes, allowing UniFFI to largely stay out of handling lifetimes entirely for these objects.</p> <p>When constructing a new object, UniFFI is able to add the <code>Arc</code> automatically, because it knows that the return type of the Rust constructor must be a new uniquely-owned struct of the corresponding type.</p> <p>When you want to return object instances from functions or methods, or store object instances as fields in records, the underlying Rust code will need to work with <code>Arc&lt;T&gt;</code> directly, to ensure that the code behaves in the way that UniFFI expects.</p> <p>When accepting instances as arguments, the underlying Rust code can choose to accept it as an <code>Arc&lt;T&gt;</code> or as the underlying struct <code>T</code>, as there are different use-cases for each scenario.</p> <p>For example, given a interface definition like this:</p> <pre><code>interface TodoList {\n    constructor();\n    void add_item(string todo);\n    sequence&lt;string&gt; get_items();\n};\n</code></pre> <p>On the Rust side of the generated bindings:  - The instance constructor will create an instance of the corresponding <code>TodoList</code> Rust struct  - The owned value is wrapped in an <code>Arc&lt;&gt;</code>  - The <code>Arc&lt;&gt;</code> is lowered into the foreign code using <code>Arc::into_raw</code> and returned as an object pointer.</p> <p>This is the \"arc to pointer\" dance. Note that this has \"leaked\" the <code>Arc&lt;&gt;</code> reference out of Rusts ownership system and given it to the foreign-language code. The foreign-language code must pass that pointer back into Rust in order to free it, or our instance will leak.</p> <p>When invoking a method on the instance:  - The foreign-language code passes the raw pointer back to the Rust code, conceptually passing a \"borrow\" of the <code>Arc&lt;&gt;</code> to the Rust scaffolding.  - The Rust side calls <code>Arc::from_raw</code> to convert the pointer into an an <code>Arc&lt;&gt;</code>  - It wraps the <code>Arc</code> in <code>std::mem::ManuallyDrop&lt;&gt;</code>, which we never actually    drop.  This is because the Rust side is borrowing the Arc and shouldn't    run the destructor and decrement the reference count.  - The <code>Arc&lt;&gt;</code> is cloned and passed to the Rust code</p> <p>Finally, when the foreign-language code frees the instance, it passes the raw pointer a special destructor function so that the Rust code can drop that initial reference (and if that happens to be the final reference, the Rust object will be dropped.).  This simply calls <code>Arc::from_raw</code>, then lets the value drop.</p> <p>Passing instances as arguments and returning them as values works similarly, except that UniFFI does not automatically wrap/unwrap the containing <code>Arc</code>.</p> <p>To see this in action, use <code>cargo expand</code> to see the exact generated code.</p>"},{"location":"internals/rendering_foreign_bindings.html","title":"Rendering Foreign Bindings","text":"<p>This document details the general system that UniFFI uses to render the foreign bindings code.</p> <p>A language binding has to generate code for two separate but entangled requirements:</p> <ul> <li>Generate the API in the target language.</li> <li>Implement the FFI - every type needs an FfiConverter.</li> </ul>"},{"location":"internals/rendering_foreign_bindings.html#api-generation","title":"API generation","text":"<p>Our foreign bindings generation uses the Askama template rendering engine. Askama uses a compile-time macro system that allows the template code to use Rust types directly, calling their methods passing them to normal Rust functions.</p> <p>The templates have access to <code>ci</code>, a <code>ComponentInterface</code>, which is the Rust representation of all the UniFFI types in your crate.</p> <p>The task of the templates is to render <code>ci</code> into a \"module\" for the foreign binding.  This mainly consists of rendering support for each <code>Type</code> described in your crate.</p> <p>Eg, here's where Python uses <code>ci</code> to iterate over the types</p> <p>The templates create foreign-native types for everything from ffi-native types (int/etc) to functions, dictionaries etc. The implementation of these generated types might call your your Rust implemented FFI, as described below.</p> <p>Bidings also need to do alot of work to make language identifiers etc work correctly - eg, turn <code>this_func(this_arg: ThisType)</code> into <code>thisFunc(...)</code></p>"},{"location":"internals/rendering_foreign_bindings.html#breaking-down-a-rust-function-called-by-python","title":"Breaking down a Rust function called by Python.","text":"<p>Let's take a look at where Python generates a top-level public function.</p> <p>This will generate code like the following:</p> <pre><code>def this_func(this_arg=0) -&gt; None:\n</code></pre> <p>Let's break the template down:</p> <pre><code>def {{ func.name()|fn_name }}({%- call py::arg_list_decl(func) -%}) -&gt; None:\n</code></pre> <p>The Askama language uses double-curly braces (<code>{ }</code>) to interpolate blocks of code into the string output.</p> <p><code>{{ func.name()|fn_name }}</code> becomes <code>this_func</code>: It calls the <code>name</code> method on a <code>Function</code> object (you can see all the other metadata about functions there too). Askama uses a \"filter\" concept: Functions that take the value left of the pipe operator (<code>|</code>) to produce a new value. The \"filter\" used in the above template is called<code>fn_name</code> and is defined in the Python bindings generator - which ends up just handing the fact it might be a Python keyword but otherwise returns the same value.</p> <p><code>{%- call py::arg_list_decl(func) -%}</code>: Calling an Askama macro, passing the <code>func</code> object linked above. It knows how to turn the function arguments into valid Python code.</p> <p>Skipping a few lines ahead in that template, we call the FFI function <code>{% call py::to_ffi_call(func) %}</code> - which ultimately end up a call to an <code>extern \"C\"</code> FFI function you generated named something like <code>uniffi_some_name_fn_func_this_func(...)</code></p> <p>The bindings also need to do lots of administrivia - eg, calling initialization functions, importing dependencies, etc</p>"},{"location":"internals/rendering_foreign_bindings.html#implementing-the-ffi","title":"Implementing the FFI.","text":"<p>All types must implement an FFI converter.</p> <p>The FfiConverter is described in the Lifting, Lowering and Serialization chapter. Note that this means different things for \"native\" types (<code>int</code>, etc), but otherwise there's a lot of <code>RustBuffer</code>! eg, the Swift <code>Bool</code> vs Swift record/struct support</p>"},{"location":"internals/rendering_foreign_bindings.html#ffi-functions","title":"FFI Functions","text":"<p>Above, we mentioned your template will generate a call to, eg, <code>uniffi_some_name_fn_func_this_func</code>. This function is automatically generated and made public in your Rust crate - it's a function that might look like:</p> <pre><code>pub extern \"C\" fn uniffi_some_name_fn_func_this_func(\n    arg: i32,\n    call_status: &amp;mut ::uniffi::RustCallStatus,\n) -&gt; i32 {\n</code></pre> <p>The bindings need to use the metadata to create the correct args to make these calls using the FFI converter implementations.</p> <p>There will be a number of memory/lifetime/etc \"adminstrative\" FFI functions that will also be used by the generated implementation.</p>"},{"location":"internals/rust_calls.html","title":"Foreign -&gt; Rust calls","text":"<p>What happens when code in the foreign language makes a call to Rust? The lifting and lowering docs describe this at a high-level, this document will explore the details.</p> <p>This document only describes non-async Rust calls. See the Async FFI docs for a description of async calls.</p>"},{"location":"internals/rust_calls.html#the-ffi-function","title":"The FFI function","text":"<p>For each exported Rust function, an FFI function is generated. This <code>extern \"C\"</code> function is exported in the Rust library and its what's called by the foreign code.</p> <p>Different bindings use different techniques to call these functions. For example, Python uses ctypes to call into a dynamic library, while Swift links to a static library and calls the C functions directly.</p> <p>The signature for the FFI function is: * Arguments:   * The lowered type for each argument of the Rust function   * A <code>RustCallStatus</code> out pointer * Returns:   * For non-unit type returns: the lowered type of the return value for the Rust function   * For unit type returns: <code>void</code> (i.e. no return value, which is special-cased in <code>C</code>).</p>"},{"location":"internals/rust_calls.html#rustcallstatus","title":"RustCallStatus","text":"<p>The last argument for the FFI function is a pointer to a <code>RustCallStatus</code> struct. The FFI function writes to this struct to report errors when calling the Rust function.</p> <p>Here's the layout for this struct:</p> <pre><code>#[repr(C)]\npub struct RustCallStatus {\n    pub code: RustCallStatusCode,\n    pub error_buf: RustBuffer,\n}\n\n#[repr(i8)]\n#[derive(Debug, PartialEq, Eq)]\npub enum RustCallStatusCode {\n    Success = 0,\n    Error = 1,\n    UnexpectedError = 2,\n    Cancelled = 3, // Only used for async calls\n}\n</code></pre> <p>When the foreign code calls the Rust FFI function, it initializes <code>RustCallStatus.code</code> to <code>RustCallStatus::Success</code> and <code>RustCallStatus.error_buf</code> to an empty RustBuffer.  After calling the real Rust function, the generated FFI function writes to this struct:</p> <ul> <li>If the function returns successfully (i.e. it runs normally and returns <code>Ok</code> value for <code>Result</code> return types), then nothing is written.   Since the foreign bindings initialize <code>code=RustCallStatus::Success</code>, this will be interpreted as a successful call.</li> <li>If a <code>Result::Err</code> value is returned then:</li> <li>The generated Rust code sets <code>code</code> to <code>RustCallStatusCode::Error</code></li> <li>The generated Rust code serializes the error into a <code>RustBuffer</code> and stores that in <code>error_buf</code>.</li> <li>The foreign bindings are responsible for deserializing that error into an exception value and     throwing that exception.</li> <li>A placeholder value is returned (e.g. <code>0</code> or an empty <code>RustBuffer</code>);</li> <li>If an unexpected error happens, for example a failure when lifting the arguments, then:</li> <li>The generated Rust code sets <code>code</code> to <code>RustCallStatusCode::InternalError</code></li> <li>The generated Rust code tries to serialize the error message to a <code>RustBuffer</code> and store it <code>error_buf</code>.     However, it's possible this fails in which case <code>error_buf</code> not be written to.</li> <li>A placeholder value is returned</li> <li>The foreign bindings are responsible throwing some sort of UniFFI internal exception.     If possible, this exception should contain the error message.</li> </ul>"},{"location":"internals/rust_calls.html#method-calls","title":"Method calls","text":"<p>Method calls work the same as function calls, except there's an extra argument for the object handle. This means the arguments are:</p> <ul> <li>The object handle (<code>void *</code>).   This is cloned before making the call as described in object references.</li> <li>The lowered type for each Rust argument</li> <li>A <code>RustCallStatus</code> out pointer</li> </ul>"},{"location":"internals/rust_calls.html#panic-handling","title":"Panic handling","text":"<p>UniFFI uses <code>std::panic::catch_unwind</code> to try to catch any panics in the Rust code. The main reason is to prevent them from moving up the call stack into the foreign language's frames, which would almost certainly lead to a crash. Panics are treated as unexpected errors as described above. UniFFI can't always catch panics, for example when the Rust panic handler is set to <code>abort</code>.</p>"},{"location":"kotlin/configuration.html","title":"Configuration","text":"<p>The generated Kotlin modules can be configured using a <code>uniffi.toml</code> configuration file.</p>"},{"location":"kotlin/configuration.html#available-options","title":"Available options","text":"Configuration name Default Description <code>package_name</code> <code>uniffi</code> The Kotlin package name - ie, the value used in the <code>package</code> statement at the top of generated files. <code>cdylib_name</code> <code>uniffi_{namespace}</code>[^1] The name of the compiled Rust library containing the FFI implementation (not needed when using <code>generate --library</code>). <code>generate_immutable_records</code> <code>false</code> Whether to generate records with immutable fields (<code>val</code> instead of <code>var</code>). <code>custom_types</code> A map which controls how custom types are exposed to Kotlin. See the custom types section of the manual <code>external_packages</code> A map of packages to be used for the specified external crates. The key is the Rust crate name, the value is the Kotlin package which will be used referring to types in that crate. See the external types section of the manual <code>android</code> <code>false</code> Used to toggle on Android specific optimizations <code>android_cleaner</code> <code>android</code> Use the <code>android.system.SystemCleaner</code> instead of <code>java.lang.ref.Cleaner</code>. Fallback in both instances is the one shipped with JNA. <code>kotlin_target_version</code> <code>\"x.y.z\"</code> When provided, it will enable features in the bindings supported for this version. The build process will fail if an invalid format is used. <code>disable_java_cleaner</code> <code>false</code> Will disable use of <code>java.lang.ref.Cleaner</code> so generated code can be compatible with Java 8. <code>omit_checksums</code> <code>false</code> Whether to omit checking the library checksums as the library is initialized. Changing this will shoot yourself in the foot if you mixup your build pipeline in any way, but might speed up initialization."},{"location":"kotlin/configuration.html#example","title":"Example","text":"<p>Custom types <pre><code># Assuming a Custom Type named URL using a String as the builtin.\n[bindings.kotlin.custom_types.Url]\n# Name of the type in the Kotlin code\ntype_name = \"URL\"\n# Classes that need to be imported\nimports = [ \"java.net.URI\", \"java.net.URL\" ]\n# Functions to convert between strings and URLs\ninto_custom = \"URI({}).toURL()\"\nfrom_custom = \"{}.toString()\"\n</code></pre></p> <p>External types <pre><code>[bindings.kotlin.external_packages]\n# This specifies that external types from the crate `rust-crate-name` will be referred by by the package `\"kotlin.package.name`.\nrust-crate-name = \"kotlin.package.name\"\n</code></pre></p>"},{"location":"kotlin/gradle.html","title":"Integrating with Gradle","text":"<p>It is possible to generate Kotlin bindings at compile time for Kotlin Android projects. We'd like to make a gradle plugin for that, but until then you can add to your <code>build.gradle</code> the following:</p> <pre><code>android.libraryVariants.all { variant -&gt;\n    def t = tasks.register(\"generate${variant.name.capitalize()}UniFFIBindings\", Exec) {\n        workingDir \"${project.projectDir}\"\n        // Runs the bindings generation, note that you must have uniffi-bindgen installed and in your PATH environment variable\n        commandLine 'uniffi-bindgen', 'generate', '&lt;PATH TO .udl FILE&gt;', '--language', 'kotlin', '--out-dir', \"${buildDir}/generated/source/uniffi/${variant.name}/java\"\n    }\n    variant.javaCompileProvider.get().dependsOn(t)\n    def sourceSet = variant.sourceSets.find { it.name == variant.name }\n    sourceSet.java.srcDir new File(buildDir, \"generated/source/uniffi/${variant.name}/java\")\n    // XXX: I've been trying to make this work but I can't, so the compiled bindings will show as \"regular sources\" in Android Studio.\n    idea.module.generatedSourceDirs += file(\"${buildDir}/generated/source/uniffi/${variant.name}/java/uniffi\")\n}\n</code></pre> <p>The generated bindings should appear in the project sources in Android Studio.</p>"},{"location":"kotlin/gradle.html#using-experimental-unsigned-types","title":"Using experimental unsigned types","text":"<p>Unsigned integers in the defined API are translated to their equivalents in the foreign language binding, e.g. <code>u32</code> becomes Kotlin's <code>UInt</code> type. See Built-in types.</p> <p>However unsigned integer types are experimental in Kotlin versions prior to 1.5. As such they require explicit annotations to suppress warnings. Uniffi is trying to add these annotations where necessary, but currently misses some places, see PR #977 for details.</p> <p>To suppress all warnings for experimental unsigned types add this to your project's <code>build.gradle</code> file:</p> <pre><code>allprojects {\n   tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {\n        kotlinOptions {\n            freeCompilerArgs += [\n                \"-Xuse-experimental=kotlin.ExperimentalUnsignedTypes\",\n            ]\n        }\n    }\n}\n</code></pre>"},{"location":"kotlin/gradle.html#update","title":"Update","text":"<p>As of PR #993, the Kotlin backend was refactored, and it became harder to support the <code>@ExperimentalUnsignedTypes</code> annotation. Uniffi's Android customers are rapidly moving toward Kotlin 1.5, so adding this compiler arg is no longer necessary.</p>"},{"location":"kotlin/gradle.html#jna-dependency","title":"JNA dependency","text":"<p>UniFFI relies on JNA for the ability to call native methods. JNA 5.12.0 or greater is required.</p> <p>Set the dependency in your <code>build.gradle</code>:</p> <pre><code>dependencies {\n    implementation \"net.java.dev.jna:jna:5.12.0@aar\"\n}\n</code></pre>"},{"location":"kotlin/gradle.html#advise-on-rust-java-interop","title":"Advise on rust-&gt;java interop","text":"<p>It's highly recommend to call <code>AttachCurrentThread</code> when spawning a rust thread, and in that thread we need to call java functions, maybe through uniffi's foreign interface. Otherwise, JNA has to attach and detach a java thread into the native thread in every function call, which is a heavy operation.</p> <pre><code>static VM: once_cell::sync::OnceCell&lt;jni::JavaVM&gt; = once_cell::sync::OnceCell::new();\n\n// need call this function in java/kotlin first\n#[export_name = \"Java_com_xxx_xxx\"]\npub extern \"system\" fn java_init(\n    env: jni::JNIEnv,\n    _class: jni::objects::JClass,\n    app: jni::objects::JObject,\n) {\n    let vm = env.get_java_vm().unwrap();\n    _ = VM.set(vm);\n}\n\n// take tokio for example, and we need to call uniffi's callback in the tokio worker threads -\ntokio::runtime::Builder::new_multi_thread().on_thread_start(|| {\n    let vm = VM.get().expect(\"init java vm\");\n    vm.attach_current_thread_permanently().unwrap();\n}).build().unwrap();\n</code></pre>"},{"location":"kotlin/gradle.html#coroutines-dependency","title":"Coroutines dependency","text":"<p>UniFFI relies on kotlinx coroutines core for future and async support. Version 1.6 or greater is required.</p> <p>Set the dependency in your <code>build.gradle</code>:</p> <pre><code>dependencies {\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4\"\n}\n</code></pre>"},{"location":"kotlin/lifetimes.html","title":"Kotlin Lifetimes","text":"<p>All interfaces exposed via Kotlin expose a public API for freeing the Kotlin wrapper object in lieu of reliable finalizers. This is done by making the \"base class\" for all such generated objects implement the <code>Disposable</code> and <code>AutoCloseable</code> interfaces.</p> <p>As such, these wrappers all implement a <code>close()</code> method, which must be explicitly called to ensure the associated Rust resources are reclaimed.</p> <p>The best way to arrange for this to be called at the right time is beyond the scope of this document; you should consult the official documentation for <code>AutoClosable</code>, but one common pattern is the Kotlin use function.</p>"},{"location":"kotlin/lifetimes.html#nested-objects","title":"Nested objects","text":"<p>We also need to consider what happens when objects are contained in other objects. The current situation is:</p> <ul> <li> <p>Dictionaries that contain interfaces implement <code>AutoClosable</code> with their close() method closing   any contained interfaces.</p> </li> <li> <p>Enums can't currently contain interfaces.</p> </li> <li> <p>Lists/Maps don't implement <code>AutoClosable</code>; if you have a list/map of interfaces   you need to close each one individually.</p> </li> </ul>"},{"location":"proc_macro/index.html","title":"Procedural Macros: Attributes and Derives","text":"<p>UniFFI allows you to define your function signatures and type definitions directly in your Rust code, avoiding the need to duplicate them in a UDL file and so avoiding the possibility for the two to get out of sync. This  mechanism is based on Procedural Macros (proc-macros), specifically the attribute and derive macros.</p> <p>You can have this mechanism extract some kinds of definitions out of your Rust code, in addition to what is declared in the UDL file. However, you have to make sure that the UDL file is still valid on its own: All types referenced in fields, parameter and return types in UDL must also be declared in UDL.</p> <p>Further, using this capability probably means you still need to refer to the UDL documentation, because at this time, that documentation tends to conflate the UniFFI type model and the description of how foreign bindings use that type model. For example, the documentation for a UDL interface describes both how it is defined in UDL and how Swift and Kotlin might use that interface. The latter is relevant even if you define the interface using proc-macros instead of in UDL.</p> <p>\u26a0 Warning \u26a0 This facility is relatively new, so things may change often. However, this remains true for all of UniFFI, so proceed with caution and the knowledge that things may break in the future.</p>"},{"location":"proc_macro/index.html#build-workflow","title":"Build workflow","text":"<p>Be sure to use library mode when using UniFFI proc-macros (See the Foreign language bindings docs for more info).</p> <p>If your crate's API is declared using only proc-macros and not UDL files, call the <code>uniffi::setup_scaffolding</code> macro at the top of your source code:</p> <pre><code>uniffi::setup_scaffolding!();\n</code></pre> <p>\u26a0 Warning \u26a0 Do not call both <code>uniffi::setup_scaffolding!()</code> and <code>uniffi::include_scaffolding!!()</code> in the same crate.</p>"},{"location":"proc_macro/index.html#the-uniffiexport-attribute","title":"The <code>#[uniffi::export]</code> attribute","text":"<p>The most important proc-macro is the <code>export</code> attribute. It can be used on functions, <code>impl</code> blocks, and <code>trait</code> definitions to make UniFFI aware of them.</p> <pre><code>#[uniffi::export]\nfn hello_ffi() {\n    println!(\"Hello from Rust!\");\n}\n</code></pre> <p>For more details:</p> <ul> <li>Records</li> <li>Enums</li> <li>Interfaces</li> <li>Functions, constructors, methods</li> <li>Errors</li> </ul>"},{"location":"proc_macro/index.html#the-uniffiobject-derive-to-extend-interfaces-defined-in-udl","title":"The <code>uniffi::Object</code> derive to extend interfaces defined in UDL","text":"<p>This derive can be used to replace an <code>interface</code> definition in UDL. Every object type must have either an <code>interface</code> definition in UDL or use this derive macro. However, <code>#[uniffi::export]</code> can be used on an impl block for an object type regardless of whether this derive is used. You can also mix and match, and define some method of an object via proc-macro while falling back to UDL for methods that are not supported by <code>#[uniffi::export]</code> yet; just make sure to use separate <code>impl</code> blocks:</p> <pre><code>// UDL file\n\ninterface Foo {\n    void method_a();\n};\n</code></pre> <pre><code>// Rust file\n\n// Not deriving uniffi::Object since it is defined in UDL\nstruct Foo {\n    // ...\n}\n\n// Implementation of the method defined in UDL\nimpl Foo {\n    fn method_a(&amp;self) {\n        // ...\n    }\n}\n\n// Another impl block with an additional method\n#[uniffi::export]\nimpl Foo {\n    fn method_b(&amp;self) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"proc_macro/index.html#the-unifficustom_type-and-unifficustom_newtype-macros","title":"The <code>uniffi::custom_type</code> and <code>uniffi::custom_newtype</code> macros","text":"<p>See the general documentation for Custom Types, which apply equally to proc-macros as to UDL.</p>"},{"location":"proc_macro/index.html#the-uniffiexportcallback_interface-attribute","title":"The <code>#[uniffi::export(callback_interface)]</code> attribute","text":"<p><code>#[uniffi::export(callback_interface)]</code> can be used to export a callback interface definition. This allows the foreign bindings to implement the interface and pass an instance to the Rust code.</p> <pre><code>#[uniffi::export(callback_interface)]\npub trait Person {\n    fn name() -&gt; String;\n    fn age() -&gt; u32;\n}\n\n// Corresponding UDL:\n// callback interface Person {\n//     string name();\n//     u32 age();\n// }\n</code></pre>"},{"location":"proc_macro/index.html#conditional-compilation","title":"Conditional compilation","text":"<p><code>uniffi::constructor|method]</code> will work if wrapped with <code>cfg_attr</code> attribute: <pre><code>#[cfg_attr(feature = \"foo\", uniffi::constructor)]\n</code></pre> Other attributes are not currently supported, see #2000 for more details.</p>"},{"location":"proc_macro/index.html#mixing-udl-and-proc-macros","title":"Mixing UDL and proc-macros","text":"<p>If you use both UDL and proc-macro generation, then your crate name must match the namespace in your UDL file. This restriction will be lifted in the future.</p>"},{"location":"proc_macro/docstrings.html","title":"Docstrings","text":"<p>In proc-macros, Rust docstrings will be captured and rendered in the bindings.</p> <p>For example: <pre><code>/// This is the docstring for MyObject\n#[derive(uniffi::Object)]\npub struct MyObject {}\n</code></pre></p> <p>Will cause Python, Swift and Kotlin to all generate a wrapper for <code>MyObject</code> with appropriate docstrings for that language.</p> <p>You can see examples of how they are rendered in the UDL docstrings documentation</p>"},{"location":"proc_macro/enumerations.html","title":"Enumerations","text":""},{"location":"proc_macro/enumerations.html#the-uniffienum-derive","title":"The <code>uniffi::Enum</code> derive","text":"<p>The <code>Enum</code> derive macro works much like the <code>Record</code> derive macro. Any fields inside variants must be named. All types that are supported as parameter and return types by <code>#[uniffi::export]</code> are also supported as field types.</p> <p>It is permitted to use this macro on a type that is also defined in the UDL file as long as the two definitions are equal in the names and ordering of variants and variant fields, and any field types inside variants are UniFFI builtin types; user-defined types might be allowed in the future.</p> <pre><code>#[derive(uniffi::Enum)]\npub enum MyEnum {\n    Fieldless,\n    WithFields {\n        foo: u8,\n        bar: Vec&lt;i32&gt;,\n    },\n    WithValue = 3,\n}\n</code></pre>"},{"location":"proc_macro/enumerations.html#variant-discriminants","title":"Variant Discriminants","text":"<p>Variant discriminants are accepted by the macro but how they are used depends on the bindings.</p> <p>For example this enum:</p> <pre><code>#[derive(uniffi::Enum)]\npub enum MyEnum {\n    Foo = 3,\n    Bar = 4,\n}\n</code></pre> <p>would give you in Kotlin &amp; Swift:</p> <pre><code>// kotlin\nenum class MyEnum {\n    FOO,\n    BAR;\n    companion object\n}\n// swift\npublic enum MyEnum {\n    case foo\n    case bar\n}\n</code></pre> <p>which means you cannot use the platforms helpful methods like <code>value</code> or <code>rawValue</code> to get the underlying discriminants. Adding a <code>repr</code> will allow the type to be defined in the foreign bindings.</p> <p>For example:</p> <pre><code>// added the repr(u8), also u16 -&gt; u64 supported\n#[repr(u8)]\n#[derive(uniffi::Enum)]\npub enum MyEnum {\n    Foo = 3,\n    Bar = 4,\n}\n</code></pre> <p>will now generate:</p> <pre><code>// kotlin\nenum class MyEnum(val value: UByte) {\n    FOO(3u),\n    BAR(4u);\n    companion object\n}\n\n// swift\npublic enum MyEnum : UInt8 {\n    case foo = 3\n    case bar = 4\n}\n</code></pre>"},{"location":"proc_macro/errors.html","title":"The <code>uniffi::Error</code> derive","text":"<p>The <code>Error</code> derive registers a type as an error and can be used on any enum that the <code>Enum</code> derive also accepts. By default, it exposes any variant fields to the foreign code. This type can then be used as the <code>E</code> in a <code>Result&lt;T, E&gt;</code> return type of an exported function or method. The generated foreign function for an exported function with a <code>Result&lt;T, E&gt;</code> return type will have the result's <code>T</code> as its return type and throw the error in case the Rust call returns <code>Err(e)</code>.</p> <pre><code>#[derive(uniffi::Error)]\npub enum MyError {\n    MissingInput,\n    IndexOutOfBounds {\n        index: u32,\n        size: u32,\n    }\n    // tuple-enums work.\n    Generic(String),\n}\n\n#[uniffi::export]\nfn do_thing() -&gt; Result&lt;(), MyError&gt; {\n    // ...\n}\n</code></pre> <p>You can also use the helper attribute <code>#[uniffi(flat_error)]</code> to expose just the variants but none of the fields. In this case the error will be serialized using Rust's <code>ToString</code> trait and will be accessible as the only field on each of the variants. The types of the fields can be any UniFFI supported type and don't need to implement any special traits.</p> <pre><code>#[derive(uniffi::Error)]\n#[uniffi(flat_error)]\npub enum MyApiError {\n    Http(reqwest::Error),\n    Json(serde_json::Error),\n}\n\n// ToString is not usually implemented directly, but you get it for free by implementing Display.\n// This impl could also be generated by a proc-macro, for example thiserror::Error.\nimpl std::fmt::Display for MyApiError {\n    // ...\n}\n\n#[uniffi::export]\nfn do_http_request() -&gt; Result&lt;(), MyApiError&gt; {\n    // ...\n}\n</code></pre>"},{"location":"proc_macro/functions.html","title":"Functions, Constructors, Methods","text":"<p>Functions are exported to the namespace with the <code>#[uniffi::export]</code> attribute</p> <pre><code>#[uniffi::export]\nfn hello_world() -&gt; String {\n    \"Hello World!\".to_owned()\n}\n</code></pre> <p>All our owned types can be used as arguments and return types.</p> <p>Arguments and receivers can also be references to these types, for example:</p> <pre><code>// Input data types as references\n#[uniffi::export]\nfn process_data(a: &amp;MyRecord, b: &amp;MyEnum, c: &amp;Option&lt;MyRecord&gt;) {\n    ...\n}\n</code></pre> <p>To export methods of an interface you can use the <code>#[uniffi::export]</code> attribute on an impl block.</p>"},{"location":"proc_macro/functions.html#default-values","title":"Default values","text":"<p>Exported functions/methods can have default values using the <code>default</code> argument of the attribute macro that wraps them. <code>default</code> inputs a comma-separated list of <code>[name]=[value]</code> items.</p> <pre><code>#[uniffi::export(default(text = \" \", max_splits = None))]\npub fn split(\n    text: String,\n    sep: String,\n    max_splits: Option&lt;u32&gt;,\n) -&gt; Vec&lt;String&gt; {\n  ...\n}\n\n#[derive(uniffi::Object)]\npub struct TextSplitter { ... }\n\n#[uniffi::export]\nimpl TextSplitter {\n    #[uniffi::constructor(default(ignore_unicode_errors = false))]\n    fn new(ignore_unicode_errors: boolean) -&gt; Self {\n        ...\n    }\n\n    #[uniffi::method(default(text = \" \", max_splits = None))]\n    fn split(\n        text: String,\n        sep: String,\n        max_splits: Option&lt;u32&gt;,\n    ) -&gt; Vec&lt;String&gt; {\n      ...\n    }\n}\n</code></pre> <p>Supported default values:</p> <ul> <li>String, integer, float, and boolean literals</li> <li><code>[]</code> for empty Vecs</li> <li><code>Option&lt;T&gt;</code> allows either <code>None</code> or <code>Some(T)</code></li> </ul>"},{"location":"proc_macro/functions.html#renaming-functions-methods-and-constructors","title":"Renaming functions, methods and constructors","text":"<p>A single exported function can specify an alternate name to be used by the bindings by specifying a <code>name</code> attribute.</p> <p><pre><code>#[uniffi::export(name = \"something\")]\nfn do_something() {\n}\n</code></pre> will be exposed to foreign bindings as a namespace function <code>something()</code></p> <p>You can also rename constructors and methods: <pre><code>#[uniffi::export]\nimpl Something {\n    // Set this as the default constructor by naming it `new`\n    #[uniffi::constructor(name = \"new\")]\n    fn make_new() -&gt; Arc&lt;Self&gt; { ... }\n\n    // Expose this as `obj.something()`\n    #[uniffi::method(name = \"something\")]\n    fn do_something(&amp;self) { }\n}\n</code></pre></p>"},{"location":"proc_macro/interfaces.html","title":"The <code>uniffi::Object</code> derive","text":"<p>The <code>Object</code> derive registers a UniFFI interface.</p> <pre><code>#[derive(uniffi::Object)]\nstruct MyObject {\n    // ...\n}\n</code></pre> <p>The <code>#[uniffi::export]</code> attribute is used on an impl block to export methods of the interface.</p> <pre><code>#[uniffi::export]\nimpl MyObject {\n    // Constructors need to be annotated as such.\n    // The return value can be either `Self` or `Arc&lt;Self&gt;`\n    // It is the primary constructor, so in most languages this is invoked with\n    `MyObject()`.\n    #[uniffi::constructor]\n    fn new(argument: String) -&gt; Arc&lt;Self&gt; {\n        // ...\n    }\n\n    // Constructors with different names are also supported, usually invoked\n    // as `MyObject.named()` (depending on the target language)\n    #[uniffi::constructor]\n    fn named() -&gt; Arc&lt;Self&gt; {\n        // ...\n    }\n\n    // All functions that are not constructors must have a `self` argument\n    fn method_a(&amp;self) {\n        // ...\n    }\n\n    // Returning objects is also supported, either as `Self` or `Arc&lt;Self&gt;`\n    fn method_b(self: Arc&lt;Self&gt;) {\n        // ...\n    }\n}\n</code></pre> <p>Impl blocks without the <code>#[uniffi::export]</code> are ignored by UniFFI. You can use the <code>#[uniffi::export]</code> attribute on any number of impl blocks.</p> <p>See more about constructors here</p>"},{"location":"proc_macro/interfaces.html#traits","title":"Traits","text":"<pre><code>#[uniffi::export]\ntrait MyTrait {\n    // ...\n}\n</code></pre> <p>And a foreign trait:</p> <pre><code>#[uniffi::export(with_foreign)]\ntrait MyTrait {\n    // ...\n}\n</code></pre>"},{"location":"proc_macro/interfaces.html#arguments","title":"Arguments","text":"<pre><code>#[uniffi::export]\nimpl Foo {\n  // Methods can take a `&amp;self`, which will be borrowed from `Arc&lt;Self&gt;`\n  fn some_method(&amp;self) {\n    ...\n  }\n}\n\n// Input foo as an Arc and bar as a reference\nfn call_both(foo: Arc&lt;Foo&gt;, bar: &amp;Foo) {\n  foo.some_method();\n  bar.some_method();\n}\n</code></pre> <p>The one restriction is that the reference must be visible in the function signature.  This wouldn't work:</p> <pre><code>type MyFooRef = &amp;'static Foo;\n\n// ERROR: UniFFI won't recognize that the `foo` argument is a reference.\n#[uniffi::export]\nfn do_something(foo: MyFooRef) {\n}\n</code></pre>"},{"location":"proc_macro/interfaces.html#structs-implementing-traits","title":"Structs implementing traits.","text":"<p>You can declare that an object implements a trait. For example:</p> <pre><code>#[uniffi::export]\ntrait MyTrait { .. }\n\n#[derive(uniffi::Object)]\nstruct MyObject {}\n\n#[uniffi::export]\nimpl MyObject {\n    // ... some methods\n}\n\n#[uniffi::export]\nimpl MyTrait for MyObject {\n    // ... the trait methods.\n}\n</code></pre> <p>This will mean the bindings are able to use both the methods declared directly on <code>MyObject</code> but also be able to be used when a <code>MyTrait</code> is required.</p> <p>Not all bindings support this.</p>"},{"location":"proc_macro/records.html","title":"The <code>uniffi::Record</code> derive","text":"<p>The <code>Record</code> derive macro exposes a <code>struct</code> with named fields over FFI. All types that are supported as parameter and return types by <code>#[uniffi::export]</code> are also supported as field types here.</p> <p>It is permitted to use this macro on a type that is also defined in the UDL file, as long as all field types are UniFFI builtin types; user-defined types might be allowed in the future. You also have to maintain a consistent field order between the Rust and UDL files (otherwise compilation will fail).</p> <pre><code>#[derive(uniffi::Record)]\npub struct MyRecord {\n    pub field_a: String,\n    pub field_b: Option&lt;Arc&lt;MyObject&gt;&gt;,\n    // Fields can have default values\n    #[uniffi(default = \"hello\")]\n    pub greeting: String,\n    #[uniffi(default = true)]\n    pub some_flag: bool,\n}\n</code></pre> <p>Most types can have default values - all defaults described for function arguments apply here too.</p>"},{"location":"python/configuration.html","title":"Configuration","text":"<p>The generated Python modules can be configured using a <code>uniffi.toml</code> configuration file.</p>"},{"location":"python/configuration.html#available-options","title":"Available options","text":"Configuration name Default Description <code>cdylib_name</code> <code>uniffi_{namespace}</code>[^1] The name of the compiled Rust library containing the FFI implementation (not needed when using <code>generate --library</code>). <code>custom_types</code> A map which controls how custom types are exposed to Python. See the custom types section of the manual <code>external_packages</code> A map which controls the package name used by external packages. See below for more."},{"location":"python/configuration.html#external-packages","title":"External Packages","text":"<p>When you reference external modules, uniffi will generate statements like <code>from module import Type</code> in the referencing module. The <code>external_packages</code> configuration value allows you to specify how <code>module</code> is formed in such statements.</p> <p>The value is a map, keyed by the crate-name and the value is the package name which will be used by Python for that crate. The default value is an empty map.</p> <p>When looking up crate-name, the following behavior is implemented.</p>"},{"location":"python/configuration.html#default-value","title":"Default value","text":"<p>If no value for the crate is found, it is assumed that you will be packaging up your library as a simple Python package, so the statement will be of the form <code>from .module import Type</code>, where <code>module</code> is the namespace specified in that crate.</p> <p>Note that this is invalid syntax unless the module lives in a package - attempting to use the module as a stand-alone module will fail. UniFFI just generates flat .py files; the packaging is up to you. Eg, a build process might create a directory, create an <code>__init__.py</code> file in that directory (maybe including <code>from subpackage import *</code>) and have <code>uniffi-bindgen</code> generate the bindings into this directory.</p>"},{"location":"python/configuration.html#specified-value","title":"Specified value","text":"<p>If the crate-name is found in the map, the specified entry used as a package name, so the statement will be of the form <code>from package.module import Type</code> (again, where <code>module</code> is the namespace specified in that crate)</p> <p>An exception is when the specified value is an empty string, in which case you will see <code>from module import Type</code>, so each generated module functions outside a package. This is used by some UniFFI tests to avoid the test code needing to create a Python package.</p>"},{"location":"python/configuration.html#examples","title":"Examples","text":"<p>Custom Types <pre><code># Assuming a Custom Type named URL using a String as the builtin.\n[bindings.python.custom_types.Url]\nimports = [\"urllib.parse\"]\n# Functions to convert between strings and the ParsedUrl class\ninto_custom = \"urllib.parse.urlparse({})\"\nfrom_custom = \"urllib.parse.urlunparse({})\"\n</code></pre></p> <p>External Packages <pre><code>[bindings.python.external_packages]\n# An external type `Foo` in `crate-name` (which specifies a namespace of `my_module`) will be referenced via `from MyPackageName.my_module import Foo`\ncrate-name = \"MyPackageName\"\n</code></pre></p>"},{"location":"swift/configuration.html","title":"Configuration","text":"<p>The generated Swift module can be configured using a <code>uniffi.toml</code> configuration file.</p>"},{"location":"swift/configuration.html#available-options","title":"Available options","text":"<p>The configurations prefixed with <code>experimental_</code> should be regarded as unstable and more likely to change than other configurations.</p> Configuration name Default Description <code>cdylib_name</code> <code>uniffi_{namespace}</code>[^1] The name of the compiled Rust library containing the FFI implementation (not needed when using <code>generate --library</code>). <code>module_name</code> <code>{namespace}</code>[^1] The name of the Swift module containing the high-level foreign-language bindings. <code>ffi_module_name</code> <code>{module_name}FFI</code> The name of the lower-level C module containing the FFI declarations. <code>ffi_module_filename</code> <code>{ffi_module_name}</code> The filename stem for the lower-level C module containing the FFI declarations. <code>generate_module_map</code> <code>true</code> Whether to generate a <code>.modulemap</code> file for the lower-level C module with FFI declarations. (ignored by <code>uniffi-bindgen-swift</code>) <code>omit_argument_labels</code> <code>false</code> Whether to omit argument labels in Swift function definitions. <code>generate_immutable_records</code> <code>false</code> Whether to generate records with immutable fields (<code>let</code> instead of <code>var</code>). <code>custom_types</code> A map which controls how custom types are exposed to Swift. See the custom types section of the manual <code>omit_localized_error_conformance</code> <code>false</code> Whether to make generated error types conform to <code>LocalizedError</code>. <code>generate_case_iterable_conformance</code> <code>false</code> Whether to make simple generated enum and error types conform to <code>CaseIterable</code>. <code>generate_codable_conformance</code> <code>false</code> Whether to make generated record, enum and error types conform to <code>Codable</code>. <code>omit_checksums</code> <code>false</code> Whether to omit checking the library checksums as the library is initialized. Changing this will shoot yourself in the foot if you mixup your build pipeline in any way, but might speed up initialization. <code>link_frameworks</code> <code>[]</code> The extra frameworks to link this binary against, such as <code>CoreBluetooth</code> or <code>CoreAudio</code>. Usually only used for interacting with native platform libraries. <p>[^1]: <code>namespace</code> is the top-level namespace from your UDL file.</p>"},{"location":"swift/configuration.html#example","title":"Example","text":"<pre><code>[bindings.swift]\ncdylib_name = \"mycrate_ffi\"\nomit_argument_labels = true\n</code></pre>"},{"location":"swift/module.html","title":"Compiling a Swift module","text":"<p>Before you can import the generated Swift bindings as a module (say, to use them from your application, or to try them out using <code>swift</code> on the command-line) you first need to compile them into a Swift module.</p> <p>To do so, you'll need both the generated <code>.swift</code> file and the corresponding <code>.modulemap</code> file, which tells Swift how to expose the underlying C FFI layer. Use <code>swiftc</code> to combine the cdylib from your Rust crate with the generated Swift bindings:</p> <pre><code>swiftc\n    -module-name example                         # Name for resulting Swift module\n    -emit-library -o libexample.dylib            # File to link with if using Swift REPL\n    -emit-module -emit-module-path ./            # Output directory for resulting module\n    -parse-as-library\n    -L ./target/debug/                           # Directory containing compiled Rust crate\n    -lexample                                    # Name of compiled Rust crate cdylib\n    -Xcc -fmodule-map-file=exampleFFI.modulemap  # The modulemap file from above\n    example.swift                                # The generated bindings file\n</code></pre> <p>This will produce an <code>example.swiftmodule</code> file that can be loaded by other Swift code or used from the Swift command-line REPL.</p> <p>If you are creating an XCFramework with this code, make sure to rename the modulemap file to <code>module.modulemap</code>, the default value expected by Clang and XCFrameworks for exposing the C FFI library to Swift.</p>"},{"location":"swift/overview.html","title":"Swift Bindings","text":"<p>UniFFI ships with production-quality support for generating Swift bindings. Concepts from the UDL file map into Swift as follows:</p> <ul> <li>Primitive datatypes map to their obvious Swift counterpart, e.g. <code>u32</code> becomes <code>UInt32</code>,   <code>string</code> becomes <code>String</code>, <code>bytes</code> becomes <code>Data</code>, etc.</li> <li>An object interface declared as <code>interface T</code> is represented as a Swift <code>protocol TProtocol</code>   and a concrete Swift <code>class T</code> that conforms to it. Having the protocol declared explicitly   can be useful for mocking instances of the class in unittests.</li> <li>A dictionary struct declared as <code>dictionary T</code> is represented as a Swift <code>struct T</code>   with public mutable fields.</li> <li>An enum declared <code>enum T</code> or <code>[Enum] interface T</code> is represented as a Swift   <code>enum T</code> with appropriate variants.</li> <li>Optional types are represented using Swift's builtin optional type syntax <code>T?</code>.</li> <li>Sequences are represented as Swift arrays, and Maps as Swift dictionaries.</li> <li>Errors are represented as Swift enums that conform to the <code>Error</code> protocol.</li> <li>Function calls that have an associated error type are marked with <code>throws</code>,   and hence must be called using one of Swift's <code>try</code> syntax variants.</li> <li>Failing assertions, Rust panics, and other unexpected errors in the generated code   are translated into a private enum conforming to the <code>Error</code> protocol.<ul> <li>If this happens inside a throwing Swift function, it can be caught and handled   by a catch-all <code>catch</code> statement (but do so at your own risk, because it indicates   that something has gone seriously wrong).</li> <li>If this happens inside a non-throwing Swift function, it will be converted   into a fatal Swift error that cannot be caught.</li> </ul> </li> </ul>"},{"location":"swift/overview.html#generated-files","title":"Generated files","text":"<p>UniFFI generates several kinds of files for Swift bindings:</p> <ul> <li>C header files declaring the FFI structs/functions used by the Rust scaffolding code</li> <li>A modulemap, which defines a Swift module for the C FFI definitions in the header file.</li> <li>A Swift source file that defines the Swift API used by consumers.  This imports the FFI module.</li> </ul>"},{"location":"swift/overview.html#swift-6-support","title":"Swift 6 Support","text":"<p>UniFFI has partial support for Swift 6. We would welcome all help improving this.</p>"},{"location":"swift/overview.html#sendable","title":"Sendable","text":"<p>Most generated code will conform to <code>Sendable</code>. Depending on your Swift compiler options, you may find rough edges where this support doesn't quite exist. At time of writing, it is known that async code will not conform. This is being tracked in #2448</p> <p>Note that <code>Sendable</code> conformance does impose obligations on code you write - for example, when you implement a Foreign Trait, the \"protocol\" generated by UniFFI will require Sendable conformance, therefore your implementation of that protocol must too. See the Swift documentation for more.</p>"},{"location":"swift/uniffi-bindgen-swift.html","title":"uniffi-bindgen-swift","text":"<p>Swift bindings can be generated like other languages using <code>uniffi-bindgen -l swift</code>.  However, you can also use the <code>uniffi-bindgen-swift</code> binary which gives greater control over Swift-specific features:</p> <ul> <li>Select which kind of files to generate: headers, modulemaps, and/or Swift sources.</li> <li>Generate a single modulemap for a library.</li> <li>Generate XCFramework-compatible modulemaps.</li> <li>Customize the modulemap module name.</li> <li>Customize the modulemap filename.</li> </ul> <p><code>uniffi-bindgen-swift</code> can be added to your project using the same general steps as <code>uniffi-bindgen</code>. See https://mozilla.github.io/uniffi-rs/latest/tutorial/foreign_language_bindings.html#creating-the-bindgen-binary. The Rust source for the binary should be:</p> <pre><code>fn main() {\n    uniffi::uniffi_bindgen_swift()\n}\n</code></pre> <p><code>uniffi-bindgen-swift</code> always inputs a library path and runs in \"library mode\".  This means proc-macro-based bindings generation is always supported.</p>"},{"location":"swift/uniffi-bindgen-swift.html#examples","title":"Examples:","text":"<p>Generate .swift source files for a library <pre><code>cargo run -p uniffi-bindgen-swift -- target/release/mylibrary.a build/swift --swift-sources\n</code></pre></p> <p>Generate .h files for a library <pre><code>cargo run -p uniffi-bindgen-swift -- target/release/mylibrary.a build/swift/Headers --headers\n</code></pre></p> <p>Generate a modulemap <pre><code>cargo run -p uniffi-bindgen-swift -- target/release/mylibrary.a build/swift/Modules --modulemap --modulemap-filename mymodule.modulemap\n</code></pre></p> <p>Generate a Xcframework-compatible modulemap <pre><code>cargo run -p uniffi-bindgen-swift -- target/release/mylibrary.a build/swift/Modules --xcframework --modulemap --modulemap-filename mymodule.modulemap\n</code></pre></p>"},{"location":"swift/xcode.html","title":"Integrating with Xcode","text":"<p>It is possible to generate Swift bindings at compile time for Xcode projects and incorporate them alongside hand-written Swift code to form a larger module. Broadly, you will need to:</p> <ol> <li>Add a build phase to compile the Rust crate into a static lib and link it    into your framework.</li> <li>Add a build phase to run <code>uniffi-bindgen</code> and generate the Swift bindings.</li> <li>Include the generated bridging header into your overall bridging header.</li> </ol> <p>There is also an example app in the UniFFI project repo that may be helpful.</p>"},{"location":"swift/xcode.html#compiling-the-rust-crate","title":"Compiling the Rust crate.","text":"<p>Sorry, configuring Xcode to compile the Rust crate into a staticlib is beyond the scope of this document. However you do so, make sure you include the resulting <code>libexample.a</code> file in the \"Link Binary with Libraries\" build phase for your framework.</p> <p>This repository contains an example iOS app (at <code>./examples/app/ios</code>) which may be useful for reference. It contains an <code>xc-universal-binary.sh</code> shell script which can invoke <code>cargo</code> with the necessary settings to produce a static library of Rust code.</p>"},{"location":"swift/xcode.html#generating-the-bindings","title":"Generating the bindings","text":"<p>In the \"Build Rules\" section of your config, add a rule to process <code>.udl</code> files using <code>uniffi-bindgen</code>. We recommend having it generate the output files somewhere in your source tree, rather than in Xcode's default <code>$DERIVED_FILE_DIR</code>; this both helps with debugging the build output, and makes it easier to configure how the generated files are used.</p> <ul> <li>Add a build rule processing files with names matching <code>*.udl</code>.<ul> <li>Use something like the following as the custom script:<ul> <li><code>$HOME/.cargo/bin/uniffi-bindgen generate $INPUT_FILE_PATH --language swift --out-dir $INPUT_FILE_DIR/Generated</code></li> </ul> </li> <li>Add both the <code>.swift</code> file and the generated bridging header as output files:<ul> <li><code>$(INPUT_FILE_DIR)/Generated/$(INPUT_FILE_BASE).swift</code></li> <li><code>$(INPUT_FILE_DIR)/Generated/$(INPUT_FILE_BASE)FFI.h</code></li> </ul> </li> </ul> </li> <li>Add your <code>.udl</code> file to the \"Compile Sources\" build phase for your framework,   so that Xcode will process it using the new build rule and will include the resulting   outputs in the build.</li> </ul> <p>You do not need to add the generated Swift code to the list of \"Compile Sources\" and should not attempt to compile it explicitly; Xcode will figure out what it needs to do with this code based on it being generated from the Build Rule for your .udl file.</p>"},{"location":"swift/xcode.html#including-the-bridging-header","title":"Including the bridging header","text":"<p>In the overall bridging header for your module, include the header file generated by UniFFI in the previous step:</p> <pre><code>#include \"exampleFFI.h\"\n</code></pre> <p>For this to work without complaint from Xcode, you also need to add the generated header file as a Public header in the \"Headers\" build phase of your project (which is why it's useful to generate this file somewhere in your source tree, rather than in a temporary build directory).</p>"},{"location":"tutorial/Prerequisites.html","title":"Prerequisites","text":"<p>This tutorial builds on our <code>arithmetic</code> and (creatively-named) <code>arithmetic-procmacro</code> examples, which will be useful when we've omitted things.</p> <p>Here we will be creating a <code>math</code> library - so we assume a <code>cargo new --lib math</code> environment.</p>"},{"location":"tutorial/Prerequisites.html#add-uniffi-as-a-dependency-and-build-dependency","title":"Add <code>uniffi</code> as a dependency and build-dependency","text":"<p>In your crate's <code>Cargo.toml</code> add:</p> <pre><code>[dependencies]\nuniffi = { version = \"[latest-version]\", features = [ \"cli\" ] }\n\n[build-dependencies]\nuniffi = { version = \"[latest-version]\", features = [ \"build\" ] }\n</code></pre> <p>UniFFI has not reached version <code>1.0</code> yet.  Versions are typically specified as <code>0.[minor-version]</code>.</p>"},{"location":"tutorial/Prerequisites.html#build-your-crate-as-a-cdylib","title":"Build your crate as a cdylib","text":"<p>Ensure your crate builds as a <code>cdylib</code> so looks something like <pre><code>[lib]\ncrate-type = [\"cdylib\"]\nname = \"math\" # This is our crate name in this tutorial\n</code></pre> to your crate's <code>Cargo.toml</code>.</p> <p>Note: You also need to add <code>staticlib</code> crate type if you target iOS.</p>"},{"location":"tutorial/Rust_scaffolding.html","title":"Rust scaffolding","text":"<p>UniFFI requires that our generated Rust \"scaffolding\" code is included in your project. For proc macros, most of this is conveniently generated by the macros.</p> <p>If you use UDL files, you need to generate this \"scaffolding\" then include the generated .rs in your project.</p>"},{"location":"tutorial/Rust_scaffolding.html#rust-scaffolding-code-for-udl","title":"Rust scaffolding code for UDL","text":"<p>Crates using UDL need a <code>build.rs</code> file next to <code>Cargo.toml</code>. This uses <code>uniffi</code> to generate the Rust scaffolding code.</p> <pre><code>fn main() {\n    uniffi::generate_scaffolding(\"src/math.udl\").unwrap();\n}\n</code></pre> <p>It will generate <code>&lt;namespace&gt;.uniffi.rs</code> under your <code>target</code> directory.</p> <p>Lastly, we include the generated scaffolding code in our <code>lib.rs</code> using this handy macro:</p> <pre><code>uniffi::include_scaffolding!(\"math\");\n</code></pre>"},{"location":"tutorial/Rust_scaffolding.html#setup-for-crates-using-only-proc-macros","title":"Setup for crates using only proc macros","text":"<p>If you are only using proc macros, you can skip <code>build.rs</code> entirely! All you need to do is add this to the top of <code>lib.rs</code></p> <pre><code>uniffi::setup_scaffolding!();\n</code></pre> <p>Don't use <code>uniffi::setup_scaffolding!()</code> in a crate which uses <code>uniffi::include_scaffolding!()</code>.</p> <p>If you don't specify a <code>namespace</code> the crate name is used.</p>"},{"location":"tutorial/Rust_scaffolding.html#libraries-that-depend-on-uniffi-components","title":"Libraries that depend on UniFFI components","text":"<p>Suppose you want to create a shared library that includes one or more components using UniFFI. The typical way to achieve this is to create a new crate that depends on the component crates.  However, this can run into issues where public symbols from the dependent crates aren't re-exported, resulting in these symbols not being available at runtime.</p> <p>If you encounter this, you can use the <code>uniffi_reexport_scaffolding!()</code> macro as a work around. For example, <code>foo_component::uniffi_reexport_scaffolding!();</code> in your library's <code>lib.rs</code> will have UniFFI generate workaround code that forces <code>foo_component</code>s functions to be exported from the library.</p> <p>Each scaffolding function contains a hash that's derived from the namespace. This avoids name collisions when combining multiple UniFFI components into one library.</p>"},{"location":"tutorial/foreign_language_bindings.html","title":"Foreign-language bindings","text":"<p>By now you have setup your crate and <code>cargo build</code> has successfully created your library.</p> <p>The next step is to have UniFFI generate source code for your foreign language. It doesn't help you build this code, it just generates it for you.</p>"},{"location":"tutorial/foreign_language_bindings.html#creating-the-bindgen-binary","title":"Creating the bindgen binary","text":"<p>First, make sure you have installed all the prerequisites.</p> <p>Ideally you would then run the <code>uniffi-bindgen</code> binary from the <code>uniffi</code> crate to generate your bindings, but if not on Cargo nightly, you need to create a binary in your project that does the same thing.</p> <p>Add the following to your <code>Cargo.toml</code>:</p> <pre><code>[[bin]]\n# This can be whatever name makes sense for your project, but the rest of this tutorial assumes uniffi-bindgen.\nname = \"uniffi-bindgen\"\npath = \"uniffi-bindgen.rs\"\n</code></pre> <p>Create <code>uniffi-bindgen.rs</code>: <pre><code>fn main() {\n    uniffi::uniffi_bindgen_main()\n}\n</code></pre></p> <p>You can now run <code>uniffi-bindgen</code> from your project using <code>cargo run --features=uniffi/cli --bin uniffi-bindgen [args]</code></p>"},{"location":"tutorial/foreign_language_bindings.html#multi-crate-workspaces","title":"Multi-crate workspaces","text":"<p>In a multiple crates workspace, you can create a separate crate for running <code>uniffi-bindgen</code>:</p> <ul> <li>Name the crate <code>uniffi-bindgen</code>, add it to your workspace.</li> <li>Add this dependency to <code>Cargo.toml</code>: <code>uniffi = {version = \"0.XX.0\", features = [\"cli\"] }</code></li> <li>As above, add the <code>uniffi-bindgen</code> binary target</li> </ul> <p>Then your can run <code>uniffi-bindgen</code> from any crate in your project using <code>cargo run -p uniffi-bindgen [args]</code></p>"},{"location":"tutorial/foreign_language_bindings.html#running-uniffi-bindgen-using-a-library-file","title":"Running uniffi-bindgen using a library file","text":"<p>Use <code>generate --library</code> to generate foreign bindings by using a cdylib file built for your library. This can be more convenient than specifying the UDL file -- especially when multiple UniFFI-ed crates are built together in one library. This should be used where possible - some \"external type\" features don't work otherwise.</p> <p>In our example, we generate the bindings with: <pre><code>cargo build --release\ncargo run --bin uniffi-bindgen generate --library target/release/libmath.so --language kotlin --out-dir out\n</code></pre> (maybe <code>.dylib</code>, good luck with <code>.dll</code>!)</p> <p>Then look in the <code>out</code> directory.</p> <p>When using library mode, if multiple crates get built into the library that use UniFFI, all will have bindings generated for them.</p> <p>Library mode comes with some extra requirements:</p> <ul> <li>It must be run from within the cargo workspace of your project</li> <li>Each crate must use exactly 1 UDL file when compiling the Rust library.  However, crates can have     multiple UDL files as long as they ensure only one is used for any particular build,     e.g. by using feature flags.</li> <li>Rust sources must use <code>uniffi::include_scaffolding!</code> to include the scaffolding code.</li> </ul>"},{"location":"tutorial/foreign_language_bindings.html#running-uniffi-bindgen-with-a-single-udl-file","title":"Running uniffi-bindgen with a single UDL file","text":"<p>As noted above, library mode is encouraged - building from a single UDL is not recommended.</p> <p>Use the <code>generate</code> command to generate bindings by specifying a UDL file.</p>"},{"location":"tutorial/foreign_language_bindings.html#kotlin","title":"Kotlin","text":"<p>From the example directory, run: <pre><code>cargo run --bin uniffi-bindgen generate src/math.udl --language kotlin\n</code></pre> then have a look at <code>src/uniffi/math/math.kt</code></p>"},{"location":"tutorial/foreign_language_bindings.html#swift","title":"Swift","text":"<p>Run <pre><code>cargo run --bin uniffi-bindgen generate src/math.udl --language swift\n</code></pre> then check out <code>src/math.swift</code></p> <p>Note that these commands could be integrated as part of your gradle/Xcode build process.</p> <p>This is it, you have an MVP integration of UniFFI in your project.</p>"},{"location":"tutorial/udl_file.html","title":"Describing the interface","text":"<p>There are two ways of describing your interface:</p>"},{"location":"tutorial/udl_file.html#proc-macros","title":"Proc macros","text":"<p>Rust proc macros can describe your interface - you'd define the function as:</p> <pre><code>#[uniffi::export]\nfn add(a: u32, b: u32) -&gt; u32 { a + b }\n</code></pre> <p>You need to set up the scaffolding with <code>uniffi::setup_scaffolding!()</code> - but that's it.</p>"},{"location":"tutorial/udl_file.html#a-udl-file","title":"A UDL File","text":"<p>We describe in a UDL (a type of IDL, Interface Definition Language) file what is exposed and available to foreign-language bindings. In this case, we are only playing with primitive types (<code>u32</code>) and not custom data structures but we still want to expose the <code>add</code> method.</p> <p>Let's create a <code>math.udl</code> file in the <code>math</code> crate's <code>src/</code> folder:</p> <pre><code>namespace math {\n  u32 add(u32 a, u32 b);\n};\n</code></pre> <p>Here you can note multiple things:</p> <ul> <li>The <code>namespace</code> directive: it will be the name of your Kotlin/Swift package. It must be present in any udl file, even if there aren't any exposed functions (e.g. <code>namespace foo {}</code>). It will typically be your crate name.</li> <li>The <code>add</code> function is in the <code>namespace</code> block. That's because on the Rust side it is a top-level function, we will see later how to to handle methods.</li> <li>Rust's <code>u32</code> is also UDL's <code>u32</code>, but it is not always true! See the Built-in Types chapter for more information on mapping types between Rust and UDL.</li> </ul> <p>Note: If any of the things you expose in the <code>udl</code> file do not have an equivalent in your Rust crate, you will get a hard error. Try changing the <code>u32</code> result type to <code>u64</code> and see what happens!</p>"},{"location":"types/builtin_types.html","title":"Built-in types","text":"<p>The following built-in types can be used by UniFFI. Ths table shows the types supported in Rust, and the types used in UDL.</p> Rust type UDL type Notes <code>bool</code> <code>boolean</code> <code>u8/i8..u64/i64</code> <code>u8/i8..u64/i64</code> <code>f32</code> <code>float</code> <code>f64</code> <code>double</code> <code>String</code> <code>string</code> <code>Vec&lt;u8&gt;</code> <code>bytes</code> Different from <code>sequence&lt;u8&gt;</code> only in foreign type mappings <code>SystemTime</code> <code>timestamp</code> Precision may be lost when converting to Python and Swift types <code>Duration</code> <code>duration</code> Precision may be lost when converting to Python and Swift types <code>&amp;T</code> <code>[ByRef] T</code> This works for <code>&amp;str</code> and <code>&amp;[T]</code> <code>Option&lt;T&gt;</code> <code>T?</code> <code>Vec&lt;T&gt;</code> <code>sequence&lt;T&gt;</code> <code>HashMap&lt;K, V&gt;</code> <code>record&lt;K, T&gt;</code> <code>()</code> <code>void</code> Empty return <code>Result&lt;T, E&gt;</code> N/A See Errors section <p>And of course you can use your own types, which is covered in the following sections.</p>"},{"location":"types/callback_interfaces.html","title":"Callback interfaces","text":"<p>Callback interfaces are a special implementation of Rust traits implemented by foreign languages.</p> <p>These are described in both UDL and proc-macros as an explicit \"callback interface\". They are (soft) deprecated, remain now for backwards compatibility, but foreign traits should be preferred.</p> <p>This document describes the differences from regular traits.</p>"},{"location":"types/callback_interfaces.html#defining-a-callback","title":"Defining a callback","text":"<p>If you must define a callback in UDL it would look like: <pre><code>callback interface Keychain {\n  // as described in the foreign traits docs...\n};\n</code></pre></p> <p>procmacros support it too, but just don't use it :)</p>"},{"location":"types/callback_interfaces.html#box-and-send-sync","title":"Box and Send + Sync?","text":"<p>Traits defined purely for callbacks probably don't technically need to be <code>Sync</code> in Rust, but they conceptually are, just outside of Rust's view.</p> <p>That is, the methods of the foreign class must be safe to call from multiple threads at once, but Rust can not enforce this in the foreign code.</p>"},{"location":"types/callback_interfaces.html#rust-signature-differences","title":"Rust signature differences","text":"<p>Consider the examples in Rust traits implemented by foreign languages.</p> <p>If the traits in question are defined as a \"callback\" interface, the <code>Arc&lt;dyn Keychain&gt;</code> types would actually be <code>Box&lt;dyn Keychain&gt;</code> - eg, the Rust implementation of the <code>Authenticator</code> constructor would be <code>fn new(keychain: Box&lt;dyn Keychain&gt;) -&gt; Self</code> instead of the <code>Arc&lt;&gt;</code>.</p>"},{"location":"types/custom_types.html","title":"Custom types","text":"<p>Custom types allow you to create a new UniFFI type which is passed over the FFI as another \"bridge\" type. For example, you might have a type named <code>Url</code> which has a bridge type <code>String</code>, or a <code>Handle</code> bridged by an <code>i64</code>.</p> <p>Any valid type can be a bridge type - not only builtins, but structs, records, enums etc.</p> <p>This not only allows using types which otherwise would be impossible over the FFI (eg, <code>url::Url</code>), but other interesting \"newtype\" options to extend the type system.</p> <p>The foreign bindings will treat these types as the bridge type - but they may optionally transform the type. For example, our <code>Url</code> has a bridged type of <code>string</code> - we could choose for Kotlin to either get that as a <code>String</code>, or supply a conversion to/from a Kotlin <code>java.net.URL</code>.</p> <p>This would mean that <code>Url</code> would be: * Represented by the <code>url::Url</code> type in Rust * Passed across the FFI as a string * Represented by the <code>java.net.URL</code> type in Kotlin</p> <p>For terminology, we lean on our existing lifting and lowering; in the same way an FFI type is \"lifted\" into the Rust type, and a Rust type is \"lowered\" into to FFI, here the bridge type is lifted into our custom type, and our custom type is lowered into the bridge type.</p> <p>This creates a 2-step lifting/lowering process: our custom type is lifted/lowered to/from the bridge type, then that bridge type lifted/lowered to/from the actual FFI type.</p> <p>By default, we assume some <code>Into/From</code> relationships between the types, but you can also supply conversion closures.</p>"},{"location":"types/custom_types.html#custom-types-in-the-scaffolding-code","title":"Custom types in the scaffolding code","text":""},{"location":"types/custom_types.html#custom_type","title":"<code>custom_type!</code>","text":"<p>Use the <code>custom_type!</code> macro to define a new custom type.</p> <p>The simplest case is for a type with <code>Into/From</code> already setup - eg, our <code>Handle</code></p> <p><pre><code>/// handle which wraps an integer\npub struct Handle(i64);\n\n// Defining `From&lt;Handle&gt; for i64` also gives us `Into&lt;i64&gt; for Handle`\nimpl From&lt;Handle&gt; for i64 {\n    fn from(val: Handle) -&gt; Self {\n        val.0\n    }\n}\n\nuniffi::custom_type!(Handle, i64);\n</code></pre> and <code>Handle</code> can be used in Rust, while foreign bindings will use <code>i64</code> (or optionally converted, see below)</p>"},{"location":"types/custom_types.html#custom_type-conversions","title":"<code>custom_type!</code> conversions","text":"<p>You can also manually specify the conversions by passing extra params to the macro. Use this when the trait implementations do not exist, or they aren't desirable for some reason.</p> <pre><code>uniffi::custom_type!(SerializableStruct, String, {\n    // Lowering our Rust SerializableStruct into a String.\n    lower: |s| s.serialize(),\n    // Lifting our foreign String into our Rust SerializableStruct\n    try_lift: |s| s.deserialize(),\n});\n</code></pre> <p>If you do not supply conversions to and from the bridge type, and assuming <code>SerializableStruct</code> and <code>String</code>, the following is used:</p> <ul> <li>Values lowered to the foreign code will be converted using <code>Into&lt;String&gt;</code> then lowered as a <code>String</code> value.</li> <li>Values lifted to the Rust code (eg, a <code>String</code>) is then converted using <code>&lt;String as TryInto&lt;SerializableStruct&gt;&gt;</code>; the <code>TryInto::Error</code> type can be anything that implements <code>Into&lt;anyhow::Error&gt;</code>.</li> <li><code>TryFrom&lt;String&gt;</code> and <code>From&lt;SerializableStruct&gt;</code> will also work, using the blanket impl from the core library.</li> </ul>"},{"location":"types/custom_types.html#custom_newtype","title":"<code>custom_newtype!</code>","text":"<p>The <code>custom_newtype!</code> macro is able to handle Rust newtype-style structs which wrap a UniFFI type.</p> <p>eg, our <code>Handle</code> object above could be declared as: <pre><code>/// Handle which wraps an integer\npub struct Handle(i64);\n\n/// `Handle` objects will be passed across the FFI the same way `i64` values are.\nuniffi::custom_newtype!(Handle, i64);\n</code></pre></p>"},{"location":"types/custom_types.html#udl","title":"UDL","text":"<p>Define custom types in UDL via a <code>typedef</code> with a <code>Custom</code> attribute, specifying the UniFFI type followed by the custom type.</p> <pre><code>[Custom]\ntypedef i64 Handle;\n</code></pre> <p>You can specify the crate name if the custom type implementation is external.</p> <pre><code>[Custom=\"crate_defining_handle_name\"]\ntypedef i64 Handle;\n\n[Custom=\"crate_defining_log_record_name\"]\ntypedef dictionary LogRecord;\n</code></pre> <p>note: you must still call the <code>custom_type!</code> or <code>custom_newtype!</code> macros in your Rust code, as described above.</p>"},{"location":"types/custom_types.html#user-defined-types","title":"User-defined types","text":"<p>All examples so far in this section convert the custom type to a builtin type. It's also possible to convert them to a user-defined type (Record, Enum, Interface, etc.). For example you might want to convert <code>log::Record</code> class into a UniFFI record:</p> <pre><code>pub type LogRecord = log::Record;\n\n#[derive(uniffi::Record)]\npub type LogRecordData {\n    level: LogLevel,\n    message: String,\n}\n\nuniffi::custom_type!(LogRecord, LogRecordData, {\n    lower: |r| LogRecordData {\n        level: r.level(),\n        message: r.to_string(),\n    }\n    try_lift: |r| Ok(LogRecord::builder()\n        .level(r.level)\n        .args(format_args!(\"{}\", r.message))\n        .build())\n});\n</code></pre>"},{"location":"types/custom_types.html#error-handling-during-conversion","title":"Error handling during conversion","text":"<p>You might have noticed that the <code>try_lift</code> function returns a <code>uniffi::Result&lt;Self&gt;</code> (which is an alias for <code>anyhow::Result</code>) and might be wondering what happens if you return an <code>Err</code>.</p> <p>It depends on the context. In short:</p> <ul> <li> <p>If the value is being used as an argument to a function/constructor that does not return   a <code>Result</code> (ie, does not have the <code>throws</code> attribute in the .udl), then the generated   code will fail at runtime with a Rust <code>panic!()</code> or the foreign language equivalent.</p> </li> <li> <p>If the value is being used as an argument to a function/constructor that does return a   <code>Result</code> (ie, does have a <code>throws</code> attribute in the .udl), then the uniffi generated   scaffolding code will use <code>anyhow::Error::downcast()</code> to try and convert the failure into   that declared error type and:</p> </li> <li>If that conversion succeeds, it will be used as the <code>Err</code> for the function.</li> <li>If that conversion fails, the code will fail at runtime.</li> </ul>"},{"location":"types/custom_types.html#example","title":"Example","text":"<p>For example, consider the following UDL: <pre><code>[Custom]\ntypedef i64 Handle;\n\n[Error]\nenum ExampleError {\n    \"InvalidHandle\"\n};\n\nnamespace errors_example {\n    take_handle_1(Handle handle);\n\n    [Throws=ExampleError]\n    take_handle_2(Handle handle);\n}\n</code></pre></p> <p>and the following Rust: <pre><code>#[derive(Debug, thiserror::Error)]\npub enum ExampleError {\n    #[error(\"The handle is invalid\")]\n    InvalidHandle,\n}\n\nuniffi::custom_type!(ExampleHandle, Builtin, {\n    lower: |handle| handle.0,\n    try_lift: |value| match value {\n        0 =&gt; Err(ExampleErrors::InvalidHandle.into()),\n        -1 =&gt; Err(SomeOtherError.into()), // SomeOtherError decl. not shown.\n        n =&gt; Ok(Handle(n)),\n    }\n})\n</code></pre></p> <p>The behavior of the generated scaffolding will be:</p> <ul> <li>Calling <code>take_handle_1</code> with a value of <code>0</code> or <code>-1</code> will always cause a runtime failure.</li> <li>Calling <code>take_handle_2</code> with a value of <code>0</code> will throw an <code>ExampleError</code> exception</li> <li>Calling <code>take_handle_2</code> with a value of <code>-1</code> will always cause a runtime failure.</li> <li>All other values will return <code>Ok(ExampleHandle)</code></li> </ul>"},{"location":"types/custom_types.html#custom-types-in-the-bindings-code","title":"Custom types in the bindings code","text":"<p>Note: The facility described in this document is not yet available for the Ruby bindings.</p> <p>By default, the foreign bindings just see the builtin type - eg, the bindings will get an integer for the <code>Handle</code>.</p> <p>However, custom types can also be converted on the bindings side.  For example, a Url type could be configured to use the <code>java.net.URL</code> class in Kotlin by adding code like this to <code>uniffi.toml</code>:</p> <pre><code>[bindings.kotlin.custom_types.Url]\n# Name of the type in the Kotlin code\ntype_name = \"URL\"\n# Classes that need to be imported\nimports = [ \"java.net.URL\" ]\n# Expression to convert the builtin type the custom type.  In this example, `{}` will be replaced with the int value.\nlift = \"URL({})\"\n# Expression to convert the custom type to the builtin type.  In this example, `{}` will be replaced with the URL value.\nlower = \"{}.toString()\"\n</code></pre> <p>Here's how the configuration works in <code>uniffi.toml</code>.</p> <ul> <li>Create a <code>[bindings.{language}.custom_types.{CustomTypeName}]</code> table to enable a custom type on a bindings side.  This has several subkeys:</li> <li><code>type_name</code> (Optional, Typed languages only): Type/class name for the     custom type.  Defaults to the type name used in the UDL.  Note: The UDL     type name will still be used in generated function signatures, however it     will be defined as a typealias to this type.</li> <li><code>lift</code>: Expression to convert the UDL type to the custom type.  <code>{}</code> will be replaced with the value of the UDL type.</li> <li><code>lower</code>: Expression to convert the custom type to the UDL type.  <code>{}</code> will be replaced with the value of the custom type.</li> <li><code>imports</code> (Optional) list of modules to import for your <code>lift</code>/<code>lower</code> functions.</li> </ul>"},{"location":"types/enumerations.html","title":"Enumerations","text":"<p>Enums must be exposed via UDL or proc-macros</p> <p>Simple enums just work:</p> <pre><code>enum Animal {\n    Dog,\n    Cat,\n}\n</code></pre> <p>and naturally used in the bindings: <pre><code>Animal.Dog // kotlin\n</code></pre> <pre><code>.dog // swift\n</code></pre> <pre><code>Animal.DOG() # python\na.is_DOG()\n</code></pre></p>"},{"location":"types/enumerations.html#enums-with-fields","title":"Enums with fields","text":"<p>Enumerations with associated data are supported.</p> <pre><code>enum IpAddr {\n  V4 {q1: u8, q2: u8, q3: u8, q4: u8},\n  V6 {addr: string},\n}\n</code></pre> <p>Enums can be very flexible (although UDL doesn't support all of this)</p> <pre><code>#[derive(uniffi::Enum)]\npub enum MyEnum {\n    None,\n    Str(String),\n    All { s: String, i: i64 }\n}\n</code></pre>"},{"location":"types/enumerations.html#remote-non-exhaustive-enums","title":"Remote, non-exhaustive enums","text":"<p>There are some special considerations here when using UDL</p>"},{"location":"types/errors.html","title":"Throwing errors","text":"<p>It is often the case that a function does not return <code>T</code> in Rust but <code>Result&lt;T, E&gt;</code> to reflect that it is fallible. For UniFFI to expose this error, your error type (<code>E</code>) must be an <code>enum</code> and implement <code>std::error::Error</code> (thiserror works!).</p> <p>Errors must be exposed via UDL or proc-macros</p> <p>Here's how you would write a Rust failible function:</p> <pre><code>#[derive(Debug, thiserror::Error)]\nenum ArithmeticError {\n    #[error(\"Integer overflow on an operation with {a} and {b}\")]\n    IntegerOverflow { a: u64, b: u64 },\n}\n\nfn add(a: u64, b: u64) -&gt; Result&lt;u64, ArithmeticError&gt; {\n    a.checked_add(b).ok_or(ArithmeticError::IntegerOverflow { a, b })\n}\n</code></pre> <p>On the other side (Kotlin, Swift etc.), a proper exception will be thrown if <code>Result::is_err()</code> is <code>true</code>.</p>"},{"location":"types/errors.html#interfaces-as-errors","title":"Interfaces as errors","text":"<p>It's possible to use an <code>interface</code> (ie, a rust struct impl or a <code>dyn Trait</code>) as an error; the thrown object will have methods instead of fields. This can be particularly useful when working with <code>anyhow</code> style errors, where an enum can't easily represent certain errors.</p> <pre><code>#[derive(Debug, thiserror::Error)]\n#[error(\"{e:?}\")] // default message is from anyhow.\npub struct MyError {\n    e: anyhow::Error,\n}\n\nimpl MyError {\n    fn message(&amp;self) -&gt; String { self.to_string() }\n}\n\nimpl From&lt;anyhow::Error&gt; for MyError {\n    fn from(e: anyhow::Error) -&gt; Self {\n        Self { e }\n    }\n}\n</code></pre> <p>You can't yet use <code>anyhow</code> directly in your exposed functions - you need a wrapper:</p> <p><pre><code>fn oops() -&gt; Result&lt;(), MyError&gt; {\n    let e = anyhow::Error::msg(\"oops\");\n    Err(e.into())\n}\n</code></pre> then in Python: <pre><code>try:\n  oops()\nexcept MyError as e:\n  print(\"oops\", e.message())\n</code></pre></p> <p>This works for procmacros too - just derive or export the types. <pre><code>#[derive(Debug, uniffi::Object)]\npub struct MyError { ... }\n#[uniffi::export]\nimpl MyError { ... }\n#[uniffi::export]\nfn oops(e: String) -&gt; Result&lt;(), Arc&lt;MyError&gt;&gt; { ... }\n</code></pre></p> <p>See our tests this feature.</p>"},{"location":"types/functions.html","title":"Functions","text":"<p>Functions are exposed in a namespace, either via UDL or proc-macros</p> <pre><code>#[uniffi::export] // if using proc-macros\nfn hello_world() -&gt; String {\n    \"Hello World!\".to_owned()\n}\n</code></pre> <p>Note that everything described here applies to all \"callables\" - eg, interface methods, constructors etc.</p>"},{"location":"types/functions.html#optional-arguments-default-values","title":"Optional arguments &amp; default values","text":"<p>You can specify a default value for function arguments (in UDL and proc-macros)</p> <p>The Rust code will still take a required argument:</p> <pre><code>fn hello_name(name: String) -&gt; String {\n    format!(\"Hello {}\", name)\n}\n</code></pre> <p>The generated foreign-language bindings will use function parameters with default values.</p> <p>If the default argument value is <code>\"world\"</code>, the generated Kotlin code will be equivalent to:</p> <pre><code>fun helloName(name: String = \"world\" ): String {\n    // ...\n}\n</code></pre>"},{"location":"types/functions.html#async","title":"Async","text":"<p>Async functions \"just work\" with proc-macros, while UDL can use the <code>[Async]</code> attribute:</p> <p>See the Async/Future support section for details.</p>"},{"location":"types/interfaces.html","title":"Interfaces, Objects and Traits","text":"<p>Interfaces can have constructors and have methods. In Rust, they are represented as <code>impl</code> blocks. In the Kotlin or Swift world, they are a class, so they are often known as \"Objects\"</p> <p>Interfaces are passed by reference so can not have data items - unlike a Record or Enum, which are passed by value so only have data fields and no methods.</p> <p>Interfaces must be exposed via UDL or proc-macros</p> <pre><code>struct TodoList {\n    items: RwLock&lt;Vec&lt;String&gt;&gt;\n}\n\nimpl TodoList {\n    fn new() -&gt; Self {\n        TodoList {\n            items: RwLock::new(Vec::new())\n        }\n    }\n\n    fn add_item(&amp;self, todo: String) {\n        self.items.write().unwrap().push(todo);\n    }\n\n    fn get_items(&amp;self) -&gt; Vec&lt;String&gt; {\n        self.items.read().unwrap().clone()\n    }\n}\n</code></pre> <p>These <code>interface</code> objects are live Rust structs behind an <code>Arc&lt;&gt;</code> that have a proxy object on the foreign language side; calling any methods on them, including a constructor results in the corresponding methods being called in Rust.</p> <p>UniFFI will generate these proxies with an interface or protocol to help with testing in the foreign-language code. For example in Kotlin, the <code>TodoList</code> would generate:</p> <pre><code>interface TodoListInterface {\n    fun addItem(todo: String)\n    fun getItems(): List&lt;String&gt;\n};\n\nclass TodoList : TodoListInterface {\n   // implementations to call the Rust code.\n}\n</code></pre> <p>When working with these objects, it may be helpful to always pass the interface or protocol, but construct the concrete implementation. For example in Swift:</p> <pre><code>let todoList = TodoList()\ntodoList.addItem(todo: \"Write documentation\")\ndisplay(list: todoList)\n\nfunc display(list: TodoListProtocol) {\n    let items = list.getItems()\n    items.forEach {\n        print($0)\n    }\n}\n</code></pre> <p>Following this pattern will make it easier for you to provide mock implementation of the Rust-based objects for testing.</p>"},{"location":"types/interfaces.html#constructors","title":"Constructors","text":"<p>Interfaces can have one or more constructors. They must have a constructor to be directly created from foreign bindings.</p> <p><code>TodoList</code> has a <code>new()</code> method. This can be exposed via UDL with <code>constructor</code>, or via proc-macros with a <code>#[uniffi::constructor]</code> attribute.</p> <p>Along with a default constructor, an interface can have named constructors, implemented as static functions.</p> <p>Constructors: * may omit or include the outer <code>Arc&lt;&gt;</code> - eg, we could have written <code>fn new() -&gt; Arc&lt;Self&gt;</code> * can return a <code>Result&lt;&gt;</code> * can be async, although foreign language constraints means support for async primary constructors is patchy.</p>"},{"location":"types/interfaces.html#destructors","title":"Destructors","text":"<p>The foreign bindings will typically generate destructors, but regardless of the foreign semantics, they always hold an <code>Arc&lt;&gt;</code> to the Rust object, so these destructors will only drop their reference and may not drop the Rust object.</p>"},{"location":"types/interfaces.html#exposing-traits-as-interfaces","title":"Exposing Traits as interfaces","text":"<p>It's possible to have UniFFI expose a Rust trait as an interface.</p> <pre><code>pub trait Button: Send + Sync {\n    fn name(&amp;self) -&gt; String;\n}\n\nstruct StopButton {}\n\nimpl Button for StopButton  {\n    fn name(&amp;self) -&gt; String {\n        \"stop\".to_string()\n    }\n}\n</code></pre> <p>Note UDL requires a <code>Trait</code> attribute; proc-macros <code>#[uniffi::export]</code> the trait declaration.</p> <p>Uniffi enforces all interfaces are <code>Send + Sync</code>, meaning exported traits need to be explicitly bound.</p> <p>References to traits are passed around like normal interface objects - in an <code>Arc&lt;&gt;</code>. For example, your Rust would have these signatures:</p> <pre><code>fn get_buttons() -&gt; Vec&lt;Arc&lt;dyn Button&gt;&gt; { ... }\nfn press(button: Arc&lt;dyn Button&gt;) -&gt; Arc&lt;dyn Button&gt; { ... }\n</code></pre>"},{"location":"types/interfaces.html#foreign-implementations","title":"Foreign implementations","text":"<p>It's possible in both UDL (via a <code>[Foreign]</code> attribute) and proc-macros (via <code>#[uniffi::export(with_foreign)]</code>) to declare the trait can also be implemented on the foreign side passed into Rust, for example:</p> <pre><code>class PyButton(uniffi_module.Button):\n    def name(self):\n        return \"PyButton\"\n\nuniffi_module.press(PyButton())\n</code></pre> <p>Note: This is currently only supported on Python, Kotlin, and Swift.</p>"},{"location":"types/interfaces.html#traits-example","title":"Traits example","text":"<p>See the \"traits\" example for more.</p>"},{"location":"types/interfaces.html#exposing-methods-from-standard-rust-traits","title":"Exposing methods from standard Rust traits","text":"<p>Rust has a number of general purpose traits which add functionality to objects, such as <code>Debug</code>, <code>Display</code>, etc. It's possible to tell UniFFI that your object implements these traits and to generate FFI functions to expose them to consumers. Bindings may then optionally generate special methods on the object.</p> <p>For example, consider the following example: <pre><code>[Traits=(Debug)]\ninterface TodoList {\n    ...\n};\n</code></pre> and the following Rust code: <pre><code>#[derive(Debug)]\nstruct TodoList {\n   ...\n}\n</code></pre> (or using proc-macros) <pre><code>#[derive(Debug, uniffi::Object)]\n#[uniffi::export(Debug)]\nstruct TodoList {\n   ...\n}\n</code></pre></p> <p>This will cause the Python bindings to generate a <code>__repr__</code> method that returns the value implemented by the <code>Debug</code> trait. Not all bindings support generating special methods, so they may be ignored. It is your responsibility to implement the trait on your objects; UniFFI will attempt to generate a meaningful error if you do not.</p> <p>The list of supported traits is hard-coded in UniFFI's internals, and at time of writing is <code>Debug</code>, <code>Display</code>, <code>Eq</code> and <code>Hash</code>.</p>"},{"location":"types/interfaces.html#managing-shared-references","title":"Managing Shared References","text":"<p>To the foreign-language consumer, UniFFI object instances are designed to behave as much like regular language objects as possible. They can be freely passed as arguments or returned as values, like this:</p> <pre><code>interface TodoList {\n    ...\n\n    // Copy the items from another TodoList into this one.\n    void import_items(TodoList other);\n\n    // Make a copy of this TodoList as a new instance.\n    TodoList duplicate();\n\n    // Create a list of lists, one for each item this one\n    sequence&lt;TodoList&gt; split();\n};\n</code></pre> <p>To ensure that this is safe, UniFFI allocates every object instance on the heap using <code>Arc</code>, Rust's built-in smart pointer type for managing shared references at runtime.</p> <p>The use of <code>Arc</code> is transparent to the foreign-language code, but sometimes shows up in the function signatures of the underlying Rust code.</p> <p>When returning interface objects, UniFFI supports both Rust functions that wrap the value in an <code>Arc&lt;&gt;</code> and ones that don't.  This only applies if the interface type is returned directly:</p> <pre><code>impl TodoList {\n    // When the foreign function/method returns `TodoList`, the Rust code can return either `TodoList` or `Arc&lt;TodoList&gt;`.\n    fn duplicate(&amp;self) -&gt; TodoList {\n        TodoList {\n            items: RwLock::new(self.items.read().unwrap().clone())\n        }\n    }\n\n    // However, if TodoList is nested inside another type then `Arc&lt;TodoList&gt;` is required\n    fn split(&amp;self) -&gt; Vec&lt;Arc&lt;TodoList&gt;&gt; {\n        self.items.read()\n            .iter()\n            .map(|i| Arc::new(TodoList::from_item(i.clone()))\n            .collect()\n    }\n}\n</code></pre> <p>By default, object instances passed as function arguments will also be passed as an <code>Arc&lt;T&gt;</code>, so the Rust implementation of <code>TodoList::import_items</code> would also need to accept an <code>Arc&lt;TodoList&gt;</code>:</p> <pre><code>impl TodoList {\n    fn import_items(&amp;self, other: Arc&lt;TodoList&gt;) {\n        self.items.write().unwrap().append(other.get_items());\n    }\n}\n</code></pre> <p>If the Rust code does not need an owned reference to the <code>Arc</code>, you can use the <code>[ByRef]</code> UDL attribute to signal that a function accepts a borrowed reference:</p> <pre><code>interface TodoList {\n    ...\n    //                  +-- indicate that we only need to borrow the other list\n    //                  V\n    void import_items([ByRef] TodoList other);\n    ...\n};\n</code></pre> <pre><code>impl TodoList {\n    //                              +-- don't need to care about the `Arc` here\n    //                              V\n    fn import_items(&amp;self, other: &amp;TodoList) {\n        self.items.write().unwrap().append(other.get_items());\n    }\n}\n</code></pre> <p>Conversely, if the Rust code explicitly wants to deal with an <code>Arc&lt;T&gt;</code> in the special case of the <code>self</code> parameter, it can signal this using the <code>[Self=ByArc]</code> UDL attribute on the method:</p> <pre><code>interface TodoList {\n    ...\n    // +-- indicate that we want the `Arc` containing `self`\n    // V\n    [Self=ByArc]\n    void import_items(TodoList other);\n    ...\n};\n</code></pre> <pre><code>impl TodoList {\n    // `Arc`s everywhere! --+-----------------+\n    //                      V                 V\n    fn import_items(self: Arc&lt;Self&gt;, other: Arc&lt;TodoList&gt;) {\n        self.items.write().unwrap().append(other.get_items());\n    }\n}\n</code></pre> <p>You can read more about the technical details in the docs on the internal details of managing object references.</p>"},{"location":"types/interfaces.html#concurrent-access","title":"Concurrent Access","text":"<p>Since interfaces represent mutable data, UniFFI has to take extra care to uphold Rust's safety guarantees around shared and mutable references. The foreign-language code may attempt to operate on an interface instance from multiple threads, and it's important that this not violate Rust's assumption that there is at most a single mutable reference to a struct at any point in time.</p> <p>UniFFI enforces this by requiring that the Rust implementation of an interface be <code>Sync+Send</code>, and you will get a compile-time error if your implementation does not satisfy this requirement. For example, consider a small \"counter\" object declared like so:</p> <pre><code>interface Counter {\n    constructor();\n    void increment();\n    u64 get();\n};\n</code></pre> <p>For this to be safe, the underlying Rust struct must adhere to certain restrictions, and UniFFI's generated Rust scaffolding will emit compile-time errors if it does not.</p> <p>The Rust struct must not expose any methods that take <code>&amp;mut self</code>. The following implementation of the <code>Counter</code> interface will fail to compile because it relies on mutable references:</p> <pre><code>struct Counter {\n    value: u64\n}\n\nimpl Counter {\n    fn new() -&gt; Self {\n        Self { value: 0 }\n    }\n\n    // No mutable references to self allowed in UniFFI interfaces.\n    fn increment(&amp;mut self) {\n        self.value = self.value + 1;\n    }\n\n    fn get(&amp;self) -&gt; u64 {\n        self.value\n    }\n}\n</code></pre> <p>Implementations can instead use Rust's \"interior mutability\" pattern. However, they must do so in a way that is both <code>Sync</code> and <code>Send</code>, since the foreign-language code may operate on the instance from multiple threads. The following implementation of the <code>Counter</code> interface will fail to compile because <code>RefCell</code> is not <code>Sync</code>:</p> <pre><code>struct Counter {\n    value: RefCell&lt;u64&gt;\n}\n\nimpl Counter {\n    fn new() -&gt; Self {\n        // `RefCell` is not `Sync`, so neither is `Counter`.\n        Self { value: RefCell::new(0) }\n    }\n\n    fn increment(&amp;self) {\n        let mut value = self.value.borrow_mut();\n        *value = *value + 1;\n    }\n\n    fn get(&amp;self) -&gt; u64 {\n        *self.value.borrow()\n    }\n}\n</code></pre> <p>This version uses an <code>AtomicU64</code> for interior mutability, which is both <code>Sync</code> and <code>Send</code> and hence will compile successfully:</p> <pre><code>struct Counter {\n    value: AtomicU64\n}\n\nimpl Counter {\n    fn new() -&gt; Self {\n        Self { value: AtomicU64::new(0) }\n    }\n\n    fn increment(&amp;self) {\n        self.value.fetch_add(1, Ordering::SeqCst);\n    }\n\n    fn get(&amp;self) -&gt; u64 {\n        self.value.load(Ordering::SeqCst)\n    }\n}\n</code></pre> <p>You can read more about the technical details in the docs on the internal details of managing object references.</p>"},{"location":"types/namespace.html","title":"Namespace","text":"<p>Every crate has a UniFFI \"namespace\". This is the name exposed to the foreign bindings, typically as a module.</p> <p>For example, if our namespace is <code>math</code>, and we have Rust code:</p> <pre><code>#[uniffi::export] // if using proc-macros\nfn exp(a: f64) -&gt; f64 { ... }\n</code></pre> <p>you might find foreign code doing: <pre><code>from math import exp # python\n</code></pre> <pre><code>import math // swift\n</code></pre> <pre><code>import omg.wtf.math.exp // kotlin\n</code></pre></p> <p>If you use UDL, it must have a <code>namespace</code> block:</p> <pre><code>namespace math {\n  double exp(double a);\n};\n</code></pre> <p>Proc-macros don't need do anything unless the namespace name is different from the crate name, in which case it can be overridden with</p> <pre><code>uniffi::setup_scaffolding!(\"math\");\n</code></pre>"},{"location":"types/records.html","title":"Records","text":"<p>Records are how UniFFI represents structured data. They consist of one of more named fields, each of which holds a value of a particular type. A rust struct without any methods.</p> <p>Records were sometimes referred to as a dictionary due to the UDL syntax, but we try to use Record.</p> <p>There's further specific detail for UDL and proc-macros</p> <p>They can be exported as a simple rust struct:</p> <pre><code>#[derive(uniffi::Record)] // if using proc-macros\nstruct TodoEntry {\n    done: bool,\n    due_date: Option&lt;u64&gt;,\n    text: String,\n}\n</code></pre> <p>The fields in a record can be of any UniFFI supported type, including objects, vecs, maps and other records. The limitations are:</p> <ul> <li>They cannot recursively contain another instance of the same record type.</li> <li>They cannot contain references to callback interfaces (another reason callback interfaces should be avoided, use traits)</li> <li>You must directly use an owned UniFFI supported type directly - no references, no smart-pointers etc.</li> </ul>"},{"location":"types/records.html#fields-holding-object-references","title":"Fields holding object references","text":"<p>A record containing an interface must use an <code>Arc&lt;&gt;</code>.</p> <pre><code>struct TodoEntry {\n    owner: std::sync::Arc&lt;User&gt;,\n    text: String,\n}\n</code></pre> <p>Depending on the language, the foreign-language bindings may also need to be aware of these embedded references. For example in Kotlin, each Object instance must be explicitly destroyed to avoid leaking the underlying memory, and this also applies to Objects stored in record fields.</p> <p>You can read more about managing object references in the section on interfaces.</p>"},{"location":"types/records.html#default-values-for-fields","title":"Default values for fields","text":"<p>Fields can be specified with a default value.</p> <pre><code>struct TodoEntry {\n    #[uniffi(default = false)] // or specified in UDL.\n    done: bool,\n    text: String,\n}\n</code></pre> <p>The above example shows proc-macros; see also the UDL docs</p> <p>The corresponding generated Kotlin code would be equivalent to:</p> <pre><code>data class TodoEntry (\n    var done: Boolean = false,\n    var text: String\n)  {\n    // ...\n}\n</code></pre>"},{"location":"types/records.html#optional-fields-and-default-values","title":"Optional fields and default values","text":"<p>Fields can be made optional by using <code>Option&lt;T&gt;</code></p> <pre><code>struct TodoEntry {\n    done: bool,\n    text: Option&lt;String&gt;,\n}\n</code></pre> <p>The corresponding generated Kotlin code would be equivalent to:</p> <pre><code>data class TodoEntry (\n    var done: Boolean,\n    var text: String?\n)  {\n    // ...\n}\n</code></pre> <p>The default for this can be <code>None</code>, which would translate to <code>null</code>/<code>None</code>/<code>etc</code> in the bindings. Kotlin generates:</p> <pre><code>data class TodoEntry (\n    var done: Boolean,\n    var text: String? = null\n)  {\n    // ...\n}\n</code></pre>"},{"location":"types/remote_ext_types.html","title":"Remote and External types","text":"<p>Remote and external types can help solve some advanced use-cases when using UniFFI. They are grouped this section, since they're often used together.</p>"},{"location":"types/remote_ext_types.html#remote-types","title":"Remote types","text":"<p>\"Remote types\" refer to types defined in other crates that do not use UniFFI. This normally means types from crates that you depend on but don't control. Remote types require extra handling to use them in UniFFI APIs, because of Rust's orphan rule. See https://github.com/mozilla/uniffi-rs/tree/main/examples/log-formatter for example code.</p> <p>In general, using remote types in UniFFI requires writing a type definition that mirrors the real definition found in the remote crate.</p>"},{"location":"types/remote_ext_types.html#proc-macros","title":"Proc-macros","text":"<pre><code>// Type aliases can be used to give remote types nicer names when exposed in the UniFFI api.\ntype LogLevel = log::Level;\n\n// Write a definition that mirrors the definition from the remote crate and wrap it with `[uniffi::remote(&lt;kind&gt;)]`.\n//\n// - UniFFI will generate the FFI scaffolding code for the item, but will not output the item itself\n//   (since the real item is defined in the remote crate).\n// - `&lt;kind&gt;` can be any parameter that's valid for `uniffi::derive()`.\n#[uniffi::remote(Enum)]\nenum LogLevel {\n    Error,\n    Warn,\n    Info,\n    Debug,\n    Trace,\n}\n</code></pre>"},{"location":"types/remote_ext_types.html#udl","title":"UDL","text":"<p>Wrap the definition with <code>[Remote]</code> attribute:</p> <pre><code>[Remote]\nenum LogLevel {\n    \"Error\",\n    \"Warn\",\n    \"Info\",\n    \"Debug\",\n    \"Trace\",\n};\n</code></pre>"},{"location":"types/remote_ext_types.html#external-types","title":"External Types","text":"<p>\"External types\" refer to types defined in other crates that use UniFFI. This normally means types from other crates in your workspace.</p>"},{"location":"types/remote_ext_types.html#proc-macros_1","title":"Proc-macros","text":"<p>Proc-macro-based code can use external types automatically, without any extra code.</p>"},{"location":"types/remote_ext_types.html#udl_1","title":"UDL","text":"<p>Suppose you depend on the <code>DemoDict</code> type from another UniFFIed crate in your workspace. You can reference this type by using the <code>[External]</code> attribute to wrap a typedef describing the concrete type.</p> <pre><code>[External=\"demo_crate\"]\ntypedef dictionary DemoDict;\n\n// Now define our own dictionary which references the external type.\ndictionary ConsumingDict {\n  DemoDict demo_dict;\n  boolean another_bool;\n};\n</code></pre> <p>Supported values for the typedef type:</p> <ul> <li>Enums: <code>enum</code></li> <li>Records: <code>record</code>, <code>dictionary</code> or <code>struct</code></li> <li>Objects: <code>object</code>, <code>impl</code> or <code>interface</code></li> <li>Traits: <code>trait</code>, <code>callback</code> or <code>trait_with_foreign</code></li> <li>Custom types: <code>custom</code></li> </ul>"},{"location":"types/remote_ext_types.html#special-cases-for-remote-types","title":"Special cases for remote types","text":"<p>There are a few cases where remote types require extra handling in addition to the rules above.</p>"},{"location":"types/remote_ext_types.html#remote-external-types","title":"Remote + External types","text":"<p>Types that are remote and external require a <code>use_remote_type!</code> macro call.</p> <p>If <code>crate_a</code> defines IpAddr as a remote type, then <code>crate_b</code> can use that type with the following Rust code:</p> <pre><code>uniffi::use_remote_type!(crate_a::IpAddr);\n</code></pre>"},{"location":"types/remote_ext_types.html#udl_2","title":"UDL","text":"<p>UDL-users will also need to add the external type definition:</p> <pre><code>[External=\"crate_a\"]\ntypedef enum IpAddr;\n</code></pre>"},{"location":"types/remote_ext_types.html#remote-custom-types","title":"Remote custom types","text":"<p>Types that are remote and custom require using the <code>remote</code> attribute with the <code>custom_type!</code> macro.</p> <pre><code>uniffi::custom_type!(StructFromOtherCrate, String, {\n    remote,\n    lower: |s| s.to_string(),\n    try_lift: |s| StructFromOtherCrate::try_from_string(s),\n});\n</code></pre>"},{"location":"types/remote_ext_types.html#foreign-bindings","title":"Foreign bindings","text":"<p>The foreign bindings will also need to know how to access the external type, which varies slightly for each language:</p>"},{"location":"types/remote_ext_types.html#kotlin","title":"Kotlin","text":"<p>For Kotlin, \"library mode\" generation with <code>generate --library [path-to-cdylib]</code> is recommended when using external types. If you use <code>generate [udl-path]</code> then the generated code needs to know how to import the external types from the Kotlin module that corresponds to the Rust crate. By default, UniFFI assumes that the Kotlin module name matches the Rust crate name, but this can be configured in <code>uniffi.toml</code> with an entry like this:</p> <pre><code>[bindings.kotlin.external_packages]\n# Map the crate names from [External={name}] into Kotlin package names\nrust-crate-name = \"kotlin.package.name\"\n</code></pre>"},{"location":"types/remote_ext_types.html#swift","title":"Swift","text":"<p>For Swift, you must compile all generated <code>.swift</code> files together in a single module since the generate code expects that it can access external types without importing them.</p>"},{"location":"udl/index.html","title":"The UDL file","text":"<p>A UDL file allows you to define an interface externally from your Rust code. It defines which functions, methods and types are exposed to the foreign-language bindings.</p> <p>For example, here we describe a namespace with 2 records and an interface</p> <pre><code>namespace sprites {\n  Point translate([ByRef] Point position, Vector direction);\n};\n\ndictionary Point {\n  double x;\n  double y;\n};\n\ndictionary Vector {\n  double dx;\n  double dy;\n};\n\ninterface Sprite {\n  constructor(Point? initial_position);\n  Point get_position();\n  void move_to(Point position);\n  void move_by(Vector direction);\n};\n</code></pre>"},{"location":"udl/docstrings.html","title":"Docstrings","text":"<p>UDL file supports docstring comments. The comments are emitted in generated bindings without any transformations. What you see in UDL is what you get in generated bindings. The only change made to UDL comments are the comment syntax specific to each language. Docstrings can be used for most declarations in UDL file</p> <p>Docstrings in UDL are comments prefixed with <code>///</code>.</p> <p>Docstrings are parsed as AST nodes, so incorrectly placed docstrings will generate parse errors</p>"},{"location":"udl/docstrings.html#docstrings-in-udl","title":"Docstrings in UDL","text":"<pre><code>/// The list of supported capitalization options\nenum Capitalization {\n    /// Lowercase, i.e. `hello, world!`\n    Lower,\n\n    /// Uppercase, i.e. `Hello, World!`\n    Upper\n};\n\nnamespace example {\n    /// Return a greeting message, using `capitalization` for capitalization\n    string hello_world(Capitalization capitalization);\n}\n</code></pre>"},{"location":"udl/docstrings.html#docstrings-in-generated-kotlin-bindings","title":"Docstrings in generated Kotlin bindings","text":"<pre><code>/**\n * The list of supported capitalization options\n */\nenum class Capitalization {\n    /**\n     * Lowercase, i.e. `hello, world!`\n     */\n    LOWER,\n\n    /**\n     * Uppercase, i.e. `Hello, World!`\n     */\n    UPPER;\n}\n\n/**\n * Return a greeting message, using `capitalization` for capitalization\n */\nfun `helloWorld`(`capitalization`: Capitalization): String { .. }\n</code></pre>"},{"location":"udl/docstrings.html#docstrings-in-generated-swift-bindings","title":"Docstrings in generated Swift bindings","text":"<pre><code>/**\n * The list of supported capitalization options\n */\npublic enum Capitalization {\n    /**\n     * Lowercase, i.e. `hello, world!`\n     */\n    case lower\n\n    /**\n     * Uppercase, i.e. `Hello, World!`\n     */\n    case upper\n}\n\n/**\n * Return a greeting message, using `capitalization` for capitalization\n */\npublic func helloWorld(capitalization: Capitalization) -&gt; String;\n</code></pre>"},{"location":"udl/docstrings.html#docstrings-in-generated-python-bindings","title":"Docstrings in generated Python bindings","text":"<pre><code>class Capitalization(enum.Enum):\n    \"\"\"The list of supported capitalization options\"\"\"\n\n    LOWER = 1\n    \"\"\"Lowercase, i.e. `hello, world!`\"\"\"\n\n    UPPER = 2\n    \"\"\"Uppercase, i.e. `Hello, World!`\"\"\"\n\ndef hello_world(capitalization: \"Capitalization\") -&gt; \"str\":\n    \"\"\"Return a greeting message, using `capitalization` for capitalization\"\"\"\n    ..\n</code></pre>"},{"location":"udl/enumerations.html","title":"Enums in UDL","text":"<p>Our simple enum example is defined in UDL as:</p> <pre><code>enum Animal {\n  \"Dog\",\n  \"Cat\",\n};\n</code></pre>"},{"location":"udl/enumerations.html#enums-with-fields","title":"Enums with fields","text":"<p>Enumerations with associated data require a different syntax, due to the limitations of using WebIDL as the basis for UniFFI's interface language. An enum like <code>IpAddr</code> is specifiedl in UDL like:</p> <pre><code>[Enum]\ninterface IpAddr {\n  V4(u8 q1, u8 q2, u8 q3, u8 q4);\n  V6(string addr);\n};\n</code></pre>"},{"location":"udl/enumerations.html#remote-non-exhaustive-enums","title":"Remote, non-exhaustive enums","text":"<p>One corner case is an enum that's defined in another crate and has the non_exhaustive` attribute.</p> <p>In this case, UniFFI needs to generate a default arm when matching against the enum variants, or else a compile error will be generated. Use the <code>[NonExhaustive]</code> attribute to handle this case:</p> <pre><code>[Enum]\n[NonExhaustive]\ninterface Message {\n  Send(u32 from, u32 to, string contents);\n  Quit();\n};\n</code></pre> <p>Note: since UniFFI generates a default arm, if you leave out a variant, or if the upstream crate adds a new variant, this won't be caught at compile time. Any attempt to pass that variant across the FFI will result in a panic.</p>"},{"location":"udl/errors.html","title":"Errors in UDL","text":"<p>You expose our error example in UDL like:</p> <pre><code>[Error]\nenum ArithmeticError {\n  \"IntegerOverflow\",\n};\n\n\nnamespace arithmetic {\n  [Throws=ArithmeticError]\n  u64 add(u64 a, u64 b);\n}\n</code></pre> <p>Note that in the above example, <code>ArithmeticError</code> is \"flat\" - the associated data is not exposed - the foreign bindings see this as a simple enum-like object with no data. If you want to expose the associated data as fields on the exception, use this syntax:</p> <pre><code>[Error]\ninterface ArithmeticError {\n  IntegerOverflow(u64 a, u64 b);\n};\n</code></pre>"},{"location":"udl/errors.html#interfaces-as-errors","title":"Interfaces as errors","text":"<p>In our error interface example we are throwing the object <code>MyError</code>.</p> <pre><code>namespace error {\n  [Throws=MyError]\n  void bail(string message);\n}\n\n[Traits=(Debug)]\ninterface MyError {\n  string message();\n};\n</code></pre>"},{"location":"udl/external_types.html","title":"Using types defined outside a UDL.","text":"<p>Often you need to refer to types described outside of this UDL - they may be defined in a proc-macro in this crate or defined in an external crate.</p> <p>You declare such types using: <pre><code>typedef [type] [TypeName];\n</code></pre> <code>TypeName</code> is then able to be used as a normal type in this UDL (ie, be returned from functions, in records, etc)</p> <p><code>type</code> indicates the actual type of <code>TypeName</code> and can be any of the following values: * \"enum\" for Enums. * \"record\", \"dictionary\" or \"struct\" for Records. * \"object\", \"impl\" or \"interface\" for objects. * \"trait\", \"callback\" or \"trait_with_foreign\" for traits. * \"custom\" for Custom Types.</p> <p>for example, if this crate has: <pre><code>#[derive(::uniffi::Object)]\nstruct MyObject { ... }\n</code></pre> our UDL could use this type with: <pre><code>typedef interface MyObject;\n</code></pre></p>"},{"location":"udl/external_types.html#external-crates","title":"External Crates","text":"<p>The <code>[External=\"crate_name\"]</code> attribute can be used whenever the type is in another crate - whether in UDL or in a proc-macro.</p> <pre><code>[External = \"other_crate\"]\ntypedef interface OtherObject;\n</code></pre>"},{"location":"udl/functions.html","title":"Functions in UDL","text":"<p>All top-level functions get exposed through the UDL's <code>namespace</code> block.</p> <p>The UDL file will look like:</p> <pre><code>namespace Example {\n    string hello_world();\n}\n</code></pre>"},{"location":"udl/functions.html#default-values","title":"Default values","text":"<p>Function arguments can be marked <code>optional</code> with a default value specified.</p> <p>In the UDL file:</p> <pre><code>namespace Example {\n    string hello_name(optional string name = \"world\");\n}\n</code></pre>"},{"location":"udl/functions.html#async","title":"Async","text":"<p>Async functions can be exposed using the <code>[Async]</code> attribute:</p> <pre><code>namespace Example {\n    [Async]\n    string async_hello();\n}\n</code></pre>"},{"location":"udl/interfaces.html","title":"Interfaces in UDL","text":"<p>You expose our <code>TodoList</code> example in UDL like:</p> <pre><code>interface TodoList {\n    constructor();\n    void add_item(string todo);\n    sequence&lt;string&gt; get_items();\n};\n</code></pre> <p>The <code>constructor()</code> calls the Rust's <code>new()</code> method.</p>"},{"location":"udl/interfaces.html#alternate-named-constructors","title":"Alternate Named Constructors","text":"<p>In addition to the default constructor connected to the <code>::new()</code> method, you can specify alternate named constructors to create object instances in different ways. Each such constructor must be given an explicit name, provided in the UDL with the <code>[Name]</code> attribute like so:</p> <pre><code>interface TodoList {\n    // The default constructor makes an empty list.\n    constructor();\n    // This alternate constructor makes a new TodoList from a list of string items.\n    [Name=new_from_items]\n    constructor(sequence&lt;string&gt; items);\n    // This alternate constructor is async.\n    [Async, Name=new_async]\n    constructor(sequence&lt;string&gt; items);\n    ...\n};\n</code></pre> <p>For each alternate constructor, UniFFI will expose an appropriate static-method, class-method or similar in the foreign language binding, and will connect it to the Rust method of the same name on the underlying Rust struct.</p> <p>Constructors can be async, although support for async primary constructors in bindings is minimal.</p>"},{"location":"udl/interfaces.html#traits","title":"Traits","text":"<p>It's possible to have UniFFI expose a Rust trait as an interface by specifying a <code>Trait</code> attribute.</p> <p>For example, in the UDL file you might specify:</p> <pre><code>[Trait]\ninterface Button {\n    string name();\n};\n\nnamespace traits {\n    sequence&lt;Button&gt; get_buttons();\n    Button press(Button button);\n};\n</code></pre>"},{"location":"udl/interfaces.html#foreign-implementations","title":"Foreign implementations","text":"<p>Use the <code>WithForeign</code> attribute to allow traits to also be implemented on the foreign side passed into Rust, for example:</p> <pre><code>[Trait, WithForeign]\ninterface Button {\n    string name();\n};\n</code></pre> <p>would allow foreign implementations of that trait - eg, passing one back into Rust from Python:</p> <pre><code>class PyButton(uniffi_module.Button):\n    def name(self):\n        return \"PyButton\"\n\nuniffi_module.press(PyButton())\n</code></pre>"},{"location":"udl/interfaces.html#traits-construction","title":"Traits construction","text":"<p>Because any number of <code>struct</code>s may implement a trait, they don't have constructors.</p>"},{"location":"udl/records.html","title":"Records in UDL","text":"<p>Our simple TodoEntry is defined in UDL as:</p> <pre><code>dictionary TodoEntry {\n    boolean done;\n    u64? due_date;\n    string text;\n};\n</code></pre> <p>All the usual types are supported.</p>"},{"location":"udl/records.html#object-references","title":"Object references","text":"<p>Our dictionary can refer to obects - here, a <code>User</code></p> <pre><code>interface User {\n    // Some sort of \"user\" object that can own todo items\n};\n\ndictionary TodoEntry {\n    User owner;\n    string text;\n}\n</code></pre> <p>The Rust struct will have <code>owner</code> as an <code>Arc&lt;&gt;</code>.</p>"},{"location":"udl/records.html#default-values-for-fields","title":"Default values for fields","text":"<p>Fields can be specified with a default value.</p> <pre><code>dictionary TodoEntry {\n    boolean done = false;\n    string text;\n};\n</code></pre>"},{"location":"udl/records.html#optional-fields-and-default-values","title":"Optional fields and default values","text":"<p>Fields can be made optional using a <code>T?</code> type.</p> <pre><code>dictionary TodoEntry {\n    boolean done;\n    string? text;\n};\n</code></pre> <p>The corresponding Rust struct would need to look like this:</p> <pre><code>struct TodoEntry {\n    done: bool,\n    text: Option&lt;String&gt;,\n}\n</code></pre>"},{"location":"udl/records.html#optional-null-values","title":"Optional null values","text":"<p>Optional fields can also be set to a default <code>null</code> value:</p> <pre><code>dictionary TodoEntry {\n    boolean done;\n    string? text = null;\n};\n</code></pre>"},{"location":"udl/records.html#vecs-and-maps","title":"Vecs and maps","text":"<p>Empty collections are supported.</p> <pre><code>dictionary TodoEntry {\n    sequence&lt;string&gt; item_list = [];\n    record&lt;string, string&gt; item_map = {};\n};\n</code></pre>"},{"location":"wasm/configuration.html","title":"WASM","text":"<p>WASM defines a portable binary format for virtual machines running untrusted code in browsers and various other scenarios. Depending on the scenario, the host language may vary.</p> <p>As such, <code>uniffi-rs</code> does not come with bindings generators \"for WASM\". This is the job for external uniffi-bindgen generators. e.g. Typescript, Kotlin.</p> <p>However, the generated scaffolding needs to be configured for that WASM32 target.</p>"},{"location":"wasm/configuration.html#configuration","title":"Configuration","text":"<p>Configuring the Rust scaffolding ready for WASM binding generators is done by opting into features.</p> <p>e.g.</p> <pre><code>[dependendencies]\nuniffi = { version = \"0.29.2\", features = [\"wasm-unstable-single-threaded\"]}\n</code></pre>"},{"location":"wasm/configuration.html#features","title":"Features","text":""},{"location":"wasm/configuration.html#wasm-unstable-single-threaded","title":"<code>wasm-unstable-single-threaded</code>","text":"<p>At time of writing, the state of threading in WASM and Rust support is still in flux.</p> <p>Much of the ecosystem is built around gloo, <code>web-sys</code> and <code>wasm-rayon</code>.</p> <p>Enabling the <code>wasm-unstable-single-threaded</code> feature opts out of the <code>Send</code> and <code>Sync</code> checks when building for <code>wasm32</code> target architectures.</p> <p>This feature only affects the <code>wasm32</code> architecture.</p> <p>Hint: running <code>clippy</code> on client code built for <code>wasm32</code> may trigger a clippy warning when constructing <code>Arc</code>s.</p> <p>The lint's remedy is either to: - make the object to <code>Send</code> and <code>Sync</code>, or - change from an <code>Arc</code> to an <code>Rc</code>.</p> <p>As we are using this feature: - to allow <code>Send</code> and <code>Sync</code>, and - we can't use <code>Rc</code> for other targets</p> <p>we can disable this warning for <code>wasm32</code> only like so:</p> <pre><code>#[cfg_attr(target_arch = \"wasm32\", allow(clippy::arc_with_non_send_sync))]\nfn new() -&gt; Arc&lt;Self&gt; {\n    Arc::new(Self {})\n}\n</code></pre> <p>Note: as support for WASM threads evolves, this feature is likely to change or go away completely.</p>"}]}