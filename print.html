<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The UniFFI user guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Overview.html">Overview</a></li><li class="chapter-item expanded "><a href="Motivation.html"><strong aria-hidden="true">1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="Getting_started.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/Prerequisites.html"><strong aria-hidden="true">2.1.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="tutorial/udl_file.html"><strong aria-hidden="true">2.2.</strong> Describing the interface</a></li><li class="chapter-item expanded "><a href="tutorial/Rust_scaffolding.html"><strong aria-hidden="true">2.3.</strong> Generating the Rust scaffolding code</a></li><li class="chapter-item expanded "><a href="tutorial/foreign_language_bindings.html"><strong aria-hidden="true">2.4.</strong> Generating the foreign-language bindings</a></li></ol></li><li class="chapter-item expanded "><a href="udl_file_spec.html"><strong aria-hidden="true">3.</strong> The UDL file</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="udl/namespace.html"><strong aria-hidden="true">3.1.</strong> Namespace</a></li><li class="chapter-item expanded "><a href="udl/builtin_types.html"><strong aria-hidden="true">3.2.</strong> Built-in types</a></li><li class="chapter-item expanded "><a href="udl/enumerations.html"><strong aria-hidden="true">3.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="udl/structs.html"><strong aria-hidden="true">3.4.</strong> Structs/Dictionaries</a></li><li class="chapter-item expanded "><a href="udl/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="udl/errors.html"><strong aria-hidden="true">3.5.1.</strong> Throwing errors</a></li></ol></li><li class="chapter-item expanded "><a href="udl/interfaces.html"><strong aria-hidden="true">3.6.</strong> Interfaces/Objects</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Kotlin</li><li class="chapter-item expanded "><a href="kotlin/gradle.html"><strong aria-hidden="true">4.</strong> Integrating with Gradle</a></li><li class="chapter-item expanded affix "><li class="part-title">Swift</li><li class="chapter-item expanded "><a href="swift/overview.html"><strong aria-hidden="true">5.</strong> Overview</a></li><li class="chapter-item expanded "><a href="swift/module.html"><strong aria-hidden="true">6.</strong> Building a Swift module</a></li><li class="chapter-item expanded "><a href="swift/xcode.html"><strong aria-hidden="true">7.</strong> Integrating with XCode</a></li><li class="chapter-item expanded affix "><li class="part-title">Internals</li><li class="chapter-item expanded "><a href="internals/crates.html"><strong aria-hidden="true">8.</strong> Navigating the code</a></li><li class="chapter-item expanded "><a href="internals/lifting_and_lowering.html"><strong aria-hidden="true">9.</strong> Lifting, Lowering, and Serialization</a></li><li class="chapter-item expanded "><a href="internals/object_references.html"><strong aria-hidden="true">10.</strong> Managing object references</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The UniFFI user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#uniffi" id="uniffi">UniFFI</a></h1>
<p>UniFFI is a tool that automatically generates foreign-language bindings targeting Rust libraries.<br />
It fits in the practice of consolidating business logic in a single Rust library while targeting multiple platforms, making it simpler to develop and maintain a cross-platform codebase.<br />
Note that this tool will not help you ship a Rust library to these platforms, but simply not have to write bindings code by hand <a href="https://i.kym-cdn.com/photos/images/newsfeed/000/572/078/d6d.jpg">[0]</a>.</p>
<h2><a class="header" href="#design" id="design">Design</a></h2>
<p>UniFFI requires to write an Interface Definition Language (based on <a href="https://heycam.github.io/webidl/">WebIDL</a>) file describing the methods and data structures available to the targeted languages.<br />
This .udl (UniFFI Definition Language) file, whose definitions must match with the exposed Rust code, is then used to generate Rust <em>scaffolding</em> code and foreign-languages <em>bindings</em>. This process can take place either during the build process or be manually initiated by the developer.</p>
<p><img src="./uniffi_diagram.png" alt="uniffi diagram" /></p>
<h2><a class="header" href="#supported-languages" id="supported-languages">Supported languages</a></h2>
<ul>
<li>Kotlin</li>
<li>Swift</li>
<li>Python</li>
<li><a href="https://en.wikipedia.org/wiki/Gecko_(software)">Gecko</a> C++ (Work in Progress)</li>
</ul>
<h2><a class="header" href="#what" id="what">What?</a></h2>
<p>We're interested in building re-useable components for sync- and storage-related browser
functionality - things like <a href="https://github.com/mozilla/application-services/tree/main/components/logins">storing and syncing passwords</a>,
<a href="https://github.com/mozilla/application-services/tree/main/components/places">working with bookmarks</a> and
<a href="https://github.com/mozilla/application-services/tree/main/components/fxa-client">signing in to your Firefox Account</a>.</p>
<p>We want to write the code for these components once, in Rust. We want to easily re-use these components from
all the different languages and on all the different platforms for which we build browsers, which currently
includes JavaScript for PCs, Kotlin for Android, and Swift for iOS.</p>
<p>And of course, we want to do this in a way that's convenient, maintainable, and difficult to mess up.</p>
<h2><a class="header" href="#how" id="how">How?</a></h2>
<p>In an aspirational world, we could get this kind of easy cross-language interop for
free using <a href="https://rustwasm.github.io/docs/wasm-bindgen/">wasm_bindgen</a> and
<a href="https://hacks.mozilla.org/2019/08/webassembly-interface-types/">webassembly interface types</a> -
imagine writing an API in Rust, annotating it with some <code>#[wasm_bindgen]</code> macros,
compiling it into a webassembly bundle, and being able to import and use that bundle
from any target language, complete with a rich high-level API!</p>
<p>That kind of tooling is not available to shipping applications today, but that doesn't
mean we can't take a small step in that general direction while the Rust and Wasm ecosystem
continues to evolve.</p>
<p>Using UniFFI, you can:</p>
<ul>
<li>Implement your software component as a <code>cdylib</code> crate in Rust; let's say the code is in <code>./src/lib.rs</code>.</li>
<li>Specify the desired component API using an <em>Interface Definition Language</em> (specifically, a variant of WebIDL) in a separate file like <code>./src/lib.udl</code>.</li>
<li>Run <code>uniffi-bindgen scaffolding ./src/lib.udl</code> to generate a bunch of boilerplate rust code that exposes this API as a C-compatible FFI layer,
and include it as part of your crate.</li>
<li><code>cargo build</code> your crate as normal to produce a shared library.</li>
<li>Run <code>uniffi-bindgen generate ./src/lib.udl -l kotlin</code> to generate a Kotlin library that can load your shared library
and expose it to Kotlin code using your nice high-level component API!
<ul>
<li>Or <code>-l swift</code> or <code>-l python</code> to produce bindings for other languages.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#why" id="why">Why?</a></h2>
<p>There are plenty of potential ways to solve this problem, and the one that's right for us might not
be right for you. You can read a little more about the considerations and trade-offs
that lead to the current approach in our <a href="https://github.com/mozilla/uniffi-rs/tree/main/docs/adr/README.md">Architecture Decision Records</a>,
starting with <a href="https://github.com/mozilla/uniffi-rs/tree/main/docs/adr/0000-whats-the-big-idea.md">this motivational document</a>.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<p>Say your company has a simple <code>math</code> crate with the following <code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: u32, b: u32) -&gt; u32 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>And top brass would like you to expose this <em>business-critical</em> operation to Kotlin and Swift.<br />
<strong>Don't panic!</strong> We will show you how do that using UniFFI.</p>
<h1><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h1>
<h2><a class="header" href="#the-uniffi-bindgen-cli-tool" id="the-uniffi-bindgen-cli-tool">The uniffi-bindgen cli tool</a></h2>
<p>Install the <code>uniffi-bindgen</code> binary on your system using:</p>
<p><code>cargo install uniffi_bindgen</code></p>
<p>You can see what it can do with <code>uniffi-bindgen --help</code>, but let's leave it aside for now.</p>
<h2><a class="header" href="#build-your-crate-as-a-cdylib" id="build-your-crate-as-a-cdylib">Build your crate as a cdylib</a></h2>
<p>Ensure your crate builds as a <code>cdylib</code> by adding</p>
<pre><code class="language-toml">crate-type = [&quot;cdylib&quot;]
name = &quot;&lt;library name&gt;&quot;
</code></pre>
<p>to your crate's <code>Cargo.toml</code>.</p>
<h1><a class="header" href="#the-udl-file" id="the-udl-file">The UDL file</a></h1>
<p>We describe in a UDL (a type of IDL, Interface Definition Language) file <em>what</em> is exposed and available to foreign-language bindings. In this case, we are only playing with primitive types (<code>u32</code>) and not custom data structures but we still want to expose the <code>add</code> method.<br />
Let's create a <code>math.udl</code> file in the <code>math</code> crate's <code>src/</code> folder:</p>
<pre><code class="language-idl">namespace math {
  u32 add(u32 a, u32 b);
};
</code></pre>
<p>Here you can note multiple things:</p>
<ul>
<li>The <code>namespace</code> directive: it will be the name of your Kotlin/Swift package. It <strong>must</strong> be present in any udl file, even if there ain't any exposed function (e.g. <code>namespace foo {}</code>).</li>
<li>The <code>add</code> function is in the <code>namespace</code> block. That's because on the Rust side it is a top-level <em>function</em>, we will see later how to to handle <em>methods</em>.</li>
<li>Rust's <code>u32</code> is also UDL's <code>u32</code>, but it is not always true! (TODO table correspondance)</li>
</ul>
<p><strong>Note:</strong> If any of the things you expose in the <code>udl</code> file do not have an equivalent in your Rust crate, you will get a hard error. Try changing the <code>u32</code> result type to <code>u64</code> and see what happens!</p>
<h1><a class="header" href="#rust-scaffolding" id="rust-scaffolding">Rust scaffolding</a></h1>
<h2><a class="header" href="#rust-scaffolding-code" id="rust-scaffolding-code">Rust scaffolding code</a></h2>
<p>Now we generate some Rust helper code to make the <code>add</code> method available to foreign-language bindings.</p>
<p>First, add <code>uniffi</code> to your crate dependencies; this is the runtime support code that powers UniFFI's serialization of data types across languages:</p>
<pre><code class="language-toml">[dependencies]
uniffi = &quot;0.8&quot;
</code></pre>
<p>Important note: the <code>uniffi</code> version must be the same as the <code>uniffi-bindgen</code> command-line tool installed on your system.</p>
<p>Then let's add <code>uniffi_build</code> to your build dependencies: it generates the Rust scaffolding code that exposes our Rust functions as a C-compatible FFI layer.</p>
<pre><code class="language-toml">[build-dependencies]
uniffi_build = &quot;0.8&quot;
</code></pre>
<p>Then create a <code>build.rs</code> file next to <code>Cargo.toml</code> that will use <code>uniffi_build</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    uniffi_build::generate_scaffolding(&quot;./src/math.udl&quot;).unwrap();
}
</code></pre></pre>
<p><strong>Note:</strong> This is the equivalent of calling (and does it under the hood) <code>uniffi-bindgen scaffolding src/math.udl --out-dir &lt;OUT_DIR&gt;</code>.</p>
<p>Lastly, we include the generated scaffolding code in our <code>lib.rs</code>. If you've used the default build
settings then this can be done using a handy macro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>uniffi_macros::include_scaffolding!(&quot;math&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>If you have generated the scaffolding in a custom location, use the standard <code>include!</code> macro
to include the generated file by name, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/math.uniffi.rs&quot;));
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note:</strong> The file name is always <code>&lt;namespace&gt;.uniffi.rs</code>.</p>
<p>Great! <code>add</code> is ready to see the outside world!</p>
<h3><a class="header" href="#avoiding-version-mismatches-between-uniffi-core-and-uniffi-bindgen" id="avoiding-version-mismatches-between-uniffi-core-and-uniffi-bindgen">Avoiding version mismatches between <code>uniffi</code> core and <code>uniffi-bindgen</code></a></h3>
<p>The process above has one significant problem - things start to fall apart if
the version of the <code>uniffi</code> core (ie, the version specified in <code>[dependencies]</code>)
and the version of <code>uniffi-bindgen</code> (ie, the version installed by
<code>cargo install</code>) get out of date - and often these problems are not detected
until runtime when the generated rust code actually runs.</p>
<p>The <code>uniffi_build</code> crate supports an alternative workflow via the
<code>builtin-bindgen</code> feature. If this feature is enabled, then the <code>uniffi_build</code>
crate takes a runtime dependency on the <code>uniffi_bindgen</code> crate - effectively
building and running the <code>uniffi-bindgen</code> tool as your crate is being compiled.
The <code>uniffi-bindgen</code> tool doesn't need to be installed if this feature is
enabled.</p>
<p>The downside of this is that it drives up the build time for your crate (as
<code>uniffi-bindgen</code> needs to be built as well), so it's not the default.</p>
<p>To enable this, the <code>[build-dependencies]</code> of your Cargo.toml might look like:</p>
<pre><code class="language-toml">[build-dependencies]
uniffi_build = {version = &quot;0.8&quot;, features = [ &quot;builtin-bindgen&quot; ]}
</code></pre>
<p>Your <code>build.rs</code> script and everything else should remain the same, but now
whatever version of <code>uniffi</code> is specified will be used to perform the (now
slightly slower) build.</p>
<h3><a class="header" href="#rust-scaffolding-code-from-a-local-uniffi" id="rust-scaffolding-code-from-a-local-uniffi">Rust scaffolding code from a local <code>uniffi</code></a></h3>
<p><strong>Note:</strong> This section is only for people who want to make changes to <code>uniffi</code>
itself. If you just want to use <code>uniffi</code> as released you should ignore this
section.</p>
<p>The techniques above don't work very well when you are making changes to
<code>uniffi</code> itself and want to see how those changes impact your project - there's
no released version of <code>uniffi</code> you can reference.</p>
<p>To support this use-case, you can leverage Cargo's support for local
dependencies and the <code>builtin-bindgen</code> feature described above. You should:</p>
<ul>
<li>
<p>Change the <code>[dependencies]</code> section of your Cargo.toml to point to a local
checkout of <code>uniffi</code> core.</p>
</li>
<li>
<p>Change the <code>[build-dependencies]</code> section of your Cargo.toml to point to a
local checkout of <code>uniffi_build</code> <em>and</em> enable the <code>builtin-bindgen</code> feature.</p>
</li>
</ul>
<p>For example, you will probably end up with Cargo.toml looking something like:</p>
<pre><code class="language-toml">[dependencies]
uniffi = { path = &quot;path/to/uniffi-rs/uniffi }
...
[build-dependencies]
uniffi_build = { path = &quot;path/to/uniffi-rs/uniffi_build, features=[&quot;builtin-bindgen&quot;] }
</code></pre>
<p>Note that <code>path/to/uniffi-rs</code> should be the path to the root of the <code>uniffi</code>
source tree - ie, the 2 path specs above point to different sub-directories
under the <code>uniffi</code> root.</p>
<h1><a class="header" href="#foreign-language-bindings" id="foreign-language-bindings">Foreign-language bindings</a></h1>
<p>As stated in the <a href="tutorial/../Overview.html">Overview</a>, this library and tutorial does not cover <em>how</em> to ship a Rust library on mobile, but how to generate bindings for it, so this section will only cover that.</p>
<h2><a class="header" href="#kotlin" id="kotlin">Kotlin</a></h2>
<p>Run</p>
<pre><code>uniffi-bindgen generate src/math.udl --language kotlin
</code></pre>
<p>then have a look at <code>src/uniffi/math/math.kt</code></p>
<h2><a class="header" href="#swift" id="swift">Swift</a></h2>
<p>Run</p>
<pre><code>uniffi-bindgen generate src/math.udl --language swift
</code></pre>
<p>then check out <code>src/math.swift</code></p>
<p>Note that these commands could be integrated as part of your gradle/XCode build process.</p>
<p>This is it, you have an MVP integration of UniFFI in your project.</p>
<h1><a class="header" href="#the-udl-file-1" id="the-udl-file-1">The UDL file</a></h1>
<p>This file defines which functions, methods and types are exposed to the foreign-language bindings.</p>
<pre><code class="language-udl">namespace sprites {
  Point translate([ByRef] Point position, Vector direction);
};

dictionary Point {
  double x;
  double y;
};

dictionary Vector {
  double dx;
  double dy;
};

interface Sprite {
  constructor(Point? initial_position);
  Point get_position();
  void move_to(Point position);
  void move_by(Vector direction);
};
</code></pre>
<h1><a class="header" href="#namespace" id="namespace">Namespace</a></h1>
<p>Every UDL file <em>must</em> have a <code>namespace</code> block:</p>
<pre><code class="language-idl">namespace math {
  double exp(double a);
};
</code></pre>
<p>It serves multiple purposes:</p>
<ul>
<li>It identifies the name of the generated Rust scaffolding file <code>&lt;namespace&gt;.uniffi.rs</code>.</li>
<li>It identifies the package name of the generated foreign-language bindings (e.g. <code>uniffi.&lt;namespace&gt;</code> in Kotlin)</li>
<li>It also contains all <a href="udl/./functions.html">top-level <em>functions</em></a> that get exposed to foreign-language bindings.</li>
</ul>
<h1><a class="header" href="#built-in-types" id="built-in-types">Built-in types</a></h1>
<p>The following built-in types can be passed as arguments/returned by Rust methods:</p>
<table><thead><tr><th>Rust type</th><th>UDL type</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>boolean</code></td><td></td></tr>
<tr><td><code>u8/i8..u64/i64</code></td><td><code>u8/i8..u64/i64</code></td><td></td></tr>
<tr><td><code>f32</code></td><td><code>float</code></td><td></td></tr>
<tr><td><code>f64</code></td><td><code>double</code></td><td></td></tr>
<tr><td><code>String</code></td><td><code>string</code></td><td></td></tr>
<tr><td><code>SystemTime</code></td><td><code>timestamp</code></td><td>Precision may be lost when converting to Python and Swift types</td></tr>
<tr><td><code>Duration  </code></td><td><code>duration</code></td><td>Precision may be lost when converting to Python and Swift types</td></tr>
<tr><td><code>&amp;T</code></td><td><code>[ByRef] T</code></td><td>This works for <code>&amp;str</code> and <code>&amp;[T]</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td><code>T?</code></td><td></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>sequence&lt;T&gt;</code></td><td></td></tr>
<tr><td><code>HashMap&lt;String, T&gt;</code></td><td><code>record&lt;DOMString, T&gt;</code></td><td>Only string keys are supported</td></tr>
<tr><td><code>()</code></td><td><code>void</code></td><td>Empty return</td></tr>
<tr><td><code>Result&lt;T, E&gt;</code></td><td>N/A</td><td>See <a href="udl/./errors.html">Errors</a> section</td></tr>
</tbody></table>
<p>And of course you can use your own types, which is covered in the following sections.</p>
<h1><a class="header" href="#enumerations" id="enumerations">Enumerations</a></h1>
<p>An enumeration defined in Rust code as</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog,
    Cat,
}
<span class="boring">}
</span></code></pre></pre>
<p>Can be exposed in the UDL file with:</p>
<pre><code class="language-idl">enum Animal {
  &quot;Dog&quot;,
  &quot;Cat&quot;,
};
</code></pre>
<p>Enumerations with associated data require a different syntax,
due to the limitations of using WebIDL as the basis for UniFFI's interface language.
An enum like this in Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
  V4 {q1: u8, q2: u8, q3: u8, q4: u8},
  V6 {addr: string},
}
<span class="boring">}
</span></code></pre></pre>
<p>Can be exposed in the UDL file with:</p>
<pre><code class="language-idl">[Enum]
interface IpAddr {
  V4(u8 q1, u8 q2, u8 q3, u8 q4);
  V6(string addr);
};
</code></pre>
<p>Only enums with named fields are supported by this syntax.</p>
<h1><a class="header" href="#structsdictionaries" id="structsdictionaries">Structs/Dictionaries</a></h1>
<p>Dictionaries are how UniFFI represents structured data.
They consist of one of more named <em>fields</em>, each of which holds a value of a particular type.
Think of them like a Rust struct without any methods.</p>
<p>A Rust struct like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoEntry {
    done: bool,
    due_date: u64,
    text: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Can be exposed via UniFFI using UDL like this:</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done;
    u64 due_date;
    string text;
};
</code></pre>
<p>The fields in a dictionary can be of almost any type, including objects or other dictionaries.
The current limitations are:</p>
<ul>
<li>They cannot recursively contain another instance of the <em>same</em> dictionary type.</li>
<li>They cannot contain references to callback interfaces.</li>
</ul>
<h2><a class="header" href="#fields-holding-object-references" id="fields-holding-object-references">Fields holding Object References</a></h2>
<p>If a dictionary contains a field whose type is an <a href="udl/./interfaces.html">interface</a>, then that
field will hold a <em>reference</em> to an underlying instance of a Rust struct. The Rust code for
working with such fields must store them as an <code>Arc</code> in order to help properly manage the
lifetime of the instance. So if the UDL interface looked like this:</p>
<pre><code class="language-idl">interface User {
    // Some sort of &quot;user&quot; object that can own todo items
};

dictionary TodoEntry {
    User owner;
    string text;
}
</code></pre>
<p>Then the corresponding Rust code would need to look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoEntry {
    owner: std::sync::Arc&lt;User&gt;,
    text: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Depending on the language, the foreign-language bindings may also need to be aware of
these embedded references. For example in Kotlin, each Object instance must be explicitly
destroyed to avoid leaking the underlying memory, and this also applies to Objects stored
in record fields.</p>
<p>You can read more about managing object references in the section on <a href="udl/./interfaces.html">interfaces</a>.</p>
<h2><a class="header" href="#default-values-for-fields" id="default-values-for-fields">Default values for fields</a></h2>
<p>Fields can be specified with a default value:</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done = false;
    string text;
};
</code></pre>
<p>The corresponding generated Kotlin code would be equivalent to:</p>
<pre><code class="language-kotlin">data class TodoEntry (
    var done: Boolean = false,
    var text: String
)  {
    // ...
}
</code></pre>
<p>This works for Swift and Python targets too.
If not set otherwise the default value for a field is used when constructing the Rust struct.</p>
<h2><a class="header" href="#optional-fields-and-default-values" id="optional-fields-and-default-values">Optional fields and default values</a></h2>
<p>Fields can be made optional using a <code>T?</code> type.</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done;
    string? text;
};
</code></pre>
<p>The corresponding Rust struct would need to look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoEntry {
    done: bool,
    text: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The corresponding generated Kotlin code would be equivalent to:</p>
<pre><code class="language-kotlin">data class TodoEntry (
    var done: Boolean,
    var text: String?
)  {
    // ...
}
</code></pre>
<p>Optional fields can also be set to a default <code>null</code> value:</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done;
    string? text = null;
};
</code></pre>
<p>The corresponding generated Kotlin code would be equivalent to:</p>
<pre><code class="language-kotlin">data class TodoEntry (
    var done: Boolean,
    var text: String? = null
)  {
    // ...
}
</code></pre>
<p>This works for Swift and Python targets too.</p>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>All top-level <em>functions</em> get exposed through the UDL's <code>namespace</code> block.
For example, if the crate's <code>lib.rs</code> file contains:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_world() -&gt; String {
    &quot;Hello World!&quot;.to_owned()
}
<span class="boring">}
</span></code></pre></pre>
<p>The UDL file will look like:</p>
<pre><code class="language-idl">namespace Example {
    string hello_world();
}
</code></pre>
<h2><a class="header" href="#optional-arguments--default-values" id="optional-arguments--default-values">Optional arguments &amp; default values</a></h2>
<p>Function arguments can be marked <code>optional</code> with a default value specified.</p>
<p>In the UDL file:</p>
<pre><code class="language-idl">namespace Example {
    string hello_name(optional string name = &quot;world&quot;);
}
</code></pre>
<p>The Rust code will take a required argument:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_name(name: String) -&gt; String {
    format!(&quot;Hello {}&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<p>The generated foreign-language bindings will use function parameters with default values.
This works for the Kotlin, Swift and Python targets.</p>
<p>For example the generated Kotlin code will be equivalent to:</p>
<pre><code class="language-kotlin">fun helloName(name: String = &quot;world&quot; ): String {
    // ...
}
</code></pre>
<h1><a class="header" href="#throwing-errors" id="throwing-errors">Throwing errors</a></h1>
<p>It is often the case that a function does not return <code>T</code> in Rust but <code>Result&lt;T, E&gt;</code> to reflect that it is fallible.<br />
For UniFFI to expose this error, your error type (<code>E</code>) must be an <code>enum</code> and implement <code>std::error::Error</code> (<a href="https://crates.io/crates/thiserror">thiserror</a> works!).</p>
<p>Here's how you would write a Rust failible function and how you'd expose it in UDL:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
enum ArithmeticError {
    #[error(&quot;Integer overflow on an operation with {a} and {b}&quot;)]
    IntegerOverflow { a: u64, b: u64 },
}

fn add(a: u64, b: u64) -&gt; Result&lt;u64, ArithmeticError&gt; {
    a.checked_add(b).ok_or(ArithmeticError::IntegerOverflow { a, b })
}
<span class="boring">}
</span></code></pre></pre>
<p>And in UDL:</p>
<pre><code>[Error]
enum ArithmeticError {
  &quot;IntegerOverflow&quot;,
};


namespace arithmetic {
  [Throws=ArithmeticError]
  u64 add(u64 a, u64 b);
}
</code></pre>
<p>On the other side (Kotlin, Swift etc.), a proper exception will be thrown if <code>Result::is_err()</code> is <code>true</code>.</p>
<p>If you want to expose the assocated data as fields on the exception, use this syntax:</p>
<pre><code>[Enum]
interface ArithmeticError {
  IntegerOverflow(u64 a, u64 b);
};
</code></pre>
<h1><a class="header" href="#interfacesobjects" id="interfacesobjects">Interfaces/Objects</a></h1>
<p>Interfaces are represented in the Rust world as a struct with an <code>impl</code> block containing methods. In the Kotlin or Swift world, it's a class.</p>
<p>Because Objects are passed by reference and Dictionaries by value, in the UniFFI world it is impossible to be both an Object and a <a href="udl/./structs.html">Dictionary</a>.</p>
<p>The following Rust code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoList {
    items: RwLock&lt;Vec&lt;String&gt;&gt;
}

impl TodoList {
    fn new() -&gt; Self {
        TodoList {
            items: RwLock::&lt;Vec::new())
        }
    }

    fn add_item(&amp;mut self, todo: String) {
        self.items.write().unwrap().push(todo);
    }

    fn get_items(&amp;self) -&gt; Vec&lt;String&gt; {
        self.items.read().unwrap().clone()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>would be exposed using:</p>
<pre><code class="language-idl">interface TodoList {
    constructor();
    void add_item(string todo);
    sequence&lt;string&gt; get_items();
};
</code></pre>
<p>By convention, the <code>constructor()</code> calls the Rust's <code>new()</code> method.</p>
<p>Conceptually, these <code>interface</code> objects are live Rust structs that have a proxy object on the foreign language side; calling any methods on them, including a constructor or destructor results in the corresponding methods being called in Rust.</p>
<p>UniFFI will generate these proxies with an interface or protocol to help with testing in the foreign-language code. For example in Kotlin, the <code>TodoList</code> would generate:</p>
<pre><code class="language-kotlin">interface TodoListInterface {
    fun addItem(todo: String)
    fun getItems(): List&lt;String&gt;
}

class TodoList : TodoListInterface {
   // implementations to call the Rust code.
}
</code></pre>
<p>When working with these objects, it may be helpful to always pass the interface or protocol, but construct the concrete implementation. For example in Swift:</p>
<pre><code class="language-swift">let todoList = TodoList()
todoList.addItem(todo: &quot;Write documentation&quot;)
display(list: todoList)

func display(list: TodoListProtocol) {
    let items = list.getItems()
    items.forEach {
        print($0)
    }
}
</code></pre>
<p>Following this pattern will make it easier for you to provide mock implementation of the Rust-based objects
for testing.</p>
<h2><a class="header" href="#alternate-named-constructors" id="alternate-named-constructors">Alternate Named Constructors</a></h2>
<p>In addition to the default constructor connected to the <code>::new()</code> method, you can specify
alternate named constructors to create object instances in different ways. Each such constructor
must be given an explicit name, provided in the UDL with the <code>[Name]</code> attribute like so:</p>
<pre><code class="language-idl">interface TodoList {
    // The default constructor makes an empty list.
    constructor();
    // This alternate constructor makes a new TodoList from a list of string items.
    [Name=new_from_items]
    constructor(sequence&lt;string&gt; items)
    ...
</code></pre>
<p>For each alternate constructor, UniFFI will expose an appropriate static-method, class-method or similar
in the foreign language binding, and will connect it to the Rust method of the same name on the underlying
Rust struct.</p>
<h2><a class="header" href="#managing-shared-references" id="managing-shared-references">Managing Shared References</a></h2>
<p>To the foreign-language consumer, UniFFI object instances are designed to behave as much like
regular language objects as possible. They can be freely passed as arguments or returned as values,
like this:</p>
<pre><code class="language-idl">interface TodoList {
    ...

    // Copy the items from another TodoList into this one.
    void import_items(TodoList other);

    // Make a copy of this TodoList as a new instance.
    TodoList duplicate();
};
</code></pre>
<p>To ensure that this is safe, UniFFI allocates every object instance on the heap using
<a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>, Rust's built-in smart pointer
type for managing shared references at runtime.</p>
<p>The use of <code>Arc</code> is transparent to the foreign-language code, but sometimes shows up
in the function signatures of the underlying Rust code. For example, the Rust code implementing
the <code>TodoList::duplicate</code> method would need to explicitly return an <code>Arc&lt;TodoList&gt;</code>, since UniFFI
doesn't know whether it will be returning a new object or an existing one:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TodoList {
    fn duplicate(&amp;self) -&gt; Arc&lt;TodoList&gt; {
        Arc::new(TodoList {
            items: RwLock::new(self.items.read().unwrap().clone())
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, object instances passed as function arguments will also be passed as an <code>Arc&lt;T&gt;</code>, so the
Rust implementation of <code>TodoList::import_items</code> would also need to accept an <code>Arc&lt;TodoList&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TodoList {
    fn import_items(&amp;self, other: Arc&lt;TodoList&gt;) {
        self.items.write().unwrap().append(other.get_items());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If the Rust code does not need an owned reference to the <code>Arc</code>, you can use the <code>[ByRef]</code> UDL attribute
to signal that a function accepts a borrowed reference:</p>
<pre><code class="language-idl">interface TodoList {
    ...
    //                  +-- indicate that we only need to borrow the other list
    //                  V
    void import_items([ByRef] TodoList other);
    ...
};
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TodoList {
    //                              +-- don't need to care about the `Arc` here
    //                              V
    fn import_items(&amp;self, other: &amp;TodoList) {
        self.items.write().unwrap().append(other.get_items());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Conversely, if the Rust code explicitly <em>wants</em> to deal with an <code>Arc&lt;T&gt;</code> in the special case of
the <code>self</code> parameter, it can signal this using the <code>[Self=ByArc]</code> UDL attribute on the method:</p>
<pre><code class="language-idl">interface TodoList {
    ...
    // +-- indicate that we want the `Arc` containing `self`
    // V
    [Self=ByArc]
    void import_items(TodoList other);
    ...
};
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TodoList {
    // `Arc`s everywhere! --+-----------------+
    //                      V                 V
    fn import_items(self: Arc&lt;Self&gt;, other: Arc&lt;TodoList&gt;) {
        self.items.write().unwrap().append(other.get_items());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can read more about the technical details in the docs on the
<a href="udl/../internals/object_references.html">internal details of managing object references</a>.</p>
<h2><a class="header" href="#concurrent-access" id="concurrent-access">Concurrent Access</a></h2>
<p>Since interfaces represent mutable data, UniFFI has to take extra care
to uphold Rust's safety guarantees around shared and mutable references.
The foreign-language code may attempt to operate on an interface instance
from multiple threads, and it's important that this not violate Rust's
assumption that there is at most a single mutable reference to a struct
at any point in time.</p>
<p>UniFFI enforces this by requiring that the Rust implementation of an interface
be <code>Sync+Send</code>, and you will get a compile-time error if your implementation
does not satisfy this requirement. For example, consider a small &quot;counter&quot;
object declared like so:</p>
<pre><code class="language-idl">interface Counter {
    constructor();
    void increment();
    u64 get();
};
</code></pre>
<p>For this to be safe, the underlying Rust struct must adhere to certain restrictions, and
UniFFI's generated Rust scaffolding will emit compile-time errors if it does not.</p>
<p>The Rust struct must not expose any methods that take <code>&amp;mut self</code>. The following implementation
of the <code>Counter</code> interface will fail to compile because it relies on mutable references:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    value: u64
}

impl Counter {
    fn new() -&gt; Self {
        Self { value: 0 }
    }

    // No mutable references to self allowed in UniFFI interfaces.
    fn increment(&amp;mut self) {
        self.value = self.value + 1;
    }

    fn get(&amp;self) -&gt; u64 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Implementations can instead use Rust's &quot;interior mutability&quot; pattern. However, they
must do so in a way that is both <code>Sync</code> and <code>Send</code>, since the foreign-language code
may operate on the instance from multiple threads. The following implementation of the
<code>Counter</code> interface will fail to compile because <code>RefCell</code> is not <code>Sync</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    value: RefCell&lt;u64&gt;
}

impl Counter {
    fn new() -&gt; Self {
        // `RefCell` is not `Sync`, so neither is `Counter`.
        Self { value: RefCell::new(0) }
    }

    fn increment(&amp;self) {
        let mut value = self.value.borrow_mut();
        *value = *value + 1;
    }

    fn get(&amp;self) -&gt; u64 {
        *self.value.borrow()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This version uses an <code>AtomicU64</code> for interior mutability, which is both <code>Sync</code> and
<code>Send</code> and hence will compile successfully:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    value: AtomicU64
}

impl Counter {
    fn new() -&gt; Self {
        Self { value: AtomicU64::new(0) }
    }

    fn increment(&amp;self) {
        self.value.fetch_add(1, Ordering::SeqCst);
    }

    fn get(&amp;self) -&gt; u64 {
        self.value.load(Ordering::SeqCst)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can read more about the technical details in the docs on the
<a href="udl/../internals/object_references.html">internal details of managing object references</a>.</p>
<h1><a class="header" href="#integrating-with-gradle" id="integrating-with-gradle">Integrating with Gradle</a></h1>
<p>It is possible to generate Kotlin bindings at compile time for Kotlin Android projects. We'd like to make a gradle plugin for that, but until then you can add to your <code>build.gradle</code> the following:</p>
<pre><code class="language-groovy">android.libraryVariants.all { variant -&gt;
    def t = tasks.register(&quot;generate${variant.name.capitalize()}UniFFIBindings&quot;, Exec) {
        workingDir &quot;${project.projectDir}&quot;
        // Runs the bindings generation, note that you must have uniffi-bindgen installed and in your PATH environment variable
        commandLine 'uniffi-bindgen', 'generate', '&lt;PATH TO .udl FILE&gt;', '--language', 'kotlin', '--out-dir', &quot;${buildDir}/generated/source/uniffi/${variant.name}/java&quot;
    }
    variant.javaCompileProvider.get().dependsOn(t)
    def sourceSet = variant.sourceSets.find { it.name == variant.name }
    sourceSet.java.srcDir new File(buildDir, &quot;generated/source/uniffi/${variant.name}/java&quot;)
    // XXX: I've been trying to make this work but I can't, so the compiled bindings will show as &quot;regular sources&quot; in Android Studio.
    idea.module.generatedSourceDirs += file(&quot;${buildDir}/generated/source/uniffi/${variant.name}/java/uniffi&quot;)
}
</code></pre>
<p>The generated bindings should appear in the project sources in Android Studio.</p>
<h2><a class="header" href="#using-experimental-unsigned-types" id="using-experimental-unsigned-types">Using experimental unsigned types</a></h2>
<p>Unsigned integers in the defined API are translated to their equivalents in the foreign language binding, e.g. <code>u32</code> becomes Kotlin's <code>UInt</code> type.
See <a href="kotlin/../udl/builtin_types.html">Built-in types</a>.</p>
<p>However unsigned integer types are experimental in Kotlin versions prior to 1.5.
As such they require explicit annotations to suppress warnings.
Uniffi is trying to add these annotations where necessary,
but currently misses some places, see <a href="https://github.com/mozilla/uniffi-rs/pull/977">PR #977</a> for details.</p>
<p>To suppress all warnings for experimental unsigned types add this to your project's <code>build.gradle</code> file:</p>
<pre><code class="language-groovy">allprojects {
   tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
        kotlinOptions {
            freeCompilerArgs += [
                &quot;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&quot;,
            ]
        }
    }
}
</code></pre>
<h1><a class="header" href="#swift-bindings" id="swift-bindings">Swift Bindings</a></h1>
<p>UniFFI ships with production-quality support for generating Swift bindings.
Concepts from the UDL file map into Swift as follows:</p>
<ul>
<li>Primitive datatypes map to their obvious Swift counterpart, e.g. <code>u32</code> becomes <code>UInt32</code>,
<code>string</code> becomes <code>String</code>, etc.</li>
<li>An object interface declared as <code>interface T</code> is represented as a Swift <code>protocol TProtocol</code>
and a concrete Swift <code>class T</code> that conforms to it. Having the protocol declared explicitly
can be useful for mocking instances of the class in unittests.</li>
<li>A dictionary struct declared as <code>dictionary T</code> is represented as a Swift <code>struct T</code>
with public mutable fields.</li>
<li>An enum declared <code>enum T</code> or <code>[Enum] interface T</code> is represented as a Swift
<code>enum T</code> with appropriate variants.</li>
<li>Optional types are represented using Swift's builtin optional type syntax <code>T?</code>.</li>
<li>Sequences are represented as Swift arrays, and Maps as Swift dictionaries.</li>
<li>Errors are represented as Swift enums that conform to the <code>Error</code> protocol.</li>
<li>Function calls that have an associated error type are marked with <code>throws</code>,
and hence must be called using one of Swift's <code>try</code> syntax variants.</li>
<li>Failing assertions, Rust panics, and other unexpected errors in the generated code
are translated into a private enum conforming to the <code>Error</code> protocol.
<ul>
<li>If this happens inside a throwing Swift function, it can be caught and handled
by a catch-all <code>catch</code> statement (but do so at your own risk, because it indicates
that something has gone seriously wrong).</li>
<li>If this happens inside a non-throwing Swift function, it will be converted
into a fatal Swift error that cannot be caught.</li>
</ul>
</li>
</ul>
<p>Conceptually, the generated bindings are split into two Swift modules, one for the low-level
C FFI layer and one for the higher-level Swift bindings. For a UniFFI component named &quot;example&quot;
we generate:</p>
<ul>
<li>A C header file <code>exampleFFI.h</code> declaring the low-level structs and functions for calling
into Rust, along with a corresponding <code>exampleFFI.modulemap</code> to expose them to Swift.</li>
<li>A Swift source file <code>example.swift</code> that imports the <code>exampleFFI</code> module and wraps it
to provide the higher-level Swift API.</li>
</ul>
<p>Splitting up the bindings in this way gives you flexibility over how both the Rust code
and the Swift code are distributed to consumers. For example, you may choose to compile
and distribute the Rust code for several UniFFI components as a single shared library
in order to reduce the compiled code size, while distributing their Swift wrappers as
individual modules.</p>
<p>For more technical details on how the bindings work internally, please see the
<a href="swift/./api/uniffi_bindgen/bindings/swift/index.html">module documentation</a></p>
<h1><a class="header" href="#compiling-a-swift-module" id="compiling-a-swift-module">Compiling a Swift module</a></h1>
<p>Before you can import the generated Swift bindings as a module (say, to use them
from your application, or to try them out using <code>swift</code> on the command-line) you
first need to compile them into a Swift module.</p>
<p>To do so, you'll need both the generated <code>.swift</code> file and the corresponding
<code>.modulemap</code> file, which tells Swift how to expose the underlying C FFI layer.
Use <code>swiftc</code> to combine the cdylib from your Rust crate with the generated
Swift bindings:</p>
<pre><code>swiftc
    -module-name example                         # Name for resulting Swift module
    -emit-library -o libexample.dylib            # File to link with if using Swift REPL
    -emit-module -emit-module-path ./            # Output directory for resulting module
    -parse-as-library
    -L ./target/debug/                           # Directory containing compiled Rust crate
    -lexample                                    # Name of compiled Rust crate cdylib
    -Xcc -fmodule-map-file=exampleFFI.modulemap  # The modulemap file from above
    example.swift                                # The generated bindings file
</code></pre>
<p>This will produce an <code>example.swiftmodule</code> file that can be loaded by
other Swift code or used from the Swift command-line REPL.</p>
<h1><a class="header" href="#integrating-with-xcode" id="integrating-with-xcode">Integrating with XCode</a></h1>
<p>It is possible to generate Swift bindings at compile time for XCode projects
and incorporate them alongside hand-written Swift code to form a larger module.
Broadly, you will need to:</p>
<ol>
<li>Add a build phase to compile the Rust crate into a static lib and link it
into your framework.</li>
<li>Add a build phase to run <code>uniffi-bindgen </code> and generate the Swift bindings.</li>
<li>Include the generated bridging header into your overall bridging header.</li>
</ol>
<p>There is also an example app in the UniFFI project repo that may be helpful.</p>
<h2><a class="header" href="#compiling-the-rust-crate" id="compiling-the-rust-crate">Compiling the Rust crate.</a></h2>
<p>Sorry, configuring XCode to compile the Rust crate into a staticlib
is beyond the scope of this document. However you do so, make sure you
include the resulting <code>libexample.a</code> file in the &quot;Link Binary with Libraries&quot;
build phase for your framework.</p>
<p>This repository contains an example iOS app (at <code>./examples/app/ios</code>) which
may be useful for reference. It contains an <code>xc-universal-binary.sh</code> shell
script which can invoke <code>cargo</code> with the necessary settings to produce a
static library of Rust code.</p>
<h2><a class="header" href="#generating-the-bindings" id="generating-the-bindings">Generating the bindings</a></h2>
<p>In the &quot;Build Rules&quot; section of your config, add a rule to process <code>.udl</code> files
using <code>uniffi-bindgen</code>. We recommend having it generate the output files
somewhere in your source tree, rather than in XCode's default <code>$DERIVED_FILE_DIR</code>;
this both helps with debugging the build output, and makes it easier to configure
how the generated files are used.</p>
<ul>
<li>Add a build rule processing files with names matching <code>*.udl</code>.
<ul>
<li>Use something like the following as the custom script:
<ul>
<li><code>$HOME/.cargo/bin/uniffi-bindgen generate $INPUT_FILE_PATH --language swift --out-dir $INPUT_FILE_DIR/Generated</code></li>
</ul>
</li>
<li>Add both the <code>.swift</code> file and the generated bridging header as output files:
<ul>
<li><code>$(INPUT_FILE_DIR)/Generated/$(INPUT_FILE_BASE).swift</code></li>
<li><code>$(INPUT_FILE_DIR)/Generated/$(INPUT_FILE_BASE)FFI.h</code></li>
</ul>
</li>
</ul>
</li>
<li>Add your <code>.udl</code> file to the &quot;Compile Sources&quot; build phase for your framework,
so that XCode will process it using the new build rule and will include the resulting
outputs in the build.</li>
</ul>
<p>You do <em>not</em> need to add the generated Swift code to the list of &quot;Compile Sources&quot;
and should not attempt to compile it explicitly; XCode will figure out what it
needs to do with this code based on it being generated from the Build Rule for
your .udl file.</p>
<h2><a class="header" href="#including-the-bridging-header" id="including-the-bridging-header">Including the bridging header</a></h2>
<p>In the overall bridging header for your module, include the header file
generated by UniFFI in the previous step:</p>
<pre><code>#include &quot;exampleFFI.h&quot;
</code></pre>
<p>For this to work without complaint from XCode, you also need to add the
generated header file as a <strong>Public</strong> header in the &quot;Headers&quot; build phase
of your project (which is why it's useful to generate this file somewhere in
your source tree, rather than in a temporary build directory).</p>
<h1><a class="header" href="#navigating-the-code" id="navigating-the-code">Navigating the code</a></h1>
<p>The code for UniFFI is organized into the following crates:</p>
<ul>
<li><strong><a href="internals/./api/uniffi_bindgen/index.html"><code>./uniffi_bindgen</code></a>:</strong> This is the source for the <code>uniffi-bindgen</code> executable and is where
most of the logic for the UniFFI tool lives. Its contents include:
<ul>
<li><strong><a href="internals/./api/uniffi_bindgen/interface/index.html"><code>./uniffi_bindgen/src/interface/</code></a>:</strong> The logic for parsing <code>.udl</code> files
into an in-memory representation called <a href="internals/./api/uniffi_bindgen/interface/struct.ComponentInterface.html"><code>ComponentInterface</code></a>,
from which we can generate code for different languages.</li>
<li><strong><a href="internals/./api/uniffi_bindgen/scaffolding/index.html"><code>./uniffi_bindgen/src/scaffolding</code></a>:</strong> This module turns a
<a href="internals/./api/uniffi_bindgen/interface/struct.ComponentInterface.html"><code>ComponentInterface</code></a> into <em>Rust scaffolding</em>, the code that
wraps the user-provided Rust code and exposes it via a C-compatible FFI layer.</li>
<li><strong><a href="internals/./api/uniffi_bindgen/bindings/index.html"><code>./uniffi_bindgen/src/bindings/</code></a>:</strong> This module turns a
<a href="internals/./api/uniffi_bindgen/interface/struct.ComponentInterface.html"><code>ComponentInterface</code></a> into <em>foreign-language bindings</em>,
the code that can load the FFI layer exposed by the scaffolding and expose it as a
higher-level API in a target language. There is a sub-module for each supported language.</li>
</ul>
</li>
<li><strong><a href="internals/./api/uniffi/index.html"><code>./uniffi</code></a>:</strong> This is a run-time support crate that is used by the generated Rust scaffolding. It
controls how values of various types are passed back-and-forth over the FFI layer, by means of the
<a href="internals/./api/uniffi/trait.ViaFfi.html"><code>ViaFfi</code></a> trait.</li>
<li><strong><a href="internals/./api/uniffi_build/index.html"><code>./uniffi_build</code></a>:</strong> This is a small hook to run <code>uniffi-bindgen</code> from the <code>build.rs</code> script
of a UniFFI component, in order to automatically generate the Rust scaffolding as part of its build process.</li>
<li><strong><a href="internals/./api/uniffi_macros/index.html"><code>./uniffi_macros</code></a>:</strong> This contains some helper macros that UniFFI components can use to
simplify loading the generated scaffolding, and executing foreign-language tests.</li>
<li><strong><a href="https://github.com/mozilla/uniffi-rs/tree/main/examples"><code>./examples</code></a>:</strong>
This contains code examples that you can use to explore the code generation
process.</li>
</ul>
<h1><a class="header" href="#lifting-lowering-and-serialization" id="lifting-lowering-and-serialization">Lifting, Lowering and Serialization</a></h1>
<p>UniFFI is able to transfer rich data types back-and-forth between the Rust
code and the foreign-language code via a process we refer to as &quot;lowering&quot;
and &quot;lifting&quot;.</p>
<p>Recall that UniFFI interoperates between different languages by defining
a C-style FFI layer which operates in terms of primitive data types and
plain functions. To transfer data from one side of this layer to the other,
the sending side &quot;<em><strong>lowers</strong></em>&quot; the data from a language-specific data type
into one of the primitive types supported by the FFI-layer functions, and the
receiving side &quot;<em><strong>lifts</strong></em>&quot; that primitive type into its own language-specific
data type.</p>
<p>Lifting and lowering simple types such as integers is done by directly casting the
value to and from an appropriate type. For complex types such as optionals and
records we currently implement lifting and lowering by serializing into a byte
buffer, but this is an implementation detail that may change in future. (See
<a href="internals//docs/adr/0002-serialize-complex-datatypes.html">ADR-0002</a> for the reasoning
behind this choice).</p>
<p>As a concrete example, consider this interface for accumulating a list of integers:</p>
<pre><code class="language-idl">namespace example {
  sequence&lt;i32&gt; add_to_list(i32 item);
}
</code></pre>
<p>Calling this function from foreign language code involves the following steps:</p>
<ol>
<li>The user-provided calling code invokes the <code>add_to_list</code> function that is exposed by the
UniFFI-generated foreign language bindings, passing <code>item</code> as an appropriate language-native
integer.</li>
<li>The foreign language bindings <em><strong>lower</strong></em> each argument to a function call into
something that can be passed over the C-style FFI. Since the <code>item</code> argument is a plain integer,
it is lowered by casting to an <code>int32_t</code>.</li>
<li>The foreign language bindings pass the lowered arguments to a C FFI function named
like <code>example_XYZ_add_to_list</code> that is exposed by the UniFFI-generated Rust scaffolding.</li>
<li>The Rust scaffolding <em><strong>lifts</strong></em> each argument received over the FFI into a native
Rust type. Since <code>item</code> is a plain integer it is lifted by casting to a Rust <code>i32</code>.</li>
<li>The Rust scaffolding passes the lifted arguments to the user-provided Rust code for
the <code>add_to_list</code> function, which returns a <code>Vec&lt;i32&gt;</code>.</li>
<li>The Rust scaffolding now needs to <em><strong>lower</strong></em> the return value in order to pass it back
to the foreign language code. Since this is a complex data type, it is lowered by serializing
the values into a byte buffer and returning the buffer pointer and length from the
FFI function.</li>
<li>The foreign language bindings receive the return value and need to <em><strong>lift</strong></em> it into an
appropriate native data type. Since it is a complex data type, it is lifted by deserializing
from the returned byte buffer into a language-native list of integers.</li>
</ol>
<h2><a class="header" href="#lowered-types" id="lowered-types">Lowered Types</a></h2>
<table><thead><tr><th>UDL Type</th><th>Representation in the C FFI</th></tr></thead><tbody>
<tr><td><code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code></td><td><code>int8_t</code>/<code>int16_t</code>/<code>int32_t</code>/<code>int64_t</code></td></tr>
<tr><td><code>u8</code>/<code>u16</code>/<code>u32</code>/<code>u64</code></td><td><code>uint8_t</code>/<code>uint16_t</code>/<code>uint32_t</code>/<code>uint64_t</code></td></tr>
<tr><td><code>f32</code>/<code>float</code></td><td><code>float</code></td></tr>
<tr><td><code>f64</code>/<code>double</code></td><td><code>double</code></td></tr>
<tr><td><code>boolean</code></td><td><code>int8_t</code>, either <code>0</code> or <code>1</code></td></tr>
<tr><td><code>string</code></td><td><code>RustBuffer</code> struct pointing to utf8 bytes</td></tr>
<tr><td><code>timestamp</code></td><td><code>RustBuffer</code> struct pointing to a i64 representing seconds and a u32 representing nanoseconds</td></tr>
<tr><td><code>duration</code></td><td><code>RustBuffer</code> struct pointing to a u64 representing seconds and a u32 representing nanoseconds</td></tr>
<tr><td><code>T?</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>sequence&lt;T&gt;</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>record&lt;DOMString, T&gt;</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>enum</code> and <code>[Enum] interface</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>dictionary</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>interface</code></td><td><code>void*</code> opaque pointer to object on the heap</td></tr>
</tbody></table>
<h2><a class="header" href="#serialization-format" id="serialization-format">Serialization Format</a></h2>
<p>When serializing complex data types into a byte buffer, UniFFI uses an
ad-hoc fixed-width format which is designed mainly for simplicity.
The details of this format are internal only and may change between versions of UniFFI.</p>
<table><thead><tr><th>UDL Type</th><th>Representation in serialized bytes</th></tr></thead><tbody>
<tr><td><code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code></td><td>Fixed-width 1/2/4/8-byte signed integer, big-endian</td></tr>
<tr><td><code>u8</code>/<code>u16</code>/<code>u32</code>/<code>u64</code></td><td>Fixed-width 1/2/4/8-byte unsigned integer, big-endian</td></tr>
<tr><td><code>f32</code>/<code>float</code></td><td>Fixed-width 4-byte float, big-endian</td></tr>
<tr><td><code>f64</code>/<code>double</code></td><td>Fixed-width 8-byte double, big-endian</td></tr>
<tr><td><code>boolean</code></td><td>Fixed-width 1-byte signed integer, either <code>0</code> or <code>1</code></td></tr>
<tr><td><code>string</code></td><td>Serialized <code>i32</code> length followed by utf-8 string bytes; no trailing null</td></tr>
<tr><td><code>T?</code></td><td>If null, serialized <code>boolean</code> false; if non-null, serialized <code>boolean</code> true followed by serialized <code>T</code></td></tr>
<tr><td><code>sequence&lt;T&gt;</code></td><td>Serialized <code>i32</code> item count followed by serialized items; each item is a serialized <code>T</code></td></tr>
<tr><td><code>record&lt;DOMString, T&gt;</code></td><td>Serialized <code>i32</code> item count followed by serialized items; each item is a serialized <code>string</code> followed by a serialized <code>T</code></td></tr>
<tr><td><code>enum</code> and <code>[Enum] interface</code></td><td>Serialized <code>i32</code> indicating variant, numbered in declaration order starting from 1, followed by the serialized values of the variant's fields in declaration order</td></tr>
<tr><td><code>dictionary</code></td><td>The serialized value of each field, in declaration order</td></tr>
<tr><td><code>interface</code></td><td>Fixed-width 8-byte unsigned integer encoding a pointer to the object on the heap</td></tr>
</tbody></table>
<p>Note that length fields in this format are serialized as <em>signed</em> integers
despite the fact that they will always be non-negative. This is to help
ease compatibility with JVM-based languages since the JVM uses signed 32-bit
integers for its size fields internally.</p>
<h1><a class="header" href="#managing-object-references" id="managing-object-references">Managing Object References</a></h1>
<p>UniFFI <a href="internals/../udl/interfaces.html">interfaces</a> represent instances of objects
that have methods and contain state. One of Rust's core innovations
is its ability to provide compile-time guarantees about working with such instances,
including:</p>
<ul>
<li>Ensuring that each instance has a unique owner responsible for disposing of it.</li>
<li>Ensuring that there is only a single writer <em>or</em> multiple readers of an object
active at any point in the program.</li>
<li>Guarding against data races.</li>
</ul>
<p>The very nature of the problems UniFFI tries to solve is that calls may come
from foreign languages on any thread, outside of the control of Rust's ownership
system. UniFFI itself tries to take a hands-off approach as much as possible and
depends on the Rust compiler itself to uphold safety guarantees, without assuming
that foreign-language callers will be &quot;well behaved&quot;.</p>
<h2><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h2>
<p>UniFFI's hands-off approach means that all object instances exposed by UniFFI must be safe to
access concurrently. In Rust terminology, they must be <code>Send+Sync</code> and must be useable
without taking any <code>&amp;mut</code> references.</p>
<p>Typically this will mean that the Rust implementation of an object uses some of Rust's
data structures for thread-safe interior mutability, such as a <code>Mutex</code> or <code>RwLock</code> or
the types from <code>std::atomic</code>. The precise details are completely up to the author
of the component - as much as possible, UniFFI tries to stay out of your way, simply requiring
that the object implementation is <code>Send+Sync</code> and letting the Rust compiler ensure that
this is so.</p>
<h2><a class="header" href="#lifetimes" id="lifetimes">Lifetimes</a></h2>
<p>In order to allow for instances to be used as flexibly as possible from foreign-language code,
UniFFI wraps all object instances in an <code>Arc</code> and leverages their reference-count based lifetimes,
allowing UniFFI to largely stay out of handling lifetimes entirely for these objects.</p>
<p>When constructing a new object, UniFFI is able to add the <code>Arc</code> automatically, because it
knows that the return type of the Rust constructor must be a new uniquely-owned struct of
the corresponding type.</p>
<p>When you want to return object instances from functions or methods, or store object instances
as fields in records, the underlying Rust code will need to work with <code>Arc&lt;T&gt;</code> directly, to ensure
that the code behaves in the way that UniFFI expects.</p>
<p>When accepting instances as arguments, the underlying Rust code can choose to accept it as an <code>Arc&lt;T&gt;</code>
or as the underlying struct <code>T</code>, as there are different use-cases for each scenario.</p>
<p>For example, given a interface definition like this:</p>
<pre><code class="language-idl">interface TodoList {
    constructor();
    void add_item(string todo);
    sequence&lt;string&gt; get_items();
};
</code></pre>
<p>On the Rust side of the generated bindings, the instance constructor will create an instance of the
corresponding <code>TodoList</code> Rust struct, wrap it in an <code>Arc&lt;&gt;</code> and return the Arc's raw pointer to the
foreign language code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; fn todolist_12ba_TodoList_new(
    err: &amp;mut uniffi::deps::ffi_support::ExternError,
) -&gt; *const std::os::raw::c_void /* *const TodoList */ {
    uniffi::deps::ffi_support::call_with_output(err, || {
        let _new = TodoList::new();
        let _arc = std::sync::Arc::new(_new);
        &lt;std::sync::Arc&lt;TodoList&gt; as uniffi::ViaFfi&gt;::lower(_arc)
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>The UniFFI runtime implements lowering for object instances using <code>Arc::into_raw</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;T: Sync + Send&gt; ViaFfi for std::sync::Arc&lt;T&gt; {
    type FfiType = *const std::os::raw::c_void;
    fn lower(self) -&gt; Self::FfiType {
        std::sync::Arc::into_raw(self) as Self::FfiType
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>which does the &quot;arc to pointer&quot; dance for us. Note that this has &quot;leaked&quot; the
<code>Arc&lt;&gt;</code> reference out of Rusts ownership system and given it to the foreign-language code.
The foreign-language code must pass that pointer back into Rust in order to free it,
or our instance will leak.</p>
<p>When invoking a method on the instance, the foreign-language code passes the
raw pointer back to the Rust code, conceptually passing a &quot;borrow&quot; of the <code>Arc&lt;&gt;</code> to
the Rust scaffolding. The Rust side turns it back into a cloned <code>Arc&lt;&gt;</code> which
lives for the duration of the method call:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; fn todolist_12ba_TodoList_add_item(
    ptr: *const std::os::raw::c_void,
    todo: uniffi::RustBuffer,
    err: &amp;mut uniffi::deps::ffi_support::ExternError,
) -&gt; () {
    uniffi::deps::ffi_support::call_with_result(err, || -&gt; Result&lt;_, TodoError&gt; {
        let _retval = TodoList::add_item(
          &amp;&lt;std::sync::Arc&lt;TodoList&gt; as uniffi::ViaFfi&gt;::try_lift(ptr).unwrap(),
          &lt;String as uniffi::ViaFfi&gt;::try_lift(todo).unwrap())?,
        )
        Ok(_retval)
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>The UniFFI runtime implements lifting for object instances using <code>Arc::from_raw</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;T: Sync + Send&gt; ViaFfi for std::sync::Arc&lt;T&gt; {
    type FfiType = *const std::os::raw::c_void;
    fn try_lift(v: Self::FfiType) -&gt; Result&lt;Self&gt; {
        let v = v as *const T;
        // We musn't drop the `Arc&lt;T&gt;` that is owned by the foreign-language code.
        let foreign_arc = std::mem::ManuallyDrop::new(unsafe { Self::from_raw(v) });
        // Take a clone for our own use.
        Ok(std::sync::Arc::clone(&amp;*foreign_arc))
    }
<span class="boring">}
</span></code></pre></pre>
<p>Notice that we take care to ensure the reference that is owned by the foreign-language
code remains alive.</p>
<p>Finally, when the foreign-language code frees the instance, it
passes the raw pointer a special destructor function so that the Rust code can
drop that initial reference (and if that happens to be the final reference,
the Rust object will be dropped.)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; fn ffi_todolist_12ba_TodoList_object_free(ptr: *const std::os::raw::c_void) {
    if let Err(e) = std::panic::catch_unwind(|| {
        assert!(!ptr.is_null());
        unsafe { std::sync::Arc::from_raw(ptr as *const TodoList) };
    }) {
        uniffi::deps::log::error!(&quot;ffi_todolist_12ba_TodoList_object_free panicked: {:?}&quot;, e);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Passing instances as arguments and returning them as values works similarly, except that
UniFFI does not automatically wrap/unwrap the containing <code>Arc</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
