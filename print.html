<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The uniffi user guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Overview.html">Overview</a></li><li class="chapter-item expanded "><a href="Getting_started.html"><strong aria-hidden="true">1.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/Prerequisites.html"><strong aria-hidden="true">1.1.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="tutorial/udl_file.html"><strong aria-hidden="true">1.2.</strong> Describing the interface</a></li><li class="chapter-item expanded "><a href="tutorial/Rust_scaffolding.html"><strong aria-hidden="true">1.3.</strong> Generating the Rust scaffolding code</a></li><li class="chapter-item expanded "><a href="tutorial/foreign_language_bindings.html"><strong aria-hidden="true">1.4.</strong> Generating the foreign-language bindings</a></li></ol></li><li class="chapter-item expanded "><a href="udl_file_spec.html"><strong aria-hidden="true">2.</strong> The UDL file</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="udl/namespace.html"><strong aria-hidden="true">2.1.</strong> Namespace</a></li><li class="chapter-item expanded "><a href="udl/builtin_types.html"><strong aria-hidden="true">2.2.</strong> Built-in types</a></li><li class="chapter-item expanded "><a href="udl/enumerations.html"><strong aria-hidden="true">2.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="udl/structs.html"><strong aria-hidden="true">2.4.</strong> Structs/Dictionaries</a></li><li class="chapter-item expanded "><a href="udl/functions.html"><strong aria-hidden="true">2.5.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="udl/errors.html"><strong aria-hidden="true">2.5.1.</strong> Throwing errors</a></li></ol></li><li class="chapter-item expanded "><a href="udl/interfaces.html"><strong aria-hidden="true">2.6.</strong> Interfaces/Objects</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Kotlin</li><li class="chapter-item expanded "><a href="kotlin/gradle.html"><strong aria-hidden="true">3.</strong> Integrating with Gradle</a></li><li class="chapter-item expanded affix "><li class="part-title">Swift</li><li class="chapter-item expanded "><a href="swift/xcode.html"><strong aria-hidden="true">4.</strong> Integrating with XCode</a></li><li class="chapter-item expanded affix "><li class="part-title">Internals</li><li class="chapter-item expanded "><a href="internals/lifting_and_lowering.html"><strong aria-hidden="true">5.</strong> Lifting, Lowering, and Serialization</a></li><li class="chapter-item expanded "><a href="internals/object_references.html"><strong aria-hidden="true">6.</strong> Managing object references</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The uniffi user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#uniffi" id="uniffi">uniffi</a></h1>
<p>Uniffi is a tool that automatically generates foreign-language bindings targeting Rust libraries.<br />
It fits in the practice of consolidating business logic in a single Rust library while targeting multiple platforms, making it simpler to develop and maintain a cross-platform codebase.<br />
Note that this tool will not help you ship a Rust library to these platforms, but simply not have to write bindings code by hand <a href="https://i.kym-cdn.com/photos/images/newsfeed/000/572/078/d6d.jpg">[0]</a>.</p>
<h2><a class="header" href="#design" id="design">Design</a></h2>
<p>uniffi requires to write an Interface Definition Language (based on <a href="https://heycam.github.io/webidl/">WebIDL</a>) file describing the methods and data structures available to the targeted languages.<br />
This .udl (Uniffi Definition Language) file, whose definitions must match with the exposed Rust code, is then used to generate Rust <em>scaffolding</em> code and foreign-languages <em>bindings</em>. This process can take place either during the build process or be manually initiated by the developer.</p>
<p><img src="./uniffi_diagram.png" alt="uniffi diagram" /></p>
<h2><a class="header" href="#supported-languages" id="supported-languages">Supported languages</a></h2>
<ul>
<li>Kotlin</li>
<li>Swift</li>
<li>Python</li>
<li><a href="https://en.wikipedia.org/wiki/Gecko_(software)">Gecko</a> C++</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<p>Say your company has a simple <code>math</code> crate with the following <code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: u32, b: u32) -&gt; u32 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>And top brass would like you to expose this <em>business-critical</em> operation to Kotlin and Swift.<br />
<strong>Don't panic!</strong> We will show you how do that using uniffi.</p>
<h1><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h1>
<h2><a class="header" href="#the-uniffi-bindgen-cli-tool" id="the-uniffi-bindgen-cli-tool">The uniffi-bindgen cli tool</a></h2>
<p>Install the <code>uniffi-bindgen</code> binary on your system using:</p>
<p><code>cargo install uniffi_bindgen</code></p>
<p>You can see what it can do with <code>uniffi-bindgen --help</code>, but let's leave it aside for now.</p>
<h2><a class="header" href="#build-your-crate-as-a-cdylib" id="build-your-crate-as-a-cdylib">Build your crate as a cdylib</a></h2>
<p>Ensure your crate builds as a <code>cdylib</code> by adding</p>
<pre><code class="language-toml">crate-type = [&quot;cdylib&quot;]
name = &quot;&lt;library name&gt;&quot;
</code></pre>
<p>to your crate's <code>Cargo.toml</code>.</p>
<h1><a class="header" href="#the-udl-file" id="the-udl-file">The UDL file</a></h1>
<p>We describe in a UDL (a type of IDL, Interface Definition Language) file <em>what</em> is exposed and available to foreign-language bindings. In this case, we are only playing with primitive types (<code>u32</code>) and not custom data structures but we still want to expose the <code>add</code> method.<br />
Let's create a <code>math.udl</code> file in the <code>math</code> crate's <code>src/</code> folder:</p>
<pre><code class="language-idl">namespace math {
  u32 add(u32 a, u32 b);
};
</code></pre>
<p>Here you can note multiple things:</p>
<ul>
<li>The <code>namespace</code> directive: it will be the name of your Kotlin/Swift package. It <strong>must</strong> be present in any udl file, even if there ain't any exposed function (e.g. <code>namespace foo {}</code>).</li>
<li>The <code>add</code> function is in the <code>namespace</code> block. That's because on the Rust side it is a top-level <em>function</em>, we will see later how to to handle <em>methods</em>.</li>
<li>Rust's <code>u32</code> is also UDL's <code>u32</code>, but it is not always true! (TODO table correspondance)</li>
</ul>
<p><strong>Note:</strong> If any of the things you expose in the <code>udl</code> file do not have an equivalent in your Rust crate, you will get a hard error. Try changing the <code>u32</code> result type to <code>u64</code> and see what happens!</p>
<h1><a class="header" href="#rust-scaffolding" id="rust-scaffolding">Rust scaffolding</a></h1>
<h2><a class="header" href="#rust-scaffolding-code" id="rust-scaffolding-code">Rust scaffolding code</a></h2>
<p>Now we generate some Rust helper code to make the <code>add</code> method available to foreign-language bindings.</p>
<p>First, add <code>uniffi</code> to your crate dependencies: it is the runtime support code that powers uniffi's serialization of data types across languages:</p>
<pre><code class="language-toml">[dependencies]
uniffi = &quot;0.5&quot;
</code></pre>
<p>Important note: the <code>uniffi</code> version must be the same as the <code>uniffi-bindgen</code> command-line tool installed on your system.</p>
<p>Then let's add <code>uniffi_build</code> to your build dependencies: it generates the Rust scaffolding code that exposes our Rust functions as a C-compatible FFI layer.</p>
<pre><code class="language-toml">[build-dependencies]
uniffi_build = &quot;0.5&quot;
</code></pre>
<p>Then create a <code>build.rs</code> file next to <code>Cargo.toml</code> that will use <code>uniffi_build</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    uniffi_build::generate_scaffolding(&quot;./src/math.udl&quot;).unwrap();
}
</code></pre></pre>
<p><strong>Note:</strong> This is the equivalent of calling (and does it under the hood) <code>uniffi-bindgen scaffolding src/math.udl --out-dir &lt;OUT_DIR&gt;</code>.</p>
<p>Lastly, we include the generated scaffolding code in our <code>lib.rs</code>. If you've used the default build
settings then this can be done using a handy macro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>uniffi_macros::include_scaffolding!(&quot;math&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>If you have generated the scaffolding in a custom location, use the standard <code>!include</code> macro
to include the generated file by name, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/math.uniffi.rs&quot;));
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note:</strong> The file name is always <code>&lt;namespace&gt;.uniffi.rs</code>.</p>
<p>Great! <code>add</code> is ready to see the outside world!</p>
<h1><a class="header" href="#foreign-language-bindings" id="foreign-language-bindings">Foreign-language bindings</a></h1>
<p>As stated in the <a href="tutorial/../Overview.html">Overview</a>, this library and tutorial does not cover <em>how</em> to ship a Rust library on mobile, but how to generate bindings for it, so this section will only cover that.</p>
<h2><a class="header" href="#kotlin" id="kotlin">Kotlin</a></h2>
<p>Run</p>
<pre><code>uniffi-bindgen generate src/math.udl --language kotlin
</code></pre>
<p>then have a look at <code>src/uniffi/math/math.kt</code></p>
<h2><a class="header" href="#swift" id="swift">Swift</a></h2>
<p>Run</p>
<pre><code>uniffi-bindgen generate src/math.udl --language swift
</code></pre>
<p>then check out <code>src/math.swift</code></p>
<p>Note that these commands could be integrated as part of your gradle/XCode build process.</p>
<p>This is it, you have an MVP integration of uniffi in your project.</p>
<h1><a class="header" href="#the-udl-file-1" id="the-udl-file-1">The UDL file</a></h1>
<p>This file defines which functions, methods and types are exposed to the foreign-language bindings.</p>
<pre><code class="language-udl">namespace sprites {
  Point translate([ByRef] Point position, Vector direction);
};

dictionary Point {
  double x;
  double y;
};

dictionary Vector {
  double dx;
  double dy;
};

interface Sprite {
  constructor(Point? initial_position);
  Point get_position();
  void move_to(Point position);
  void move_by(Vector direction);
};
</code></pre>
<h1><a class="header" href="#namespace" id="namespace">Namespace</a></h1>
<p>Every UDL file <em>must</em> have a <code>namespace</code> block:</p>
<pre><code class="language-idl">namespace math {
  double exp(double a);
};
</code></pre>
<p>It serves multiple purposes:</p>
<ul>
<li>It identifies the name of the generated Rust scaffolding file <code>&lt;namespace&gt;.uniffi.rs</code>.</li>
<li>It identifies the package name of the generated foreign-language bindings (e.g. <code>uniffi.&lt;namespace&gt;</code> in Kotlin)</li>
<li>It also contains all <a href="udl/./functions.html">top-level <em>functions</em></a> that get exposed to foreign-language bindings.</li>
</ul>
<h1><a class="header" href="#built-in-types" id="built-in-types">Built-in types</a></h1>
<p>The following built-in types can be passed as arguments/returned by Rust methods:</p>
<table><thead><tr><th>Rust type</th><th>UDL type</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>boolean</code></td><td></td></tr>
<tr><td><code>u8/i8..u64/i64</code></td><td><code>u8/i8..u64/i64</code></td><td></td></tr>
<tr><td><code>f32</code></td><td><code>float</code></td><td></td></tr>
<tr><td><code>f64</code></td><td><code>double</code></td><td></td></tr>
<tr><td><code>String</code></td><td><code>string</code></td><td></td></tr>
<tr><td><code>&amp;T</code></td><td><code>[ByRef] T</code></td><td>This works for <code>&amp;str</code> and <code>&amp;[T]</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td><code>T?</code></td><td></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>sequence&lt;T&gt;</code></td><td></td></tr>
<tr><td><code>HashMap&lt;String, T&gt;</code></td><td><code>record&lt;DOMString, T&gt;</code></td><td>Only string keys are supported</td></tr>
<tr><td><code>()</code></td><td><code>void</code></td><td>Empty return</td></tr>
<tr><td><code>Result&lt;T, E&gt;</code></td><td>N/A</td><td>See <a href="udl/./errors.html">Errors</a> section</td></tr>
</tbody></table>
<p>And of course you can use your own types, which is covered in the following sections.</p>
<h1><a class="header" href="#enumerations" id="enumerations">Enumerations</a></h1>
<p>An enumeration defined in Rust code as</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog,
    Cat,
}
<span class="boring">}
</span></code></pre></pre>
<p>Can be exposed in the UDL file with:</p>
<pre><code class="language-idl">enum Animal {
  &quot;Dog&quot;,
  &quot;Cat&quot;,
};
</code></pre>
<p>Enumerations with associated data require a different syntax,
due to the limitations of using WebIDL as the basis for UniFFI's interface language.
An enum like this in Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
  V4 {q1: u8, q2: u8, q3: u8, q4: u8},
  V6 {addr: string},
}
<span class="boring">}
</span></code></pre></pre>
<p>Can be exposed in the UDL file with:</p>
<pre><code class="language-idl">[Enum]
interface IpAddr {
  V4(u8 q1, u8 q2, u8 q3, u8 q4);
  V6(string addr);
};
</code></pre>
<p>Only enums with named fields are supported by this syntax.</p>
<h1><a class="header" href="#structsdictionaries" id="structsdictionaries">Structs/Dictionaries</a></h1>
<p>Dictionaries can be compared to POJOs in the Java world: just a data structure holding some data.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoEntry {
    done: bool,
    due_date: u64,
    text: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>can be converted in UDL to:</p>
<pre><code class="language-idl">dictionary TodoEntry {
    boolean done;
    u64 due_date;
    string text;
};

</code></pre>
<p>Dictionaries can contain each other and every other data type available, except objects.</p>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>All top-level <em>functions</em> get exposed through the UDL's <code>namespace</code> block.
For example, if the crate's <code>lib.rs</code> file contains:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_world() -&gt; String {
    &quot;Hello World!&quot;.to_owned()
}
<span class="boring">}
</span></code></pre></pre>
<p>The UDL file will look like:</p>
<pre><code class="language-idl">namespace Example {
    string hello_world();
}
</code></pre>
<h1><a class="header" href="#throwing-errors" id="throwing-errors">Throwing errors</a></h1>
<p>It is often the case that a function does not return <code>T</code> in Rust but <code>Result&lt;T, E&gt;</code> to reflect that it is fallible.<br />
For uniffi to expose this error, your error type (<code>E</code>) must be an <code>enum</code> and implement <code>std::error::Error</code> (<a href="https://crates.io/crates/thiserror">thiserror</a> works!).</p>
<p>Here's how you would write a Rust failible function and how you'd expose it in UDL:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
enum ArithmeticError {
    #[error(&quot;Integer overflow on an operation with {a} and {b}&quot;)]
    IntegerOverflow { a: u64, b: u64 },
}

fn add(a: u64, b: u64) -&gt; Result&lt;u64, ArithmeticError&gt; {
    a.checked_add(b).ok_or(ArithmeticError::IntegerOverflow { a, b })
}
<span class="boring">}
</span></code></pre></pre>
<p>And in UDL:</p>
<pre><code>[Error]
enum ArithmeticError {
  &quot;IntegerOverflow&quot;,
};


namespace arithmetic {
  [Throws=ArithmeticError]
  u64 add(u64 a, u64 b);
}
</code></pre>
<p>On the other side (Kotlin, Swift etc.), a proper exception will be thrown if <code>Result::is_err()</code> is <code>true</code>.</p>
<h1><a class="header" href="#interfacesobjects" id="interfacesobjects">Interfaces/Objects</a></h1>
<p>Interfaces are represented in the Rust world as a struct with an <code>impl</code> block containing methods. In the Kotlin or Swift world, it's a class.</p>
<p>Because Objects are passed by reference and Dictionaries by value, in the uniffi world it is impossible to be both an Object and a <a href="udl/./structs.html">Dictionary</a>.</p>
<p>The following Rust code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoList {
    items: Vec&lt;String&gt;
}

impl TodoList {
    fn new() -&gt; Self {
        TodoList {
            items: Vec::new()
        }
    }

    fn add_item(&amp;mut self, todo: String) {
        self.items.push(todo);
    }

    fn get_items(&amp;self) -&gt; Vec&lt;String&gt; {
        self.items.clone()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>would be exposed using:</p>
<pre><code class="language-idl">interface TodoList {
    constructor();
    void add_item(string todo);
    sequence&lt;string&gt; get_items();
};
</code></pre>
<p>By convention, the <code>constructor()</code> calls the Rust's <code>new()</code> method.</p>
<p>Conceptually, these <code>interface</code> objects are live Rust objects that have a proxy on the foreign language side; calling any methods on them, including a constructor or destructor results in the corresponding methods being call in Rust.</p>
<p><code>uniffi</code> will generate these proxies of live objects with an interface or protocol.</p>
<p>e.g. in Kotlin.</p>
<pre><code class="language-kotlin">interface TodoListInterface {
    fun addItem(todo: String)
    fun getItems(): List&lt;String&gt;
}

class TodoList : TodoListInterface {
   // implementations to call the Rust code.
}
</code></pre>
<p>When working with these objects, it may be helpful to always pass the interface or protocol, but construct the concrete implementation.</p>
<p>e.g. in Swift</p>
<pre><code class="language-swift">let todoList = TodoList()
todoList.addItem(todo: &quot;Write documentation&quot;)
display(list: todoList)

func display(list: TodoListProtocol) {
    let items = list.getItems()
    items.forEach {
        print($0)
    }
}
</code></pre>
<h2><a class="header" href="#alternate-named-constructors" id="alternate-named-constructors">Alternate Named Constructors</a></h2>
<p>In addition to the default constructor connected to the <code>::new()</code> method, you can specify
alternate named constructors to create object instances in different ways. Each such constructor
must be given an explicit name, provided in the UDL with the <code>[Name]</code> attribute like so:</p>
<pre><code class="language-idl">interface TodoList {
    // The default constructor makes an empty list.
    constructor();
    // This alternate constructor makes a new TodoList from a list of string items.
    [Name=new_from_items]
    constructor(sequence&lt;string&gt; items)
    ...
</code></pre>
<p>For each alternate constructor, UniFFI will expose an appropriate static-method, class-method or similar
in the foreign language binding, and will connect it to the Rust method of the same name on the underlying
Rust struct.</p>
<h2><a class="header" href="#concurrent-access" id="concurrent-access">Concurrent Access</a></h2>
<p>Since interfaces represent mutable data, uniffi has to take extra care
to uphold Rust's safety guarantees around shared and mutable references.
The foreign-language code may attempt to operate on an interface instance
from multiple threads, and it's important that this not violate Rust's
assumption that there is at most a single mutable reference to a struct
at any point in time.</p>
<p>By default, uniffi enforces this using runtime locking. Each interface instance
has an associated lock which is transparently acquired at the beginning of each
call to a method of that instance, and released once the method returns. This
approach is simple and safe, but it means that all method calls on an instance
are run in a strictly sequential fashion, limiting concurrency.</p>
<p>You can opt out of this protection by marking the interface as threadsafe:</p>
<pre><code class="language-idl">[Threadsafe]
interface Counter {
    constructor();
    void increment();
    u64 get();
};
</code></pre>
<p>The uniffi-generated code will allow concurrent method calls on threadsafe interfaces
without any locking.</p>
<p>For this to be safe, the underlying Rust struct must adhere to certain restrictions, and
uniffi's generated Rust scaffolding will emit compile-time errors if it does not.</p>
<p>The Rust struct must not expose any methods that take <code>&amp;mut self</code>. The following implementation
of the <code>Counter</code> interface will fail to compile because it relies on mutable references:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    value: u64
}

impl Counter {
    fn new() -&gt; Self {
        Self { value: 0 }
    }

    // No mutable references to self allowed in [Threadsafe] interfaces.
    fn increment(&amp;mut self) {
        self.value = self.value + 1;
    }

    fn get(&amp;self) -&gt; u64 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Implementations can instead use Rust's &quot;interior mutability&quot; pattern. However, they
must do so in a way that is both <code>Sync</code> and <code>Send</code>, since the foreign-language code
may operate on the instance from multiple threads. The following implementation of the
<code>Counter</code> interface will fail to compile because <code>RefCell</code> is not <code>Send</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    value: RefCell&lt;u64&gt;
}

impl Counter {
    fn new() -&gt; Self {
        // `RefCell` is not `Sync`, so neither is `Counter`.
        Self { value: RefCell::new(0) }
    }

    fn increment(&amp;self) {
        let mut value = self.value.borrow_mut();
        *value = *value + 1;
    }

    fn get(&amp;self) -&gt; u64 {
        *self.value.borrow()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This version uses an <code>AtomicU64</code> for interior mutability, which is both <code>Sync</code> and
<code>Send</code> and hence will compile successfully:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    value: AtomicU64
}

impl Counter {
    fn new() -&gt; Self {
        Self { value: AtomicU64::new(0) }
    }

    fn increment(&amp;self) {
        self.value.fetch_add(1, Ordering::SeqCst);
    }

    fn get(&amp;self) -&gt; u64 {
        self.value.load(Ordering::SeqCst)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can read more about the technical details in the docs on the
<a href="udl/../internals/object_references.html">internal details of managing object references</a>.</p>
<h1><a class="header" href="#integrating-with-gradle" id="integrating-with-gradle">Integrating with Gradle</a></h1>
<p>It is possible to generate Kotlin bindings at compile time for Kotlin Android projects. We'd like to make a gradle plugin for that, but until then you can add to your <code>build.gradle</code> the following:</p>
<pre><code class="language-groovy">android.libraryVariants.all { variant -&gt;
    def t = tasks.register(&quot;generate${variant.name.capitalize()}UniffiBindings&quot;, Exec) {
        workingDir &quot;${project.projectDir}&quot;
        // Runs the bindings generation, note that you must have uniffi-bindgen installed and in your PATH environment variable
        commandLine 'uniffi-bindgen', 'generate', '&lt;PATH TO .udl FILE&gt;', '--language', 'kotlin', '--out-dir', &quot;${buildDir}/generated/source/uniffi/${variant.name}/java&quot;
    }
    variant.javaCompileProvider.get().dependsOn(t)
    def sourceSet = variant.sourceSets.find { it.name == variant.name }
    sourceSet.java.srcDir new File(buildDir, &quot;generated/source/uniffi/${variant.name}/java&quot;)
    // XXX: I've been trying to make this work but I can't, so the compiled bindings will show as &quot;regular sources&quot; in Android Studio.
    idea.module.generatedSourceDirs += file(&quot;${buildDir}/generated/source/uniffi/${variant.name}/java/uniffi&quot;)
}
</code></pre>
<p>The generated bindings should appear in the project sources in Android Studio.</p>
<h1><a class="header" href="#integrating-with-xcode" id="integrating-with-xcode">Integrating with XCode</a></h1>
<p>It is possible to generate Swift bindings at compile time for XCode projects.
In your project configuration, add a &quot;Run Script Phase&quot; that applies to <code>*.udl</code> files:</p>
<pre><code class="language-bash">$HOME/.cargo/bin/uniffi-bindgen generate $INPUT_FILE_PATH --language swift --out-dir $DERIVED_FILE_DIR\n
</code></pre>
<h1><a class="header" href="#lifting-lowering-and-serialization" id="lifting-lowering-and-serialization">Lifting, Lowering and Serialization</a></h1>
<p>Uniffi is able to transfer rich data types back-and-forth between the Rust
code and the foreign-language code via a process we refer to as &quot;lowering&quot;
and &quot;lifting&quot;.</p>
<p>Recall that uniffi interoperates between different languages by defining
a C-style FFI layer which operates in terms of primitive data types and
plain functions. To transfer data from one side of this layer to the other,
the sending side &quot;<em><strong>lowers</strong></em>&quot; the data from a language-specific data type
into one of the primitive types supported by the FFI-layer functions, and the
receiving side &quot;<em><strong>lifts</strong></em>&quot; that primitive type into its own language-specific
data type.</p>
<p>Lifting and lowering simple types such as integers is done by directly casting the
value to and from an appropriate type. For complex types such as optionals and
records we currently implement lifting and lowering by serializing into a byte
buffer, but this is an implementation detail that may change in future. (See
<a href="internals//docs/adr/0002-serialize-complex-datatypes.html">ADR-0002</a> for the reasoning
behind this choice).</p>
<p>As a concrete example, consider this interface for accumulating a list of integers:</p>
<pre><code class="language-idl">namespace example {
  sequence&lt;i32&gt; add_to_list(i32 item);
}
</code></pre>
<p>Calling this function from foreign language code involves the following steps:</p>
<ol>
<li>The user-provided calling code invokes the <code>add_to_list</code> function that is exposed by the
uniffi-generated foreign language bindings, passing <code>item</code> as an appropriate language-native
integer.</li>
<li>The foreign language bindings <em><strong>lower</strong></em> each argument to a function call into
something that can be passed over the C-style FFI. Since the <code>item</code> argument is a plain integer,
it is lowered by casting to an <code>int32_t</code>.</li>
<li>The foreign language bindings pass the lowered arguments to a C FFI function named
like <code>example_XYZ_add_to_list</code> that is exposed by the uniffi-generated Rust scaffolding.</li>
<li>The Rust scaffolding <em><strong>lifts</strong></em> each argument received over the FFI into a native
Rust type. Since <code>item</code> is a plain integer it is lifted by casting to a Rust <code>i32</code>.</li>
<li>The Rust scaffolding passes the lifted arguments to the user-provided Rust code for
the <code>add_to_list</code> function, which returns a <code>Vec&lt;i32&gt;</code>.</li>
<li>The Rust scaffolding now needs to <em><strong>lower</strong></em> the return value in order to pass it back
to the foreign language code. Since this is a complex data type, it is lowered by serializing
the values into a byte buffer and returning the buffer pointer and length from the
FFI function.</li>
<li>The foreign language bindings receive the return value and need to <em><strong>lift</strong></em> it into an
appropriate native data type. Since it is a complex data type, it is lifted by deserializing
from the returned byte buffer into a language-native list of integers.</li>
</ol>
<h2><a class="header" href="#lowered-types" id="lowered-types">Lowered Types</a></h2>
<table><thead><tr><th>UDL Type</th><th>Representation in the C FFI</th></tr></thead><tbody>
<tr><td><code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code></td><td><code>int8_t</code>/<code>int16_t</code>/<code>int32_t</code>/<code>int64_t</code></td></tr>
<tr><td><code>u8</code>/<code>u16</code>/<code>u32</code>/<code>u64</code></td><td><code>uint8_t</code>/<code>uint16_t</code>/<code>uint32_t</code>/<code>uint64_t</code></td></tr>
<tr><td><code>f32</code>/<code>float</code></td><td><code>float</code></td></tr>
<tr><td><code>f64</code>/<code>double</code></td><td><code>double</code></td></tr>
<tr><td><code>boolean</code></td><td><code>int8_t</code>, either <code>0</code> or <code>1</code></td></tr>
<tr><td><code>string</code></td><td><code>RustBuffer</code> struct pointing to utf8 bytes</td></tr>
<tr><td><code>T?</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>sequence&lt;T&gt;</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>record&lt;DOMString, T&gt;</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>enum</code> and <code>[Enum] interface</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>dictionary</code></td><td><code>RustBuffer</code> struct pointing to serialized bytes</td></tr>
<tr><td><code>interface</code></td><td><code>uint64_t</code> opaque integer handle</td></tr>
</tbody></table>
<h2><a class="header" href="#serialization-format" id="serialization-format">Serialization Format</a></h2>
<p>When serializing complex data types into a byte buffer, uniffi uses an
ad-hoc fixed-width format which is designed mainly for simplicity.
The details of this format are internal only and may change between versions of uniffi.</p>
<table><thead><tr><th>UDL Type</th><th>Representation in serialized bytes</th></tr></thead><tbody>
<tr><td><code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code></td><td>Fixed-width 1/2/4/8-byte signed integer, big-endian</td></tr>
<tr><td><code>u8</code>/<code>u16</code>/<code>u32</code>/<code>u64</code></td><td>Fixed-width 1/2/4/8-byte unsigned integer, big-endian</td></tr>
<tr><td><code>f32</code>/<code>float</code></td><td>Fixed-width 4-byte float, big-endian</td></tr>
<tr><td><code>f64</code>/<code>double</code></td><td>Fixed-width 8-byte double, big-endian</td></tr>
<tr><td><code>boolean</code></td><td>Fixed-width 1-byte signed integer, either <code>0</code> or <code>1</code></td></tr>
<tr><td><code>string</code></td><td>Serialized <code>i32</code> length followed by utf-8 string bytes; no trailing null</td></tr>
<tr><td><code>T?</code></td><td>If null, serialized <code>boolean</code> false; if non-null, serialized <code>boolean</code> true followed by serialized <code>T</code></td></tr>
<tr><td><code>sequence&lt;T&gt;</code></td><td>Serialized <code>i32</code> item count followed by serialized items; each item is a serialized <code>T</code></td></tr>
<tr><td><code>record&lt;DOMString, T&gt;</code></td><td>Serialized <code>i32</code> item count followed by serialized items; each item is a serialized <code>string</code> followed by a serialized <code>T</code></td></tr>
<tr><td><code>enum</code> and <code>[Enum] interface</code></td><td>Serialized <code>i32</code> indicating variant, numbered in declaration order starting from 1, followed by the serialized values of the variant's fields in declaration order</td></tr>
<tr><td><code>dictionary</code></td><td>The serialized value of each field, in declaration order</td></tr>
<tr><td><code>interface</code></td><td><em>Cannot currently be serialized</em></td></tr>
</tbody></table>
<p>Note that length fields in this format are serialized as <em>signed</em> integers
despite the fact that they will always be non-negative. This is to help
ease compatibility with JVM-based languages since the JVM uses signed 32-bit
integers for its size fields internally.</p>
<h1><a class="header" href="#managing-object-references" id="managing-object-references">Managing Object References</a></h1>
<p>Uniffi <a href="internals/../udl/interfaces.html">interfaces</a> represent instances of objects
that have methods and contain shared mutable state. One of Rust's core innovations
is its ability to provide compile-time guarantees about working with such instances,
including:</p>
<ul>
<li>Ensuring that each instance has a unique owner responsible for disposing of it.</li>
<li>Ensuring that there is only a single writer <em>or</em> multiple readers of an object
active at any point in the program.</li>
<li>Guarding against data races.</li>
</ul>
<p>Uniffi aims to maintain these guarantees even when the Rust code is being invoked
from a foreign language, at the cost of turning them into run-time checks rather
than compile-time guarantees.</p>
<h2><a class="header" href="#handle-maps" id="handle-maps">Handle Maps</a></h2>
<p>We achieve this by indirecting all object access through a
<a href="https://docs.rs/ffi-support/0.4.0/ffi_support/handle_map/index.html">handle map</a>,
a mapping from opaque integer handles to object instances. This indirection
imposes a small runtime cost but helps us guard against errors or oversights
in the generated bindings.</p>
<p>For each interface declared in the UDL, the uniffi-generated Rust scaffolding
will create a global handlemap that is responsible for owning all instances
of that interface, and handing out references to them when methods are called.</p>
<p>For example, given a interface definition like this:</p>
<pre><code class="language-idl">interface TodoList {
    constructor();
    void add_item(string todo);
    sequence&lt;string&gt; get_items();
};
</code></pre>
<p>The Rust scaffolding would define a lazyily-initialized global static like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    static ref UNIFFI_HANDLE_MAP_TODOLIST: ConcurrentHandleMap&lt;TodoList&gt; = ConcurrentHandleMap::new();
}
<span class="boring">}
</span></code></pre></pre>
<p>On the Rust side of the generated bindings, the instance constructor will create an instance of the
corresponding <code>TodoList</code> Rust struct, insert it into the handlemap, and return the resulting integer
handle to the foreign language code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; fn todolist_TodoList_new(err: &amp;mut ExternError) -&gt; u64 {
    // Give ownership of the new instance to the handlemap.
    // We will only ever operate on borrowed references to it.
    UNIFFI_HANDLE_MAP_TODOLIST.insert_with_output(err, || TodoList::new())
}
<span class="boring">}
</span></code></pre></pre>
<p>When invoking a method on the instance, the foreign-language code passes the integer handle back
to the Rust code, which borrows a mutable reference to the instance from the handlemap for the duration
of the method call:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; fn todolist_TodoList_add_item(handle: u64, todo: RustBuffer, err: &amp;mut ExternError) -&gt; () {
    let todo = &lt;String as uniffi::ViaFfi&gt;::try_lift(todo).unwrap()
    // Borrow a reference to the instance so that we can call a method on it.
    UNIFFI_HANDLE_MAP_TODOLIST.call_with_result_mut(err, handle, |obj| -&gt; Result&lt;(), TodoError&gt; {
        TodoList::add_item(obj, todo)
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, when the foreign-language code frees the instance, it passes the integer handle to
a special destructor function so that the Rust code can delete it from the handlemap:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; fn ffi_todolist_TodoList_object_free(handle: u64) {
    UNIFFI_HANDLE_MAP_TODOLIST.delete_u64(handle);
}
<span class="boring">}
</span></code></pre></pre>
<p>This indirection gives us some important safety properties:</p>
<ul>
<li>If the generated bindings incorrectly pass an invalid handle, or a handle for a different type of object,
then the handlemap will throw an error with high probability, providing some amount of run-time typechecking
for correctness of the generated bindings.</li>
<li>The handlemap can ensure we uphold Rust's requirements around unique mutable references and threadsafey,
using a combination of compile-time checks and runtime locking depending on the details of the underlying
Rust struct that implements the interface.</li>
</ul>
<h2><a class="header" href="#managing-concurrency" id="managing-concurrency">Managing Concurrency</a></h2>
<p>By default, uniffi uses the <a href="https://docs.rs/ffi-support/0.4.0/ffi_support/handle_map/struct.ConcurrentHandleMap.html">ffi_support::ConcurrentHandleMap</a> struct as the handlemap for each declared instance. This class
wraps each instance with a <code>Mutex</code>, which serializes access to the instance and upholds Rust's guarantees
against shared mutable access.  This approach is simple and safe, but it means that all method calls
on an instance are run in a strictly sequential fashion, limiting concurrency.</p>
<p>For instances that are explicited tagged with the <code>[Threadsafe]</code> attribute, uniffi instead uses
a custom <code>ArcHandleMap</code> struct. This replaces the run-time <code>Mutex</code> with compile-time assertions
about the safety of the underlying Rust struct. Specifically:</p>
<ul>
<li>The <code>ArcHandleMap</code> will never give out a mutable reference to an instance, forcing the
underlying struct to use interior mutability and manage its own locking.</li>
<li>The <code>ArcHandleMap</code> can only contain structs that are <code>Sync</code> and <code>Send</code>, ensuring that
shared references can safely be accessed from multiple threads.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
