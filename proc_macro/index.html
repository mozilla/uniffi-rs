<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Procedural Macros: Attributes and Derives - The UniFFI user guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../Overview.html">Overview</a></li><li class="chapter-item expanded "><a href="../Motivation.html"><strong aria-hidden="true">1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="../Getting_started.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorial/Prerequisites.html"><strong aria-hidden="true">2.1.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="../tutorial/udl_file.html"><strong aria-hidden="true">2.2.</strong> Describing the interface</a></li><li class="chapter-item expanded "><a href="../tutorial/Rust_scaffolding.html"><strong aria-hidden="true">2.3.</strong> Generating the Rust scaffolding code</a></li><li class="chapter-item expanded "><a href="../tutorial/foreign_language_bindings.html"><strong aria-hidden="true">2.4.</strong> Generating the foreign-language bindings</a></li></ol></li><li class="chapter-item expanded "><a href="../udl_file_spec.html"><strong aria-hidden="true">3.</strong> The UDL file</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../udl/namespace.html"><strong aria-hidden="true">3.1.</strong> Namespace</a></li><li class="chapter-item expanded "><a href="../udl/builtin_types.html"><strong aria-hidden="true">3.2.</strong> Built-in types</a></li><li class="chapter-item expanded "><a href="../udl/enumerations.html"><strong aria-hidden="true">3.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../udl/structs.html"><strong aria-hidden="true">3.4.</strong> Structs/Dictionaries</a></li><li class="chapter-item expanded "><a href="../udl/functions.html"><strong aria-hidden="true">3.5.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../udl/errors.html"><strong aria-hidden="true">3.5.1.</strong> Throwing errors</a></li></ol></li><li class="chapter-item expanded "><a href="../udl/interfaces.html"><strong aria-hidden="true">3.6.</strong> Interfaces/Objects</a></li><li class="chapter-item expanded "><a href="../udl/callback_interfaces.html"><strong aria-hidden="true">3.7.</strong> Callback Interfaces</a></li><li class="chapter-item expanded "><a href="../udl/ext_types.html"><strong aria-hidden="true">3.8.</strong> External Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../udl/ext_types_external.html"><strong aria-hidden="true">3.8.1.</strong> Declaring External Types</a></li><li class="chapter-item expanded "><a href="../udl/custom_types.html"><strong aria-hidden="true">3.8.2.</strong> Declaring Custom Types</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../proc_macro/index.html" class="active"><strong aria-hidden="true">4.</strong> Procedural Macros: Attributes and Derives</a></li><li class="chapter-item expanded "><a href="../futures.html"><strong aria-hidden="true">5.</strong> Futures and async support</a></li><li class="chapter-item expanded "><a href="../bindings.html"><strong aria-hidden="true">6.</strong> Bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../bindings.html"><strong aria-hidden="true">6.1.</strong> Customizing binding generation</a></li><li class="chapter-item expanded "><a href="../foreign_traits.html"><strong aria-hidden="true">6.2.</strong> Implementing Rust traits in foreign bindings</a></li><li class="chapter-item expanded "><a href="../kotlin/configuration.html"><strong aria-hidden="true">6.3.</strong> Kotlin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../kotlin/gradle.html"><strong aria-hidden="true">6.3.1.</strong> Integrating with Gradle</a></li><li class="chapter-item expanded "><a href="../kotlin/lifetimes.html"><strong aria-hidden="true">6.3.2.</strong> Kotlin Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="../swift/overview.html"><strong aria-hidden="true">6.4.</strong> Swift</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../swift/configuration.html"><strong aria-hidden="true">6.4.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../swift/module.html"><strong aria-hidden="true">6.4.2.</strong> Building a Swift module</a></li><li class="chapter-item expanded "><a href="../swift/xcode.html"><strong aria-hidden="true">6.4.3.</strong> Integrating with Xcode</a></li></ol></li><li class="chapter-item expanded "><a href="../python/configuration.html"><strong aria-hidden="true">6.5.</strong> Python</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Internals</li><li class="chapter-item expanded "><a href="../internals/design_principles.html"><strong aria-hidden="true">7.</strong> Design Principles</a></li><li class="chapter-item expanded "><a href="../internals/crates.html"><strong aria-hidden="true">8.</strong> Navigating the Code</a></li><li class="chapter-item expanded "><a href="../internals/lifting_and_lowering.html"><strong aria-hidden="true">9.</strong> Lifting, Lowering, and Serialization</a></li><li class="chapter-item expanded "><a href="../internals/object_references.html"><strong aria-hidden="true">10.</strong> Managing Object References</a></li><li class="chapter-item expanded "><a href="../internals/rendering_foreign_bindings.html"><strong aria-hidden="true">11.</strong> Rendering Foreign Bindings</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The UniFFI user guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="procedural-macros-attributes-and-derives"><a class="header" href="#procedural-macros-attributes-and-derives">Procedural Macros: Attributes and Derives</a></h1>
<p>UniFFI allows you to define your function signatures and type definitions directly in your Rust
code, avoiding the need to duplicate them in a UDL file and so avoiding the possibility for the two to get out of sync.
This  mechanism is based on <a href="https://doc.rust-lang.org/reference/procedural-macros.html">Procedural Macros</a> (proc-macros), specifically the attribute and derive macros.</p>
<p>You can have this mechanism extract some kinds of definitions out of your Rust code,
in addition to what is declared in the UDL file. However, you have to make sure
that the UDL file is still valid on its own: All types referenced in fields, parameter and return
types in UDL must also be declared in UDL.</p>
<p>Further, using this capability probably means you still need to refer to the UDL documentation,
because at this time, that documentation tends to conflate the UniFFI type model and the
description of how foreign bindings use that type model. For example, the documentation for
a UDL interface describes both how it is defined in UDL and how Swift and Kotlin might use
that interface. The latter is relevent even if you define the interface using proc-macros
instead of in UDL.</p>
<p><strong>⚠ Warning ⚠</strong> This facility is relatively new, so things may change often. However, this remains
true for all of UniFFI, so proceed with caution and the knowledge that things may break in the future.</p>
<h2 id="build-workflow"><a class="header" href="#build-workflow">Build workflow</a></h2>
<p>Be sure to use library mode when using UniFFI proc-macros (See the <a href="../tutorial/foreign_language_bindings.html">Foreign language bindings docs</a> for more info).</p>
<p>If your crate's API is declared using only proc-macros and not UDL files, call the <code>uniffi::setup_scaffolding</code> macro at the top of your source code:</p>
<pre><code class="language-rust">uniffi::setup_scaffolding!();</code></pre>
<p><strong>⚠ Warning ⚠</strong> Do not call both <code>uniffi::setup_scaffolding!()</code> and <code>uniffi::include_scaffolding!!()</code> in the same crate.</p>
<h2 id="the-uniffiexport-attribute"><a class="header" href="#the-uniffiexport-attribute">The <code>#[uniffi::export]</code> attribute</a></h2>
<p>The most important proc-macro is the <code>export</code> attribute. It can be used on functions, <code>impl</code>
blocks, and <code>trait</code> definitions to make UniFFI aware of them.</p>
<pre><code class="language-rust">#[uniffi::export]
fn hello_ffi() {
    println!(&quot;Hello from Rust!&quot;);
}

// Corresponding UDL:
//
// interface MyObject {};
#[derive(uniffi::Object)] 
struct MyObject {
    // ...
}

#[uniffi::export]
impl MyObject {
    // Constructors need to be annotated as such.
    // As of right now, they must return `Arc&lt;Self&gt;`, this might change.
    // If the constructor is named `new`, it is treated as the primary
    // constructor, so in most languages this is invoked with `MyObject()`.
    #[uniffi::constructor]
    fn new(argument: String) -&gt; Arc&lt;Self&gt; {
        // ...
    }

    // Constructors with different names are also supported, usually invoked
    // as `MyObject.named()` (depending on the target language)
    #[uniffi::constructor]
    fn named() -&gt; Arc&lt;Self&gt; {
        // ...
    }

    // All functions that are not constructors must have a `self` argument
    fn method_a(&amp;self) {
        // ...
    }

    // `Arc&lt;Self&gt;` is also supported
    fn method_b(self: Arc&lt;Self&gt;) {
        // ...
    }
}

// Corresponding UDL:
// [Trait]
// interface MyTrait {};
#[uniffi::export]
trait MyTrait {
    // ...
}
</code></pre>
<p>All owned <a href="../udl/builtin_types.html">builtin types</a> and user-defined types can be used as arguments
and return types.</p>
<p>Arguments and receivers can also be references to these types, for example:</p>
<pre><code class="language-rust">// Input data types as references
#[uniffi::export]
fn process_data(a: &amp;MyRecord, b: &amp;MyEnum, c: Option&lt;&amp;MyRecord&gt;) {
    ...
}

#[uniffi::export]
impl Foo {
  // Methods can take a `&amp;self`, which will be borrowed from `Arc&lt;Self&gt;`
  fn some_method(&amp;self) {
    ...
  }
}

// Input foo as an Arc and bar as a reference
fn call_both(foo: Arc&lt;Foo&gt;, bar: &amp;Foo) {
  foo.some_method();
  bar.some_method();
}</code></pre>
<p>The one restriction is that the reference must be visible in the function signature.  This wouldn't
work:</p>
<pre><code class="language-rust">type MyFooRef = &amp;'static Foo;

// ERROR: UniFFI won't recognize that the `foo` argument is a reference.
#[uniffi::export]
fn do_something(foo: MyFooRef) {
}</code></pre>
<h2 id="the-uniffirecord-derive"><a class="header" href="#the-uniffirecord-derive">The <code>uniffi::Record</code> derive</a></h2>
<p>The <code>Record</code> derive macro exposes a <code>struct</code> with named fields over FFI. All types that are
supported as parameter and return types by <code>#[uniffi::export]</code> are also supported as field types
here.</p>
<p>It is permitted to use this macro on a type that is also defined in the UDL file, as long as all
field types are UniFFI builtin types; user-defined types might be allowed in the future. You also
have to maintain a consistent field order between the Rust and UDL files (otherwise compilation
will fail).</p>
<pre><code class="language-rust">#[derive(uniffi::Record)]
pub struct MyRecord {
    pub field_a: String,
    pub field_b: Option&lt;Arc&lt;MyObject&gt;&gt;,
    // Fields can have a default value.
    // Currently, only string, integer, float and boolean literals are supported as defaults.
    #[uniffi(default = &quot;hello&quot;)]
    pub greeting: String,
    #[uniffi(default = true)]
    pub some_flag: bool,
}</code></pre>
<h2 id="the-uniffienum-derive"><a class="header" href="#the-uniffienum-derive">The <code>uniffi::Enum</code> derive</a></h2>
<p>The <code>Enum</code> derive macro works much like the <code>Record</code> derive macro. Any fields inside variants must
be named. All types that are supported as parameter and return types by <code>#[uniffi::export]</code> are
also supported as field types.</p>
<p>It is permitted to use this macro on a type that is also defined in the UDL file as long as the
two definitions are equal in the names and ordering of variants and variant fields, and any field
types inside variants are UniFFI builtin types; user-defined types might be allowed in the future.</p>
<pre><code class="language-rust">#[derive(uniffi::Enum)]
pub enum MyEnum {
    Fieldless,
    WithFields {
        foo: u8,
        bar: Vec&lt;i32&gt;,
    },
}</code></pre>
<h2 id="the-uniffiobject-derive"><a class="header" href="#the-uniffiobject-derive">The <code>uniffi::Object</code> derive</a></h2>
<p>This derive can be used to replace an <code>interface</code> definition in UDL. Every object type must have
<em>either</em> an <code>interface</code> definition in UDL <em>or</em> use this derive macro. However, <code>#[uniffi::export]</code>
can be used on an impl block for an object type regardless of whether this derive is used. You can
also mix and match, and define some method of an object via proc-macro while falling back to UDL
for methods that are not supported by <code>#[uniffi::export]</code> yet; just make sure to use separate
<code>impl</code> blocks:</p>
<pre><code class="language-idl">// UDL file

interface Foo {
    void method_a();
};
</code></pre>
<pre><code class="language-rust">// Rust file

// Not deriving uniffi::Object since it is defined in UDL
struct Foo {
    // ...
}

// Implementation of the method defined in UDL
impl Foo {
    fn method_a(&amp;self) {
        // ...
    }
}

// Another impl block with an additional method
#[uniffi::export]
impl Foo {
    fn method_b(&amp;self) {
        // ...
    }
}</code></pre>
<h2 id="the-unifficustom_type-and-unifficustom_newtype-macros"><a class="header" href="#the-unifficustom_type-and-unifficustom_newtype-macros">The <code>uniffi::custom_type</code> and <code>uniffi::custom_newtype</code> macros</a></h2>
<p>There are 2 macros available which allow procmacros to support &quot;custom types&quot; as described in the
<a href="../udl/custom_types.html">UDL documentation for Custom Types</a></p>
<p>The <code>uniffi::custom_type!</code> macro requires you to specify the name of the custom type, and the name of the
builtin which implements this type. Use of this macro requires you to manually implement the
<code>UniffiCustomTypeConverter</code> trait for for your type, as shown below.</p>
<pre><code class="language-rust">pub struct Uuid {
    val: String,
}

// Use `Uuid` as a custom type, with `String` as the Builtin
uniffi::custom_type!(Uuid, String);

impl UniffiCustomTypeConverter for Uuid {
    type Builtin = String;

    fn into_custom(val: Self::Builtin) -&gt; uniffi::Result&lt;Self&gt; {
        Ok(Uuid { val })
    }

    fn from_custom(obj: Self) -&gt; Self::Builtin {
        obj.val
    }
}</code></pre>
<p>There's also a <code>uniffi::custom_newtype!</code> macro, designed for custom types which use the
&quot;new type&quot; idiom. You still need to specify the type name and builtin type, but because UniFFI
is able to make assumptions about how the type is laid out, <code>UniffiCustomTypeConverter</code>
is implemented automatically.</p>
<pre><code class="language-rust">uniffi::custom_newtype!(NewTypeHandle, i64);
pub struct NewtypeHandle(i64);</code></pre>
<p>and that's it!</p>
<h2 id="the-uniffierror-derive"><a class="header" href="#the-uniffierror-derive">The <code>uniffi::Error</code> derive</a></h2>
<p>The <code>Error</code> derive registers a type as an error and can be used on any enum that the <code>Enum</code> derive also accepts.
By default, it exposes any variant fields to the foreign code.
This type can then be used as the <code>E</code> in a <code>Result&lt;T, E&gt;</code> return type of an exported function or method.
The generated foreign function for an exported function with a <code>Result&lt;T, E&gt;</code> return type
will have the result's <code>T</code> as its return type and throw the error in case the Rust call returns <code>Err(e)</code>.</p>
<pre><code class="language-rust">#[derive(uniffi::Error)]
pub enum MyError {
    MissingInput,
    IndexOutOfBounds {
        index: u32,
        size: u32,
    }
    Generic {
        message: String,
    }
}

#[uniffi::export]
fn do_thing() -&gt; Result&lt;(), MyError&gt; {
    // ...
}</code></pre>
<p>You can also use the helper attribute <code>#[uniffi(flat_error)]</code> to expose just the variants but none of the fields.
In this case the error will be serialized using Rust's <code>ToString</code> trait
and will be accessible as the only field on each of the variants.
For flat errors your variants can have unnamed fields,
and the types of the fields don't need to implement any special traits.</p>
<pre><code class="language-rust">#[derive(uniffi::Error)]
#[uniffi(flat_error)]
pub enum MyApiError {
    Http(reqwest::Error),
    Json(serde_json::Error),
}

// ToString is not usually implemented directly, but you get it for free by implementing Display.
// This impl could also be generated by a proc-macro, for example thiserror::Error.
impl std::fmt::Display for MyApiError {
    // ...
}

#[uniffi::export]
fn do_http_request() -&gt; Result&lt;(), MyApiError&gt; {
    // ...
}</code></pre>
<h2 id="the-uniffiexportcallback_interface-attribute"><a class="header" href="#the-uniffiexportcallback_interface-attribute">The <code>#[uniffi::export(callback_interface)]</code> attribute</a></h2>
<p><code>#[uniffi::export(callback_interface)]</code> can be used to export a <a href="../udl/callback_interfaces.html">callback interface</a> definition.
This allows the foreign bindings to implement the interface and pass an instance to the Rust code.</p>
<pre><code class="language-rust">#[uniffi::export(callback_interface)]
pub trait Person {
    fn name() -&gt; String;
    fn age() -&gt; u32;
}

// Corresponding UDL:
// callback interface Person {
//     string name();
//     u32 age();
// }</code></pre>
<h2 id="types-from-dependent-crates"><a class="header" href="#types-from-dependent-crates">Types from dependent crates</a></h2>
<p>When using proc-macros, you can use types from dependent crates in your exported library, as long as
the dependent crate annotates the type with one of the UniFFI derives.  However, there are a couple
exceptions:</p>
<h3 id="types-from-udl-based-dependent-crates"><a class="header" href="#types-from-udl-based-dependent-crates">Types from UDL-based dependent crates</a></h3>
<p>If the dependent crate uses a UDL file to define their types, then you must invoke one of the
<code>uniffi::use_udl_*!</code> macros, for example:</p>
<pre><code class="language-rust">uniffi::use_udl_record!(dependent_crate, RecordType);
uniffi::use_udl_enum!(dependent_crate, EnumType);
uniffi::use_udl_error!(dependent_crate, ErrorType);
uniffi::use_udl_object!(dependent_crate, ObjectType);</code></pre>
<h3 id="non-uniffi-types-from-dependent-crates"><a class="header" href="#non-uniffi-types-from-dependent-crates">Non-UniFFI types from dependent crates</a></h3>
<p>If the dependent crate doesn't define the type in a UDL file or use one of the UniFFI derive macros,
then it's currently not possible to use them in an proc-macro exported interface.  However, we hope
to fix this limitation soon.</p>
<h2 id="other-limitations"><a class="header" href="#other-limitations">Other limitations</a></h2>
<p>In addition to the per-item limitations of the macros presented above, there is also currently a
global restriction: You can only use the proc-macros inside a crate whose name is the same as the
namespace in your UDL file. This restriction will be lifted in the future.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../udl/custom_types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../udl/custom_types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
