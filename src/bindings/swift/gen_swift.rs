/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use std::path::Path;

use anyhow::Result;
use askama::Template;

use crate::interface::*;

// Some config options for it the caller wants to customize the generated python.
// Note that this can only be used to control details of the python *that do not affect the underlying component*,
// sine the details of the underlying component are entirely determined by the `ComponentInterface`.
pub struct Config {
    // No config options yet.
}

impl Config {
    pub fn from(_ci: &ComponentInterface) -> Self {
        Config {
            // No config options yet
        }
    }
}

#[derive(Template)]
#[template(
    ext = "h",
    escape = "none",
    source = r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

#pragma once

#include <stdbool.h>
#include <stdint.h>

typedef struct RustBuffer {
    int64_t len;
    uint8_t *_Nullable data;
} RustBuffer;

{% for func in ci.iter_ffi_function_definitions() -%}
    {%- match func.return_type() -%}{%- when Some with (type_) %}{{ type_|decl_c }}{% when None %}void{% endmatch %} {{ func.name() }}(
      {%- for arg in func.arguments() %}
      {{ arg.type_()|decl_c }} {{ arg.name() }}{% if loop.last %}{% else %},{% endif %}
      {%- endfor %}
      // TODO: When we implement error handling, there will be a `*_Nonnull out_err` param here.
    );
{% endfor -%}
"#
)]
pub struct BridgingHeader<'config, 'ci> {
    _config: &'config Config,
    ci: &'ci ComponentInterface,
}

impl<'config, 'ci> BridgingHeader<'config, 'ci> {
    pub fn new(config: &'config Config, ci: &'ci ComponentInterface) -> Self {
        Self {
            _config: config,
            ci,
        }
    }
}

#[derive(Template)]
#[template(
    ext = "modulemap",
    escape = "none",
    source = r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
module uniffi_{{ ci.namespace() }} {
    umbrella header "{{ header|header_path }}"
    export *
}
"#
)]
pub struct ModuleMap<'ci, 'header> {
    ci: &'ci ComponentInterface,
    header: &'header Path,
}

impl<'ci, 'header> ModuleMap<'ci, 'header> {
    pub fn new(ci: &'ci ComponentInterface, header: &'header Path) -> Self {
        Self { ci, header }
    }
}

#[derive(Template)]
#[template(
    ext = "swift",
    escape = "none",
    source = r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import Foundation
import uniffi_{{ ci.namespace() }}

extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

extension RustBuffer {
    init(bytes: [UInt8]) {
        // TODO: This also copies the buffer. Can we write directly into
        // a Rust buffer?
        let rustBuffer = {{ ci.ffi_bytebuffer_alloc().name() }}(UInt32(bytes.count))
        let pointer = UnsafeMutableBufferPointer(start: rustBuffer.data, count: Int(rustBuffer.len))
        bytes.copyBytes(to: pointer)
        self.init(len: Int64(pointer.count), data: pointer.baseAddress!)
    }

    // Frees the buffer in place. The buffer must not be used after this is
    // called.
    func deallocate() {
        {{ ci.ffi_bytebuffer_free().name() }}(self)
    }
}

// Serialization and deserialization errors.
enum InternalError: Error {
    // Reading the requested value would read past the end of the buffer.
    case bufferOverflow
    // The buffer still has data after lifting its containing value.
    case incompleteData
    // Unexpected tag byte for `Optional`; should be 0 or 1.
    case unexpectedOptionalTag
    // Unexpected integer that doesn't correspond to an enum case.
    case unexpectedEnumCase
}

// A helper class to read values out of a byte buffer.
class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        self.offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset..<offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw InternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value, { data.copyBytes(to: $0, from: range)})
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        self.bytes = []
        self.offset = 0
    }

    // Writes an integer in big-endian order.
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        let _ = withUnsafeBytes(of: &value, { bytes.append(contentsOf: $0) })
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Types conforming to `Liftable` know how to deserialize ("lift") themselves
// from a byte buffer. This is equivalent to the `Liftable` trait on the Rust
// side.
protocol Liftable {
    static func lift(from: Reader) throws -> Self
}

// Types conforming to `Lowerable` know how to serialize ("lower") themselves
// into a byte buffer. Equivalent to the `Lowerable` trait on the Rust side.
protocol Lowerable {
    func lower(into: Writer)
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
// Roughly equivalent to the `ViaFfi` implementations for primitives in Rust.
protocol Primitive {}

extension Primitive {
    static func fromFFIValue(_ v: Self) throws -> Self {
        return v
    }

    func toFFIValue() -> Self {
        return self
    }
}

// Types conforming to `Serializable` pass themselves over the FFI using byte
// buffers. Roughly equivalent to the `ViaFfiUsingByteBuffer` trait in Rust.
protocol Serializable: Liftable & Lowerable {}

extension Serializable {
    static func fromFFIValue(_ buf: RustBuffer) throws -> Self {
      let reader = Reader(data: Data(rustBuffer: buf))
      let value = try Self.lift(from: reader)
      if reader.hasRemaining() {
          throw InternalError.incompleteData
      }
      buf.deallocate()
      return value
    }

    func toFFIValue() -> RustBuffer {
      let writer = Writer()
      self.lower(into: writer)
      return RustBuffer(bytes: writer.bytes)
    }
}

// Implement our protocols for the built-in types that we use.

extension Bool: Liftable, Lowerable {
    static func lift(from buf: Reader) throws -> Bool {
        return try self.fromFFIValue(buf.readInt())
    }

    func lower(into buf: Writer) {
        buf.writeInt(self.toFFIValue())
    }

    static func fromFFIValue(_ v: UInt8) throws -> Bool {
        return v != 0
    }

    func toFFIValue() -> UInt8 {
        return self ? 1 : 0
    }
}

extension UInt8: Liftable, Lowerable, Primitive {
    static func lift(from buf: Reader) throws -> UInt8 {
        return try self.fromFFIValue(buf.readInt())
    }

    func lower(into buf: Writer) {
        buf.writeInt(self.toFFIValue())
    }
}

extension UInt32: Liftable, Lowerable, Primitive {
    static func lift(from buf: Reader) throws -> UInt32 {
        return try self.fromFFIValue(buf.readInt())
    }

    func lower(into buf: Writer) {
        buf.writeInt(self.toFFIValue())
    }
}

extension UInt64: Liftable, Lowerable, Primitive {
    static func lift(from buf: Reader) throws -> UInt64 {
        return try self.fromFFIValue(buf.readInt())
    }

    func lower(into buf: Writer) {
        buf.writeInt(self.toFFIValue())
    }
}

extension Float: Liftable, Lowerable, Primitive {
    static func lift(from buf: Reader) throws -> Float {
        return try self.fromFFIValue(buf.readFloat())
    }

    func lower(into buf: Writer) {
        buf.writeFloat(self.toFFIValue())
    }
}

extension Double: Liftable, Lowerable, Primitive {
    static func lift(from buf: Reader) throws -> Double {
        return try self.fromFFIValue(buf.readDouble())
    }

    func lower(into buf: Writer) {
        buf.writeDouble(self.toFFIValue())
    }
}

extension Optional: Liftable where Wrapped: Liftable {
    static func lift(from buf: Reader) throws -> Self {
        switch try buf.readInt() as UInt8 {
        case 0: return nil
        case 1: return try Wrapped.lift(from: buf)
        default: throw InternalError.unexpectedOptionalTag
        }
    }
}

extension Optional: Lowerable where Wrapped: Lowerable {
    func lower(into buf: Writer) {
        guard let value = self else {
            buf.writeInt(0)
            return
        }
        buf.writeInt(1)
        value.lower(into: buf)
    }
}

extension Optional: Serializable where Wrapped: Liftable & Lowerable {}

// Public interface members begin here.

{% for e in ci.iter_enum_definitions() %}
public enum {{ e.name() }}: Lowerable, Liftable {
    {% for value in e.values() %}
    case {{ value|decl_enum_variant_swift }}
    {% endfor %}

    static func lift(from buf: Reader) throws -> {{ e.name() }} {
        return try {{ e.name() }}.fromFFIValue(UInt32.lift(from: buf))
    }

    static func fromFFIValue(_ number: UInt32) throws -> {{ e.name() }} {
        switch number {
        {% for value in e.values() %}
        case {{ loop.index }}: return .{{ value|decl_enum_variant_swift }}
        {% endfor %}
        default: throw InternalError.unexpectedEnumCase
        }
    }

    func lower(into buf: Writer) {
        self.toFFIValue().lower(into: buf)
    }

    func toFFIValue() -> UInt32 {
        switch self {
        {% for value in e.values() %}
        case .{{ value|decl_enum_variant_swift }}: return {{ loop.index }}
        {% endfor %}
        }
    }
}
{%- endfor -%}

{%- for rec in ci.iter_record_definitions() %}
public struct {{ rec.name() }}: Lowerable, Liftable, Serializable {
    {%- for field in rec.fields() %}
    let {{ field.name() }}: {{ field.type_()|decl_swift }}
    {%- endfor %}

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        {%- for field in rec.fields() %}
        {{ field.name() }}: {{ field.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
        {%- endfor %}
    ) {
        {%- for field in rec.fields() %}
        self.{{ field.name() }} = {{ field.name() }}
        {%- endfor %}
    }

    static func lift(from buf: Reader) throws -> {{ rec.name() }} {
        return try {{ rec.name() }}(
            {%- for field in rec.fields() %}
            {{ field.name() }}: {{ "buf"|lift_from_swift(field.type_()) }}{% if loop.last %}{% else %},{% endif %}
            {%- endfor %}
        )
    }

    func lower(into buf: Writer) {
        {%- for field in rec.fields() %}
        {{ field.name() }}.lower(into: buf)
        {%- endfor %}
    }
}
{% endfor %}

{% for func in ci.iter_function_definitions() %}
{%- match func.return_type() -%}
{%- when Some with (return_type) %}

public func {{ func.name() }}(
    // TODO: More considered handling of labels (don't emit them
    // for single-argument functions; others?)
    {%- for arg in func.arguments() %}
    {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
    {%- endfor %}
) -> {{ return_type|decl_swift }} {
    let _retval = {{ func.ffi_func().name() }}(
        {%- for arg in func.arguments() %}
        {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
        {%- endfor %}
    )
    return try! {{ "_retval"|lift_swift(return_type) }}
}

{% when None -%}

public func {{ func.name() }}(
    {%- for arg in func.arguments() %}
    {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
    {%- endfor %}
) {
    {{ func.ffi_func().name() }}(
        {%- for arg in func.arguments() %}
        {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
        {%- endfor %}
    )
}

{%- endmatch %}
{% endfor %}

{% for obj in ci.iter_object_definitions() %}
public class {{ obj.name() }} {
    private let handle: UInt64

    {%- for cons in obj.constructors() %}
    public init(
        {%- for arg in cons.arguments() %}
        {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
        {%- endfor %}
    ) {
        self.handle = {{ cons.ffi_func().name() }}(
            {%- for arg in cons.arguments() %}
            {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
            {%- endfor %}
        );
    }
    {%- endfor %}

    // XXX TODO: destructors or equivalent.

    {%- for meth in obj.methods() %}
    {%- match meth.return_type() -%}
    {%- when Some with (return_type) %}

    public func {{ meth.name() }}(
        {% for arg in meth.arguments() %}
        {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
        {% endfor %}
    ) -> {{ return_type|decl_swift }} {
        let _retval = {{ meth.ffi_func().name() }}(
            self.handle{% if meth.arguments().len() > 0 %},{% endif %}
            {%- for arg in meth.arguments() %}
            {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
            {%- endfor %}
        )
        return try! {{ "_retval"|lift_swift(return_type) }}
    }

    {% when None -%}

    public func {{ meth.name() }}(
        {% for arg in meth.arguments() %}
        {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
        {% endfor %}
    ) {
        {{ meth.ffi_func().name() }}(
            self.handle{% if meth.arguments().len() > 0 %},{% endif %}
            {%- for arg in meth.arguments() %}
            {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
            {%- endfor %}
        )
    }

    {%- endmatch %}
    {%- endfor %}
}
{% endfor %}
"#
)]
pub struct SwiftWrapper<'config, 'ci> {
    _config: &'config Config,
    ci: &'ci ComponentInterface,
}

impl<'config, 'ci> SwiftWrapper<'config, 'ci> {
    pub fn new(config: &'config Config, ci: &'ci ComponentInterface) -> Self {
        Self {
            _config: config,
            ci,
        }
    }
}

/// Filters for our Askama templates above. These output C (for the bridging
/// header) and Swift (for the actual library) declarations.
mod filters {
    use super::*;
    use std::fmt;

    /// Declares a C type in the bridging header.
    pub fn decl_c(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            // These native types map nicely to the FFI without conversion.
            TypeReference::U32 => "uint32_t".into(),
            TypeReference::U64 => "uint64_t".into(),
            TypeReference::Float => "float".into(),
            TypeReference::Double => "double".into(),
            TypeReference::Bytes => "RustBuffer".into(),
            // Our FFI lowers Booleans into bytes, to work around JNA bugs.
            // We'll lift these up into Booleans on the Swift side.
            TypeReference::Boolean => "uint8_t".into(),
            // These types need conversion, and special handling for lifting/lowering.
            TypeReference::Enum(_) => "uint32_t".into(),
            TypeReference::Record(_) => "RustBuffer".into(),
            TypeReference::Optional(_) => "RustBuffer".into(),
            TypeReference::Object(_) => "uint64_t".into(),
            _ => panic!("[TODO: decl_c({:?})", type_),
        })
    }

    /// Declares a Swift type in the public interface for the library.
    pub fn decl_swift(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            TypeReference::U32 => "UInt32".into(),
            TypeReference::U64 => "UInt64".into(),
            TypeReference::Float => "Float".into(),
            TypeReference::Double => "Double".into(),
            // TypeReference::Bytes => "Data".into(),
            TypeReference::Boolean => "Bool".into(),
            TypeReference::Enum(name) => name.into(),
            TypeReference::Record(name) => name.into(),
            TypeReference::Optional(type_) => format!("{}?", decl_swift(type_)?),
            TypeReference::Object(name) => name.into(),
            _ => panic!("[TODO: decl_swift({:?})", type_),
        })
    }

    /// Lowers a Swift type into a C type. This is used to pass arguments over
    /// the FFI, from Swift to Rust.
    pub fn lower_swift(
        name: &dyn fmt::Display,
        _type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.toFFIValue()", name))
    }

    /// ...
    pub fn lift_from_swift(
        name: &dyn fmt::Display,
        type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.lift(from: {})", decl_swift(type_)?, name))
    }

    /// ...
    pub fn lift_swift(
        name: &dyn fmt::Display,
        type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.fromFFIValue({})", decl_swift(type_)?, name))
    }

    /// ...
    pub fn decl_enum_variant_swift(name: &str) -> Result<String, askama::Error> {
        use heck::MixedCase;
        Ok(name.to_mixed_case())
    }

    /// ...
    pub fn header_path(path: &Path) -> Result<String, askama::Error> {
        Ok(path.to_str().expect("Invalid bridging header path").into())
    }
}
