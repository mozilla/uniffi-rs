/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use std::path::Path;

use anyhow::Result;
use askama::Template;

use crate::interface::*;

// Some config options for it the caller wants to customize the generated python.
// Note that this can only be used to control details of the python *that do not affect the underlying component*,
// sine the details of the underlying component are entirely determined by the `ComponentInterface`.
pub struct Config {
    // No config options yet.
}

impl Config {
    pub fn from(_ci: &ComponentInterface) -> Self {
        Config {
            // No config options yet
        }
    }
}

#[derive(Template)]
#[template(
    ext = "h",
    escape = "none",
    source = r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

#pragma once

#include <stdbool.h>
#include <stdint.h>

typedef struct RustBuffer {
    int64_t len;
    uint8_t *_Nullable data;
} RustBuffer;

{% for func in ci.iter_ffi_function_definitions() -%}
    {%- match func.return_type() -%}{%- when Some with (type_) %}{{ type_|decl_c }}{% when None %}void{% endmatch %} {{ func.name() }}(
      {%- for arg in func.arguments() %}
      {{ arg.type_()|decl_c }} {{ arg.name() }}{% if loop.last %}{% else %},{% endif %}
      {%- endfor %}
      // TODO: When we implement error handling, there will be a `*_Nonnull out_err` param here.
    );
{% endfor -%}
"#
)]
pub struct BridgingHeader<'config, 'ci> {
    _config: &'config Config,
    ci: &'ci ComponentInterface,
}

impl<'config, 'ci> BridgingHeader<'config, 'ci> {
    pub fn new(config: &'config Config, ci: &'ci ComponentInterface) -> Self {
        Self {
            _config: config,
            ci,
        }
    }
}

#[derive(Template)]
#[template(
    ext = "modulemap",
    escape = "none",
    source = r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
module uniffi_{{ ci.namespace() }} {
    umbrella header "{{ header|header_path }}"
    export *
}
"#
)]
pub struct ModuleMap<'ci, 'header> {
    ci: &'ci ComponentInterface,
    header: &'header Path,
}

impl<'ci, 'header> ModuleMap<'ci, 'header> {
    pub fn new(ci: &'ci ComponentInterface, header: &'header Path) -> Self {
        Self { ci, header }
    }
}

#[derive(Template)]
#[template(
    ext = "swift",
    escape = "none",
    source = r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import Foundation
import uniffi_{{ ci.namespace() }}

extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

extension RustBuffer {
    init(bytes: [UInt8]) {
        // TODO: This also copies the buffer. Can we write directly into
        // a Rust buffer?
        let rustBuffer = {{ ci.ffi_bytebuffer_alloc().name() }}(UInt32(bytes.count))
        let pointer = UnsafeMutableBufferPointer(start: rustBuffer.data, count: Int(rustBuffer.len))
        bytes.copyBytes(to: pointer)
        self.init(len: Int64(pointer.count), data: pointer.baseAddress!)
    }

    // Frees the buffer in place. The buffer must not be used after this is
    // called.
    func deallocate() {
        {{ ci.ffi_bytebuffer_free().name() }}(self)
    }
}

enum InternalError: Error {
    // Can't read past the end of the buffer.
    case bufferOverflow
    // Junk left in buffer after deserializing.
    case incompleteData
}

// A helper class to extract a byte stream from a `Data`.
class DataReader: ByteBuffer {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        self.offset = 0
    }

    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset..<offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw InternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value, { data.copyBytes(to: $0, from: range)})
        offset = range.upperBound
        return value.bigEndian
    }

    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write bytes into a `Data`.
class DataWriter: MutableByteBuffer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        self.bytes = []
        self.offset = 0
    }

    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        let _ = withUnsafeBytes(of: &value, { bytes.append(contentsOf: $0) })
    }
}

// A byte buffer reads data from a sequence of bytes.
protocol ByteBuffer {
    // Reads a fixed-with integer `T` at the current offset, in big-endian
    // order, and advances the offset on success. Throws if reading `T` would
    // advance the offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T

    // Indicates if the offset has reached the end of the buffer.
    func hasRemaining() -> Bool
}

// A mutable byte buffer writes data into a sequence of bytes.
protocol MutableByteBuffer {
    // Writes a fixed-with integer `T` at the current offset, in big-endian
    // order.
    func writeInt<T: FixedWidthInteger>(_ value: T)
}

// Types conforming to `Liftable` know how to deserialize ("lift") themselves
// from a byte buffer. This is equivalent to the `Liftable` trait on the Rust
// side.
protocol Liftable {
    static func lift<B: ByteBuffer>(from buf: B) throws -> Self
}

// Types conforming to `Lowerable` know how to serialize ("lower") themselves
// into a byte buffer. Equivalent to the `Lowerable` trait on the Rust side.
protocol Lowerable {
    func lower<B: MutableByteBuffer>(into buf: B)
}

// Lifts a value from a Rust buffer.
func liftFromRustBuffer<T: Liftable>(_ buf: RustBuffer) throws -> T {
    let reader = DataReader(data: Data(rustBuffer: buf))
    let value = try T.lift(from: reader)
    if reader.hasRemaining() {
        throw InternalError.incompleteData
    }
    buf.deallocate()
    return value
}

// Lowers a value into a Rust buffer.
func lowerIntoRustBuffer<T: Lowerable>(_ value: T) -> RustBuffer {
    let writer = DataWriter()
    value.lower(into: writer)
    return RustBuffer(bytes: writer.bytes)
}

// Implement `Liftable` and `Lowerable` for built-in types, along with
// extension methods for `toFFIValue` and `fromFFIValue`. These are equivalent
// to their Rust counterparts in the `ViaFfi` trait. Unlike Rust, Swift doesn't
// have blanket implementations (the feature we want is called "parameterized
// protocols"), so we can't make any type `T: Liftable & Lowerable` conform to a
// hypothetical `ViaFFIUsingByteBuffer` protocol. Instead, we write out
// `intoFFIValue` and `fromFFIValue` by hand, and implement non-primitive ones
// using `lowerIntoRustBuffer` and `liftFromRustBuffer`.

extension Bool: Liftable, Lowerable {
    static func lift<B: ByteBuffer>(from buf: B) throws -> Bool {
        return try self.fromFFIValue(buf.readInt())
    }

    func lower<B: MutableByteBuffer>(into buf: B) {
        buf.writeInt(self.toFFIValue())
    }

    static func fromFFIValue(_ v: UInt8) throws -> Bool {
        return v != 0
    }

    func toFFIValue() -> UInt8 {
        return self ? 1 : 0
    }
}

extension UInt8: Liftable, Lowerable {
    static func lift<B: ByteBuffer>(from buf: B) throws -> UInt8 {
        return try self.fromFFIValue(buf.readInt())
    }

    func lower<B: MutableByteBuffer>(into buf: B) {
        buf.writeInt(self.toFFIValue())
    }

    static func fromFFIValue(_ v: UInt8) throws -> UInt8 {
        return v
    }

    func toFFIValue() -> UInt8 {
        return self
    }
}

extension UInt32: Liftable, Lowerable {
    static func lift<B: ByteBuffer>(from buf: B) throws -> UInt32 {
        return try self.fromFFIValue(buf.readInt())
    }

    func lower<B: MutableByteBuffer>(into buf: B) {
        buf.writeInt(self.toFFIValue())
    }

    static func fromFFIValue(_ v: UInt32) throws -> UInt32 {
        return v
    }

    func toFFIValue() -> UInt32 {
        return self
    }
}

extension UInt64: Liftable, Lowerable {
    static func lift<B: ByteBuffer>(from buf: B) throws -> UInt64 {
        return try self.fromFFIValue(buf.readInt())
    }

    func lower<B: MutableByteBuffer>(into buf: B) {
        buf.writeInt(self.toFFIValue())
    }

    static func fromFFIValue(_ v: UInt64) throws -> UInt64 {
        return v
    }

    func toFFIValue() -> UInt64 {
        return self
    }
}

extension Optional: Liftable where Wrapped: Liftable {
    static func lift<B: ByteBuffer>(from buf: B) throws -> Self {
        switch try buf.readInt() as UInt8 {
        case 0:
            return nil
        case 1:
            return try Wrapped.lift(from: buf)
        default:
            fatalError()
        }
    }

    static func fromFFIValue(_ buf: RustBuffer) throws -> Self {
        return try liftFromRustBuffer(buf)
    }
}

extension Optional: Lowerable where Wrapped: Lowerable {
    func lower<B: MutableByteBuffer>(into buf: B) {
        guard let value = self else {
            buf.writeInt(0)
            return
        }
        buf.writeInt(1)
        value.lower(into: buf)
    }

    func toFFIValue() -> RustBuffer {
        lowerIntoRustBuffer(self)
    }
}

// Public interface members begin here.

{% for e in ci.iter_enum_definitions() %}
    public enum {{ e.name() }}: Lowerable, Liftable {
        {% for value in e.values() %}
        case {{ value|decl_enum_variant_swift }}
        {% endfor %}

        static func lift<B: ByteBuffer>(from buf: B) throws -> {{ e.name() }} {
          return try {{ e.name() }}.fromFFIValue(UInt32.lift(from: buf))
        }

        static func fromFFIValue(_ number: UInt32) throws -> {{ e.name() }} {
          switch number {
          {% for value in e.values() %}
          case {{ loop.index }}: return .{{ value|decl_enum_variant_swift }}
          {% endfor %}
          default: fatalError()
          }
        }

        func lower<B: MutableByteBuffer>(into buf: B) {
          self.toFFIValue().lower(into: buf)
        }

        func toFFIValue() -> UInt32 {
          switch self {
          {% for value in e.values() %}
          case .{{ value|decl_enum_variant_swift }}: return {{ loop.index }}
          {% endfor %}
          }
        }
    }
{%- endfor -%}

{%- for rec in ci.iter_record_definitions() %}
    public struct {{ rec.name() }}: Lowerable, Liftable {
      {%- for field in rec.fields() %}
      let {{ field.name() }}: {{ field.type_()|decl_swift }}
      {%- endfor %}

      static func lift<B: ByteBuffer>(from buf: B) throws -> {{ rec.name() }} {
        return try {{ rec.name() }}(
          {%- for field in rec.fields() %}
          {{ "buf"|lift_from_swift(field.type_()) }}{% if loop.last %}{% else %},{% endif %}
          {%- endfor %}
        )
      }

      static func fromFFIValue(_ buf: RustBuffer) throws -> {{ rec.name() }} {
        return try liftFromRustBuffer(buf)
      }

      func lower<B: MutableByteBuffer>(into buf: B) {
        {%- for field in rec.fields() %}
        {{ field.name() }}.lower(into: buf)
        {%- endfor %}
      }

      func toFFIValue() -> RustBuffer {
        lowerIntoRustBuffer(self)
      }
    }
{% endfor %}

{% for func in ci.iter_function_definitions() %}

    {%- match func.return_type() -%}
    {%- when Some with (return_type) %}

        public func {{ func.name() }}(
            {%- for arg in func.arguments() %}
                {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
            {%- endfor %}
        ) -> {{ return_type|decl_swift }} {
            let _retval = {{ func.ffi_func().name() }}(
                {%- for arg in func.arguments() %}
                {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
                {%- endfor %}
            )
            return try! {{ "_retval"|lift_swift(return_type) }}
        }

    {% when None -%}

        public func {{ func.name() }}(
            {%- for arg in func.arguments() %}
                {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
            {%- endfor %}
        ) {
            {{ func.ffi_func().name() }}(
                {%- for arg in func.arguments() %}
                {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
                {%- endfor %}
            )
        }

    {%- endmatch %}
{% endfor %}
"#
)]
pub struct SwiftWrapper<'config, 'ci> {
    _config: &'config Config,
    ci: &'ci ComponentInterface,
}

impl<'config, 'ci> SwiftWrapper<'config, 'ci> {
    pub fn new(config: &'config Config, ci: &'ci ComponentInterface) -> Self {
        Self {
            _config: config,
            ci,
        }
    }
}

/// Filters for our Askama templates above. These output C (for the bridging
/// header) and Swift (for the actual library) declarations.
mod filters {
    use super::*;
    use std::fmt;

    /// Declares a C type in the bridging header.
    pub fn decl_c(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            // These native types map nicely to the FFI without conversion.
            TypeReference::U32 => "uint32_t".into(),
            TypeReference::U64 => "uint64_t".into(),
            TypeReference::Float => "float".into(),
            TypeReference::Double => "double".into(),
            TypeReference::Bytes => "RustBuffer".into(),
            // Our FFI lowers Booleans into bytes, to work around JNA bugs.
            // We'll lift these up into Booleans on the Swift side.
            TypeReference::Boolean => "uint8_t".into(),
            // These types need conversion, and special handling for lifting/lowering.
            TypeReference::Enum(_) => "uint32_t".into(),
            TypeReference::Record(_) => "RustBuffer".into(),
            TypeReference::Optional(_) => "RustBuffer".into(),
            TypeReference::Object(_) => "uint64_t".into(),
            _ => panic!("[TODO: decl_c({:?})", type_),
        })
    }

    /// Declares a Swift type in the public interface for the library.
    pub fn decl_swift(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            TypeReference::U32 => "UInt32".into(),
            TypeReference::U64 => "UInt64".into(),
            TypeReference::Float => "Float".into(),
            TypeReference::Double => "Double".into(),
            // TypeReference::Bytes => "Data".into(),
            TypeReference::Boolean => "Bool".into(),
            TypeReference::Enum(name) => name.into(),
            TypeReference::Record(name) => name.into(),
            TypeReference::Optional(type_) => format!("{}?", decl_swift(type_)?),
            TypeReference::Object(name) => name.into(),
            _ => panic!("[TODO: decl_swift({:?})", type_),
        })
    }

    /// Lowers a Swift type into a C type. This is used to pass arguments over
    /// the FFI, from Swift to Rust.
    pub fn lower_swift(
        name: &dyn fmt::Display,
        _type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.toFFIValue()", name))
    }

    /// ...
    pub fn lift_from_swift(
        name: &dyn fmt::Display,
        type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.lift(from: {})", decl_swift(type_)?, name))
    }

    /// ...
    pub fn lift_swift(
        name: &dyn fmt::Display,
        type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.fromFFIValue({})", decl_swift(type_)?, name))
    }

    /// ...
    pub fn decl_enum_variant_swift(name: &str) -> Result<String, askama::Error> {
        use heck::MixedCase;
        Ok(name.to_mixed_case())
    }

    /// ...
    pub fn header_path(path: &Path) -> Result<String, askama::Error> {
        Ok(path.to_str().expect("Invalid bridging header path").into())
    }
}
