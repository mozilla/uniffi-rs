/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use anyhow::{anyhow, bail, Context, Result};
use std::{
    ffi::OsString,
    fs::File,
    io::Write,
    path::{Path, PathBuf},
    process::Command,
};

pub mod gen_gecko;
pub use gen_gecko::{
    Config, Interface, InterfaceHeader, Namespace, NamespaceHeader, SharedHeader, WebIdl,
};

use super::super::interface::ComponentInterface;

pub struct Source {
    name: String,
    header: String,
    source: String,
}

pub struct Bindings {
    webidl: String,
    shared_header: String,
    sources: Vec<Source>,
}

/// Generate uniffi component bindings for Gecko.
///
/// Bindings to a Rust interface for Gecko involves more than just generating a
/// `.cpp` file.
pub fn write_bindings(
    ci: &ComponentInterface,
    out_dir: &Path,
    _try_format_code: bool,
) -> Result<()> {
    use heck::CamelCase;

    let out_path = PathBuf::from(out_dir);

    let Bindings {
        webidl,
        shared_header,
        sources,
    } = generate_bindings(&ci)?;

    let mut webidl_file = out_path.clone();
    webidl_file.push(format!("{}.webidl", ci.namespace().to_camel_case()));
    let mut w = File::create(&webidl_file).context("Failed to create WebIDL file for bindings")?;
    write!(w, "{}", webidl)?;

    let mut shared_header_file = out_path.clone();
    shared_header_file.push(format!("{}Shared.h", ci.namespace().to_camel_case()));
    let mut h = File::create(&shared_header_file)
        .context("Failed to create shared header file for bindings")?;
    write!(h, "{}", shared_header)?;

    for Source {
        name,
        header,
        source,
    } in sources
    {
        let mut header_file = out_path.clone();
        header_file.push(format!("{}.h", name));
        let mut h = File::create(&header_file).context(format!(
            "Failed to create header file for `{}` bindings",
            name
        ))?;
        write!(h, "{}", header)?;

        let mut source_file = out_path.clone();
        source_file.push(format!("{}.cpp", name));
        let mut w = File::create(&source_file).context(format!(
            "Failed to create header file for `{}` bindings",
            name
        ))?;
        write!(w, "{}", source)?;
    }

    Ok(())
}

/// Generate Gecko bindings for the given ComponentInterface, as a string.
pub fn generate_bindings(ci: &ComponentInterface) -> Result<Bindings> {
    let config = Config::from(&ci);
    use askama::Template;
    use heck::CamelCase;

    let webidl = WebIdl::new(&config, &ci)
        .render()
        .context("Failed to render WebIDL bindings")?;

    // Firefox's WebIDL code generator (`Codegen.py`) expects to find one
    // C++ header and implementation file per interface, even if we only output
    // one WebIDL file. Dictionaries and enums are autogenerated, but we still
    // need to output a "shared" header file with our serialization helpers, and
    // serializers for the autogenerated types. This is different from other
    // languages, where we can just spit out a single source file for the entire
    // library.

    let shared_header = SharedHeader::new(&config, &ci)
        .render()
        .context("Failed to render shared header")?;

    let mut sources = Vec::new();

    // Top-level functions go in one namespace, which needs its own header and
    // source file.
    let functions = ci.iter_function_definitions();
    if !functions.is_empty() {
        let header = NamespaceHeader::new(&config, &ci, functions.as_slice())
            .render()
            .context("Failed to render top-level namespace header")?;
        let source = Namespace::new(&config, &ci, functions.as_slice())
            .render()
            .context("Failed to render top-level namespace binding")?;
        sources.push(Source {
            name: ci.namespace().to_camel_case(),
            header,
            source,
        });
    }

    // Now generate one header/source pair for each interface.
    let objects = ci.iter_object_definitions();
    for obj in objects {
        let header = InterfaceHeader::new(&config, &ci, &obj)
            .render()
            .context(format!("Failed to render {} header", obj.name()))?;
        let source = Interface::new(&config, &ci, &obj)
            .render()
            .context(format!("Failed to render {} binding", obj.name()))?;
        sources.push(Source {
            name: obj.name().to_camel_case(),
            header,
            source,
        });
    }

    Ok(Bindings {
        webidl,
        shared_header,
        sources,
    })
}
