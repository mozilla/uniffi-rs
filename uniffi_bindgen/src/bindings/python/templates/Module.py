{{ docstring|docstring(0) -}}
# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
{%- if has_async_fns %}
import asyncio
from collections.abc import Awaitable
{%- endif %}
import platform
{%- for import in imports %}
import {{ import }}
{%- endfor %}


# Used for default argument values
_DEFAULT = object() # type: typing.Any

{% include "RustBufferTemplate.py" %}
{% include "Helpers.py" %}
{% include "HandleMap.py" %}
{% include "RustBufferHelper.py" %}
{%- if has_callback_interface %}
{%- include "CallbackInterfaceRuntime.py" %}
{%- endif %}

# Contains loading, initialization code, and the FFI Function declarations.
{% include "NamespaceLibraryTemplate.py" %}

{# Async support comes after NamespaceLibraryTemplate, since it depends on the FFI types #}
{%- if has_async_fns %}
{%- include "Async.py" %}
{%- endif %}

# Public interface members begin here.
{% include "Types.py" %}

{%- for func in functions %}
{%- include "TopLevelFunctionTemplate.py" %}
{%- endfor %}

__all__ = [
    {%- for name in exported_names %}
    "{{ name }}",
    {%- endfor %}
]
