// All type-specific logic for the scaffolding templates lives here.
//
use super::*;

/// Name of the type used in Rust code
pub fn rust_type(type_: &Type) -> String {
    match type_ {
        Type::Int8 => "i8".into(),
        Type::UInt8 => "u8".into(),
        Type::Int16 => "i16".into(),
        Type::UInt16 => "u16".into(),
        Type::Int32 => "i32".into(),
        Type::UInt32 => "u32".into(),
        Type::Int64 => "i64".into(),
        Type::UInt64 => "u64".into(),
        Type::Float32 => "f32".into(),
        Type::Float64 => "f64".into(),
        Type::Boolean => "bool".into(),
        Type::String => "String".into(),
        Type::Timestamp => "std::time::SystemTime".into(),
        Type::Duration => "std::time::Duration".into(),
        Type::Enum(name) | Type::Record(name) | Type::Error(name) => name.clone(),
        Type::Object(name) => format!("std::sync::Arc<{}>", name),
        Type::CallbackInterface(name) => format!("Box<dyn {}>", name),
        Type::Optional(t) => format!("Option<{}>", rust_type(t)),
        Type::Sequence(t) => format!("Vec<{}>", rust_type(t)),
        Type::Map(t) => format!("std::collections::HashMap<String, {}>", rust_type(t)),
    }
}

/// Name of the FfiConverter for this type
///
/// - For primitives / standard types this is the type itself.
/// - For user-defined types, this is a unique generated name.  We then generate a unit-struct
pub fn ffi_converter_name(type_: &Type) -> String {
    match type_ {
        // Generated in the template code, where we create a unit struct to implement FfiConverter.
        // We use a unit-struct to sidestep Rust's orphan rules (ADR-0006).
        Type::Enum(_) | Type::Record(_) | Type::Error(_) => {
            format!("FfiConverter{}", type_.canonical_name())
        }
        // Generated by CallbackTemplate.rs.  We define a proxy struct to forward callbacks back
        // across the FFI, then implement FFIConverter on that.
        Type::CallbackInterface(_) => {
            format!("FfiConverter{}", type_.canonical_name())
        }
        // Generated by ObjectTemplate.rs, using an Arc<T> as the RustType
        Type::Object(name) => format!("std::sync::Arc<{}>", name),
        // These are defined in the uniffi crate.  We implement FfiConverter on the type itself
        Type::Int8 => "i8".into(),
        Type::UInt8 => "u8".into(),
        Type::Int16 => "i16".into(),
        Type::UInt16 => "u16".into(),
        Type::Int32 => "i32".into(),
        Type::UInt32 => "u32".into(),
        Type::Int64 => "i64".into(),
        Type::UInt64 => "u64".into(),
        Type::Float32 => "f32".into(),
        Type::Float64 => "f64".into(),
        Type::String => "String".into(),
        Type::Boolean => "bool".into(),
        Type::Timestamp => "std::time::SystemTime".into(),
        Type::Duration => "std::time::Duration".into(),
        Type::Optional(inner) => format!("Option<{}>", ffi_converter_name(inner)),
        Type::Sequence(inner) => format!("Vec<{}>", ffi_converter_name(inner)),
        Type::Map(inner) => format!("HashMap<String, {}>", ffi_converter_name(inner)),
    }
}
