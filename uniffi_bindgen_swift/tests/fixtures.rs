/* This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use anyhow::{bail, Context, Result};
use heck::SnakeCase;
use std::env;
use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};
use std::path::{Path, PathBuf};
use std::process::Command;
use uniffi_testing::UniFFITestHelper;

/// Run the test fixtures from UniFFI

fn run_test(fixture_name: &str, script_file: &str) -> Result<()> {
    let script_path = Path::new(".")
        .join("tests")
        .join(script_file)
        .canonicalize()
        .context("script_path canonicalize")?;
    let test_helper = UniFFITestHelper::new(fixture_name).context("UniFFITestHelper::new")?;
    let out_dir = test_helper
        .create_out_dir(env!("CARGO_TARGET_TMPDIR"), &script_path)
        .context("create_out_dir()")?;
    test_helper
        .copy_cdylibs_to_out_dir(&out_dir)
        .context("copy_cdylibs_to_out_dir()")?;
    let library_name = calc_library_name(&out_dir)?;
    let generated_sources =
        GeneratedSources::new(&out_dir, &test_helper).context("generate_sources()")?;

    // Compile the generated sources together to create the swift module as a .so file
    let bindings_mod = generated_sources.bindings_module_name()?;
    // FIXME: We should use DLL_SUFFIX instead of hardcoding ".dylib", however right now the harded
    // ".dylib" is doing some work by preventing filename collisions between the bindings module
    // and the Rust dylib.  For example, in callbacks example the would both be named
    // "libcallbacks.so" and would overwrite each other.  This is obviously very fragile and we
    // should make a different system for it.
    //
    // Once we do that, we can also remove the `-o` argument.
    //
    // See #1194 for more info.
    let bindings_filename = format!("{}{}{}", DLL_PREFIX, bindings_mod, ".dylib");
    let mut command = Command::new("swiftc");
    command
        .current_dir(&out_dir)
        .arg("-emit-module")
        .arg("-module-name")
        .arg(&bindings_mod)
        .arg("-o")
        .arg(&bindings_filename)
        .arg("-emit-library")
        .arg("-Xcc")
        .arg(format!(
            "-fmodule-map-file={}",
            generated_sources.module_map.to_string_lossy()
        ))
        .arg(generated_sources.swift_module);
    let status = command
        .spawn()
        .context("Failed to spawn `swiftc` when compiling bindings")?
        .wait()
        .context("Failed to wait for `swiftc` when compiling bindings")?;
    if !status.success() {
        bail!(
            "running `swiftc` to compile bindings failed ({:?})",
            command
        )
    }

    // Run the test script against compiled bindings

    let mut command = Command::new("swift");
    command
        .current_dir(&out_dir)
        .arg("-I")
        .arg(&out_dir)
        .arg("-L")
        .arg(&out_dir)
        .arg(format!("-l{}", &bindings_filename))
        .arg(format!("-l{}", &library_name))
        .arg("-Xcc")
        .arg(format!(
            "-fmodule-map-file={}",
            generated_sources.module_map.to_string_lossy()
        ))
        .arg(&script_path);
    let status = command
        .spawn()
        .context("Failed to spawn `swiftc` when running test script")?
        .wait()
        .context("Failed to wait for `swiftc` when running test script")?;
    if !status.success() {
        bail!("running `swift` to run test script failed ({:?})", command)
    }
    Ok(())
}

// Stores sources generated by `uniffi-bindgen-swift`
struct GeneratedSources {
    swift_module: PathBuf,
    module_map: PathBuf,
}

impl GeneratedSources {
    fn new(out_dir: &Path, test_helper: &UniFFITestHelper) -> Result<Self> {
        for source in test_helper.get_compile_sources()? {
            let mut cmd_line = vec![
                "uniffi-bindgen-swift".to_string(),
                "--out-dir".to_string(),
                out_dir.to_string_lossy().to_string(),
                "--no-format".to_string(),
            ];
            if let Some(path) = source.config_path {
                cmd_line.push("--config-path".to_string());
                cmd_line.push(path.to_string_lossy().to_string())
            }
            cmd_line.push(source.udl_path.to_string_lossy().to_string());
            uniffi_bindgen_swift::run(cmd_line)?;
        }
        Ok(GeneratedSources {
            swift_module: glob1(out_dir.join("*.swift"))?,
            module_map: glob1(out_dir.join("*.modulemap"))?,
        })
    }

    pub fn bindings_module_name(&self) -> Result<String> {
        Ok(self
            .swift_module
            .file_name()
            .unwrap()
            .to_string_lossy()
            .strip_suffix(".swift")
            .context("bindings_module_name()")?
            .to_snake_case())
    }
}

// Get a single path from a globspec
fn glob1(globspec: PathBuf) -> Result<PathBuf> {
    let mut paths = glob::glob(&globspec.to_string_lossy())?;
    let first = paths
        .next()
        .unwrap_or_else(|| panic!("globspec {:?} returned 0 results", &globspec));
    if paths.next().is_some() {
        bail!(format!(
            "globspec {:?} returned multiple results",
            &globspec
        ));
    }
    Ok(first?.canonicalize()?)
}

fn calc_library_name(out_dir: &Path) -> Result<String> {
    let library_path = glob1(out_dir.join(format!("{}*{}", DLL_PREFIX, DLL_SUFFIX)))?;
    Ok(library_path
        .file_name()
        .unwrap()
        .to_string_lossy()
        .strip_prefix(DLL_PREFIX)
        .unwrap()
        .strip_suffix(DLL_SUFFIX)
        .unwrap()
        .to_string())
}

macro_rules! fixture_tests {
    {
        $(($test_name:ident, $fixture_name:expr, $test_script:expr),)*
    } => {
    $(
        #[test]
        fn $test_name() -> Result<()> {
            run_test($fixture_name, $test_script)
        }
    )*
    }
}

fixture_tests! {
    // Examples
    (test_arithmetic,        "uniffi-example-arithmetic",   "scripts/test_arithmetic.swift"),
    (test_callbacks_example, "uniffi-example-callbacks",    "scripts/test_callbacks_example.swift"),
    (test_custom_types,      "uniffi-example-custom-types", "scripts/test_custom_types.swift"),
    (test_geometry,          "uniffi-example-geometry",     "scripts/test_geometry.swift"),
    (test_rondpoint,         "uniffi-example-rondpoint",    "scripts/test_rondpoint.swift"),
    (test_sprites,           "uniffi-example-sprites",      "scripts/test_sprites.swift"),
    (test_todolist,          "uniffi-example-todolist",     "scripts/test_todolist.swift"),
    // // Fixtures
    (test_callbacks,           "uniffi-fixture-callbacks",      "scripts/test_callbacks.swift"),
    (test_chronological,       "uniffi-fixture-time",           "scripts/test_chronological.swift"),
    (test_coverall,            "uniffi-fixture-coverall",       "scripts/test_coverall.swift"),
    (test_external_types,      "uniffi-fixture-external-types", "scripts/test_external_types.swift"),
    // // Regression tests
    (test_cdylib_crate_dependency,     "uniffi-fixture-regression-cdylib-dependency-ffi-crate",        "scripts/test_cdylib_crate_dependency.swift"),
    (test_enum_without_i32_helpers,    "uniffi-fixture-regression-i356-enum-without-int-helpers",      "scripts/test_enum_without_i32_helpers.swift"),
    (test_omit_argument_labels, "uniffi-fixture-swift-omit-argument-labels", "scripts/test_omit_argument_labels.swift"),
}
